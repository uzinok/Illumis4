(function () {
	function r(e, n, t) {
		function o(i, f) {
			if (!n[i]) {
				if (!e[i]) {
					var c = "function" == typeof require && require;
					if (!f && c) return c(i, !0);
					if (u) return u(i, !0);
					var a = new Error("Cannot find module '" + i + "'");
					throw a.code = "MODULE_NOT_FOUND", a
				}
				var p = n[i] = {
					exports: {}
				};
				e[i][0].call(p.exports, function (r) {
					var n = e[i][1][r];
					return o(n || r)
				}, p, p.exports, r, e, n, t)
			}
			return n[i].exports
		}
		for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
		return o
	}
	return r
})()({
	1: [function (require, module, exports) {
		"use strict";
		var patientcore = window.patientcore = {
			throttle: function throttle(fn, threshhold, scope) {
				threshhold || (threshhold = 250);
				var last, deferTimer;
				return function () {
					var context = scope || this;
					var now = +new Date,
						args = arguments;
					if (last && now < last + threshhold) {
						clearTimeout(deferTimer);
						deferTimer = setTimeout(function () {
							last = now;
							fn.apply(context, args)
						}, threshhold)
					} else {
						last = now;
						fn.apply(context, args)
					}
				}
			},
			layout: {
				_callbacks: [],
				_current: null,
				_initialized: false,
				set: function set(layout) {
					var layoutHasChanged = patientcore.layout._current !== layout;
					patientcore.layout._current = layout;
					var callbacks = patientcore.layout._callbacks.sort(function (a, b) {
						return a.index - b.index
					});
					for (var i = 0; i < callbacks.length; i++) {
						var callback = callbacks[i];
						if (patientcore.layout._initialized && layoutHasChanged || !patientcore.layout._initialized && !callback.init) {
							callback.fn(layout)
						}
					}
					patientcore.layout._initialized = true
				},
				ready: function ready(callback, index) {
					if (patientcore.layout._current) {
						callback(patientcore.layout._current);
						patientcore.layout._callbacks.push({
							index: index,
							init: true,
							fn: callback
						})
					} else {
						patientcore.layout._callbacks.push({
							index: index,
							init: false,
							fn: callback
						})
					}
				}
			},
			prelayout: {
				_callbacks: [],
				_initialized: false,
				set: function set() {
					var callbacks = patientcore.prelayout._callbacks;
					var pathname = window.location.pathname;
					for (var i = 0, len = callbacks.length; i < len; i++) {
						var callback = callbacks[i];
						if (callback.options) {
							if (callback.options.excludedPaths.indexOf(pathname) > -1) {
								continue
							}
						}
						callback.fn()
					}
					patientcore.prelayout._initialized = true;
					patientcore.prelayout._callbacks.length = 0
				},
				ready: function ready(callback, options) {
					if (patientcore.prelayout._initialized) {
						callback()
					} else {
						patientcore.prelayout._callbacks.push({
							options: options,
							fn: callback
						})
					}
				}
			},
			debounce: function debounce(func, wait, immediate) {
				var timeout;
				return function () {
					var context = this,
						args = arguments;
					var later = function later() {
						timeout = null;
						if (!immediate) func.apply(context, args)
					};
					var callNow = immediate && !timeout;
					clearTimeout(timeout);
					timeout = setTimeout(later, wait);
					if (callNow) func.apply(context, args)
				}
			},
			cookies: {
				get: function get(cname) {
					var name = cname + "=";
					var decodedCookie = decodeURIComponent(document.cookie);
					var ca = decodedCookie.split(";");
					for (var i = 0; i < ca.length; i++) {
						var c = ca[i];
						while (c.charAt(0) === " ") {
							c = c.substring(1)
						}
						if (c.indexOf(name) === 0) {
							return c.substring(name.length, c.length)
						}
					}
					return null
				},
				set: function set(cname, cvalue, exdays, domain) {
					var d = new Date;
					var maxAge = exdays * 24 * 60 * 60;
					d.setTime(d.getTime() + maxAge * 1e3);
					var expires = "expires=" + d.toUTCString() + ";max-age=" + maxAge;
					document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/" + (domain !== null ? ";domain=" + domain : "")
				},
				remove: function remove(cname) {
					this.set(cname, "", -1)
				}
			},
			localStorageAvailable: function localStorageAvailable() {
				try {
					localStorage.setItem("_test", 1);
					localStorage.removeItem("_test");
					return true
				} catch (e) {
					return false
				}
			}
		};
		var escapeScriptCharsAlone = false;
		String.prototype.escape = function (escapeScriptCharsAlone) {
			var tagsToReplace = {
				"&": "&amp;",
				"<": "&lt;",
				">": "&gt;",
				'"': "&quot;",
				"/": "&#x2F;",
				"'": "&#x27;"
			};
			if (escapeScriptCharsAlone) {
				return this.replace(/[<>]/g, function (tag) {
					return tagsToReplace[tag] || tag
				})
			} else {
				return this.replace(/[&<>'/"]/g, function (tag) {
					return tagsToReplace[tag] || tag
				})
			}
		};
		patientcore.prelayout.ready(function () {
			$(function () {
				$("input[type='text'],textarea").bind("change keyup input", function () {
					var inputText = $(this).val();
					$(this).val(inputText.escape(true))
				})
			})
		})
	}, {}],
	2: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			require("../../components/02-global/@header/header")(patientcore, patient);
			require("../../components/02-global/@modal/modal")(patientcore, patient);
			require("../../components/02-global/@alert/alert")(patientcore, patient);
			require("../../components/01-elements/@popover/popover")(patientcore, patient);
			require("../../components/01-elements/@field/field")(patientcore, patient);
			require("../../components/03-editorial/@references/references")(patientcore, patient);
			require("../../components/03-editorial/@playlist/playlist")(patientcore, patient);
			require("../../components/04-hubs/@az/az")(patientcore, patient);
			require("../../components/04-articles/@feedback/feedback")(patientcore, patient);
			require("../../components/05-search/@search/search")(patientcore, patient);
			require("../../components/05-search/@search-filter/search-filter")(patientcore, patient);
			require("../../components/06-account/@notes-modal/notes-modal")(patientcore, patient);
			require("../../components/07-symptom-checker/@helpbox/helpbox")(patientcore, patient);
			require("../../components/08-recipes/@accordion/accordion")(patientcore, patient);
			require("../../components/08-recipes/@recipe-ingredients/recipe-ingredients")(patientcore, patient);
			require("../../components/10-other/@subnav/subnav")(patientcore, patient);
			require("../../components/10-other/@subnav-modal/subnav-modal")(patientcore, patient);
			require("../../components/10-other/@action-menu/action-menu")(patientcore, patient);
			require("../../components/10-other/@series-nav/series-nav")(patientcore, patient);
			require("../../components/10-other/@card-carousel/card-carousel")(patientcore, patient);
			require("../../components/10-other/@card-carousel/card-carousel-hcp")(patientcore);
			require("../../components/10-other/@featured-card/featured-card")(patientcore, patient);
			require("../../components/10-other/@progressive-images/progressive-images")(patientcore, patient)
		}
	}, {
		"../../components/01-elements/@field/field": 7,
		"../../components/01-elements/@popover/popover": 8,
		"../../components/02-global/@alert/alert": 9,
		"../../components/02-global/@header/header": 10,
		"../../components/02-global/@modal/modal": 11,
		"../../components/03-editorial/@playlist/playlist": 12,
		"../../components/03-editorial/@references/references": 13,
		"../../components/04-articles/@feedback/feedback": 14,
		"../../components/04-hubs/@az/az": 15,
		"../../components/05-search/@search-filter/search-filter": 16,
		"../../components/05-search/@search/search": 17,
		"../../components/06-account/@notes-modal/notes-modal": 18,
		"../../components/07-symptom-checker/@helpbox/helpbox": 19,
		"../../components/08-recipes/@accordion/accordion": 20,
		"../../components/08-recipes/@recipe-ingredients/recipe-ingredients": 21,
		"../../components/10-other/@action-menu/action-menu": 22,
		"../../components/10-other/@card-carousel/card-carousel": 24,
		"../../components/10-other/@card-carousel/card-carousel-hcp": 23,
		"../../components/10-other/@featured-card/featured-card": 25,
		"../../components/10-other/@progressive-images/progressive-images": 26,
		"../../components/10-other/@series-nav/series-nav": 27,
		"../../components/10-other/@subnav-modal/subnav-modal": 28,
		"../../components/10-other/@subnav/subnav": 29
	}],
	3: [function (require, module, exports) {
		(function (global) {
			(function () {
				"use strict";
				var $ = global.$ = require("jquery");
				require("@webcomponents/template");
				require("es6-promise").polyfill();
				require("./polyfills/closest")();
				var patient = global.patient = {
					$window: $(window),
					$document: $(document),
					$html: $(document.documentElement),
					$body: $(document.body),
					events: $({}),
					state: {
						ready: false,
						scrollPos: 0,
						scrollDirection: null,
						breakpoint: null,
						waypoint: null
					},
					breakpoints: [{
						name: "min",
						layout: "a"
					}, {
						name: "small",
						width: 560,
						layout: "a"
					}, {
						name: "medium",
						width: 728,
						layout: "b"
					}, {
						name: "large",
						width: 1024,
						layout: "c"
					}, {
						name: "xlarge",
						width: 1180,
						layout: "d"
					}, {
						name: "max",
						width: 1350,
						layout: "d"
					}],
					scroll: function Scroll(selector) {
						$("html,body").animate({
							scrollTop: $(selector).offset().top - 50
						}, "slow")
					}
				};
				patient.events.on("modal.open", function () {
					patient.$body.addClass("is-locked modal-open")
				});
				patient.events.on("modal.close", function () {
					patient.$body.removeClass("is-locked modal-open")
				});
				patient.$document.keyup(function (e) {
					if (e.keyCode === 27) {
						patient.events.trigger("modal.close")
					}
				});
				require("./scroll")(global.patientcore, patient);
				require("./components")(global.patientcore, patient);
				require("./mq")(patient);
				patient.$window.trigger("resize")
			}).call(this)
		}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	}, {
		"./components": 2,
		"./mq": 4,
		"./polyfills/closest": 5,
		"./scroll": 6,
		"@webcomponents/template": 30,
		"es6-promise": 38,
		jquery: 40
	}],
	4: [function (require, module, exports) {
		"use strict";
		var enquire = require("enquire.js");
		module.exports = function (patient) {
			var _loop = function _loop() {
				var breakpoint = patient.breakpoints[i];
				var minWidth = breakpoint.width;
				var maxWidth = patient.breakpoints[i + 1] ? patient.breakpoints[i + 1].width - 1 : null;
				enquire.register("screen ".concat(minWidth ? "and (min-width: ".concat(minWidth, "px)") : "", " ").concat(maxWidth ? "and (max-width: ".concat(maxWidth, "px)") : ""), {
					match: function match() {
						if (patient.state.breakpoint !== breakpoint.name) {
							patient.state.breakpoint = breakpoint;
							patient.events.trigger("breakpoint.match", breakpoint)
						}
					},
					unmatch: function unmatch() {
						patient.events.trigger("breakpoint.unmatch", breakpoint)
					}
				})
			};
			for (var i = 0, len = patient.breakpoints.length; i < len; i++) {
				_loop()
			}
		}
	}, {
		"enquire.js": 37
	}],
	5: [function (require, module, exports) {
		"use strict";
		module.exports = function () {
			if (!Element.prototype.matches) {
				Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector
			}
			if (!Element.prototype.closest) {
				Element.prototype.closest = function (s) {
					var el = this;
					if (!document.documentElement.contains(el)) return null;
					do {
						if (el.matches(s)) return el;
						el = el.parentElement || el.parentNode
					} while (el !== null && el.nodeType === 1);
					return null
				}
			}
		}
	}, {}],
	6: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var scroll = function scroll(scrollPos) {
					patient.events.trigger("window.scrolled", scrollPos)
				};
				var raf = patient.$window.requestAnimationFrame || patient.$window.webkitRequestAnimationFrame || patient.$window.mozRequestAnimationFrame || patient.$window.msRequestAnimationFrame || patient.$window.oRequestAnimationFrame;
				var lastScrollTop = patient.$window.scrollTop();
				if (raf) {
					loop()
				}

				function loop() {
					var scrollTop = patient.$window.scrollTop();
					if (lastScrollTop === scrollTop) {
						return
					} else {
						lastScrollTop = scrollTop;
						scroll(lastScrollTop);
						raf(loop)
					}
				}
			})
		}
	}, {}],
	7: [function (require, module, exports) {
		"use strict";
		var Pikaday = require("pikaday");
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var dateFields = document.querySelectorAll('[data-field="date"]');
				var dateCount = 0;
				if (dateFields.length) {
					var dateMax = new Date;
					dateMax.setDate(dateMax.getDate() + 2);
					[].forEach.call(dateFields, function (e) {
						e.setAttribute("type", "text");
						var picker = new Pikaday({
							field: dateFields[dateCount],
							format: "DD MMM YYYY",
							minDate: new Date(2e3, 12, 31),
							maxDate: dateMax,
							onSelect: function onSelect(d) {
								var target = $(this._o.field).data("date-target");
								if (target) {
									var $el = $(target);
									if ($el.length > 0) {
										var date = ("00" + d.getDate()).slice(-2);
										var month = ("00" + (d.getMonth() + 1)).slice(-2);
										$el.val(d.getFullYear() + "-" + month + "-" + date)
									}
								}
							}
						});
						dateCount++
					})
				}
			})
		}
	}, {
		pikaday: 41
	}],
	8: [function (require, module, exports) {
		"use strict";
		var Popper = require("popper.js");
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var nativeTriggers = document.querySelectorAll("[data-popover]");
				var nativeTriggersTitle = document.querySelectorAll("[data-title]");
				if (nativeTriggers.length || nativeTriggersTitle.length) {
					var popovers = [];
					document.body.addEventListener("click", function () {
						popovers.forEach(function (el) {
							return el.hide()
						})
					}, false);
					[].forEach.call(nativeTriggers, function (e) {
						var trigger = $(e);
						var popover = $(trigger.attr("data-popover"));
						if (popover) {
							popovers.push(popover);
							var popper = new Popper(trigger, popover, {
								placement: "bottom"
							});
							patient.$window.on("resize", function () {
								return popper.update()
							});
							trigger.on("click", function () {
								popover.toggle();
								popper.update();
								return false
							});
							popover.on("click", function (e) {
								e.stopPropagation()
							})
						}
					});
					[].forEach.call(nativeTriggersTitle, function (e) {
						var trigger = $(e);
						var hoverTitle = $(trigger.attr("data-title"));
						var isTouchDevice = "ontouchstart" in window || navigator.msMaxTouchPoints > 0;
						if (hoverTitle && !isTouchDevice) {
							popovers.push(hoverTitle);
							var popper = new Popper(trigger, hoverTitle, {
								placement: "bottom"
							});
							patient.$window.on("resize", function () {
								return popper.update()
							});
							trigger.on("mouseenter", function () {
								hoverTitle.show();
								popper.update();
								return false
							});
							trigger.on("mouseleave", function () {
								hoverTitle.hide();
								popper.update();
								return false
							})
						}
						return false
					})
				}
			})
		}
	}, {
		"popper.js": 42
	}],
	9: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var alerts = document.querySelectorAll('[data-component="alert"]');
				var _loop = function _loop() {
					var alert = alerts[i];
					var close = alert.querySelector("[data-close]");
					if (!close) return "continue";
					close.addEventListener("click", function (e) {
						e.preventDefault();
						patient.events.trigger("alert.closed", $(alert));
						alert.parentNode.removeChild(alert)
					})
				};
				for (var i = 0, len = alerts.length; i < len; i++) {
					var _ret = _loop();
					if (_ret === "continue") continue
				}
			})
		}
	}, {}],
	10: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var nativeHeader = document.getElementById("header");
				if (nativeHeader != null && nativeHeader.length) {
					var header = $(nativeHeader);
					var toggles = header.find("[data-toggle]");
					toggles.on("click", function (e) {
						var toggle = $(this);
						var target = $(toggle.attr("href"));
						if (target.is(":visible")) {
							toggle.removeClass("is-active");
							target.removeClass("is-open")
						} else {
							toggle.addClass("is-active");
							target.addClass("is-open");
							patient.events.trigger("header.toggle-opened", toggle)
						}
						e.stopPropagation();
						return false
					});
					["click", "tap"].forEach(function (e) {
						document.body.addEventListener(e, function () {
							toggles.each(function () {
								var toggle = $(this);
								toggle.removeClass("is-active");
								$(toggle.attr("href")).removeClass("is-open")
							})
						}, false)
					});
					patient.events.on("window.scrolled", function (event, scrollTop) {
						var catchTrigger = $("[data-header-push]");
						if (catchTrigger.length) {
							var catchPosition = catchTrigger.offset().top;
							var catchScrollPosition = catchPosition - header.outerHeight();
							var headerPos = header.offset().top;
							if (scrollTop <= catchScrollPosition) {
								header.addClass("is-pinned");
								header.css("top", 0)
							} else if (scrollTop <= catchScrollPosition + header.outerHeight()) {
								header.removeClass("is-pinned");
								header.css("top", catchScrollPosition)
							}
							if (headerPos > catchScrollPosition) {
								header.css("visibility", "hidden")
							} else {
								header.css("visibility", "")
							}
						} else {
							header.addClass("is-pinned");
							header.css("top", 0)
						}
					})
				}
			})
		};

		function sticky_ads() {
			var sidebar = document.getElementsByClassName("sidebar")[0];
			var inline_ad = document.getElementsByClassName("inline-content")[0];
			var inline_ad_offset_top = undefined;
			var leaderboard = document.getElementById("leaderboard");
			if (leaderboard && sidebar && window.innerWidth > 1024) {
				var rightrailPlacement = document.getElementsByClassName("advertSlot--vertical")[0];
				var childrenCount = rightrailPlacement.getElementsByClassName("advertSlot__section").length;
				sidebar = rightrailPlacement.getElementsByClassName("advertSlot__section")[childrenCount - 1];
				if (document.getElementById("taboola-below-article-redesign")) {
					var taboola_section = document.getElementById("taboola-below-article-redesign").closest(".slat");
					var article_div = taboola_section.previousElementSibling
				}
				var header = document.getElementById("header");
				var leaderboard_inital_offset_top = leaderboard.offsetTop;
				var sidebar_inital_offset_top = sidebar.offsetTop;
				var header_initial_height = header.offsetHeight;
				if (leaderboard && sidebar && getComputedStyle(sidebar).display !== "none") {
					leaderboard.style.cssText = "position: -webkit-sticky;position: sticky;";
					leaderboard.style.top = "0px";
					window.addEventListener("scroll", function () {
						var side_ads_top_value = "0.5rem";
						if (leaderboard.offsetHeight >= 250) {
							if (window.scrollY >= (sidebar_inital_offset_top - leaderboard.offsetHeight) / 4) {
								leaderboard.style.position = "relative"
							} else if (window.scrollY < (sidebar_inital_offset_top - leaderboard.offsetHeight) / 4) {
								leaderboard.style.cssText = "position: -webkit-sticky;position: sticky;";
								leaderboard.style.top = "0px";
								side_ads_top_value = "15.5rem"
							}
						} else {
							if (window.scrollY >= (sidebar_inital_offset_top - leaderboard.offsetHeight) / 4) {
								leaderboard.style.position = "relative"
							} else if (window.scrollY < (sidebar_inital_offset_top - leaderboard.offsetHeight) / 4) {
								leaderboard.style.cssText = "position: -webkit-sticky;position: sticky;";
								leaderboard.style.top = "0px";
								side_ads_top_value = "6.5rem"
							}
						}
						$(".advert--sticky").css("top", side_ads_top_value);
						$(".sidebar__ads .ad-300").css("top", side_ads_top_value)
					})
				} else if (leaderboard && sidebar && getComputedStyle(sidebar).display == "none") {
					leaderboard.style.cssText = "position: -webkit-sticky;position: sticky;";
					leaderboard.style.top = "0px";
					window.addEventListener("scroll", function () {
						if (article_div) {
							if (window.scrollY >= article_div.offsetTop + article_div.offsetHeight - leaderboard.offsetHeight) {
								leaderboard.style.position = "relative"
							} else if (window.scrollY < article_div.offsetTop + article_div.offsetHeight - leaderboard.offsetHeight) {
								leaderboard.style.cssText = "position: -webkit-sticky;position: sticky;";
								leaderboard.style.top = "0px"
							}
						}
					})
				}
			} else if (leaderboard && inline_ad && window.innerWidth > 728) {
				if (document.getElementById("taboola-below-article-redesign")) {
					var taboola_section = document.getElementById("taboola-below-article-redesign").closest(".slat");
					var article_div = taboola_section.previousElementSibling
				}
				if (leaderboard && inline_ad && getComputedStyle(inline_ad).display !== "none") {
					leaderboard.style.cssText = "position: -webkit-sticky;position: sticky;";
					leaderboard.style.top = "0px";
					window.addEventListener("scroll", function () {
						inline_ad_offset_top = inline_ad.offsetTop;
						if (leaderboard.offsetHeight >= 250) {
							if (window.scrollY >= (inline_ad_offset_top - leaderboard.offsetHeight) / 4) {
								leaderboard.style.position = "relative"
							} else if (window.scrollY < (inline_ad_offset_top - leaderboard.offsetHeight) / 4) {
								leaderboard.style.cssText = "position: -webkit-sticky;position: sticky;";
								leaderboard.style.top = "0px"
							}
						} else {
							if (window.scrollY >= inline_ad_offset_top - leaderboard.offsetHeight) {
								leaderboard.style.position = "relative"
							} else if (window.scrollY < inline_ad_offset_top - leaderboard.offsetHeight) {
								leaderboard.style.cssText = "position: -webkit-sticky;position: sticky;";
								leaderboard.style.top = "0px"
							}
						}
					})
				}
			} else if (leaderboard && window.innerWidth > 728) {
				if (document.getElementById("taboola-below-article-redesign")) {
					var taboola_section = document.getElementById("taboola-below-article-redesign").closest(".slat");
					var article_div = taboola_section.previousElementSibling
				}
				leaderboard.style.cssText = "position: -webkit-sticky;position: sticky;";
				leaderboard.style.top = "0px";
				window.addEventListener("scroll", function () {
					if (article_div) {
						if (window.scrollY >= article_div.offsetTop + article_div.offsetHeight - leaderboard.offsetHeight) {
							leaderboard.style.position = "relative"
						} else if (window.scrollY < article_div.offsetTop + article_div.offsetHeight - leaderboard.offsetHeight) {
							leaderboard.style.cssText = "position: -webkit-sticky;position: sticky;";
							leaderboard.style.top = "0px"
						}
					}
				})
			}
		}
		var countryValue = '';
		window.getIsHptoEnabled = function checkIfEnableHpto() {
			if (typeof window.isMobile == "function") {
				return window.isMobile() || countryValue != "United Kingdom" ? false : JSON.parse(document.getElementsByTagName("body")[0].getAttribute("data-hpto-show").toLowerCase())
			}
		};

		function onLoad() {
			var showHptoAds = window.getIsHptoEnabled();
			if (showHptoAds) {
				var _document$getElementB, _document$getElements, _document$getElementB2, _document$getElementB3;
				(_document$getElementB = document.getElementById("leaderboard")) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.remove();
				(_document$getElements = document.getElementsByTagName("aside")[0]) === null || _document$getElements === void 0 ? void 0 : _document$getElements.remove();
				(_document$getElementB2 = document.getElementById("hubpage__ad")) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.remove();
				(_document$getElementB3 = document.getElementById("adx_native_ad_110955")) === null || _document$getElementB3 === void 0 ? void 0 : _document$getElementB3.remove();
				$(".more-menu").removeClass("inactive");
				$(".menu-non-hpto").addClass("inactive")
			} else {
				sticky_ads();
				$(".menu-non-hpto").addClass("active")
			}
		}
		document.onload = onLoad();
		if (document.getElementById("leaderboard")) {
			var ad_height = document.getElementById("leaderboard").offsetHeight;
			if (document.getElementById("float_nav")) {
				document.getElementById("float_nav").style.bottom = 0
			}
		}
		if (document.getElementById("float_nav")) {
			var float_sec = document.getElementById("next_section");
			var float_height = document.getElementById("float_nav").offsetHeight;
			var mobile_adj = 0;
			window.onscroll = function () {
				if ((window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth) <= 480 && document.getElementById("leaderboard") !== null) {
					mobile_adj = document.getElementById("leaderboard").offsetHeight
				}
				if (float_sec.offsetTop > window.pageYOffset + (window.innerHeight || Math.max(document.documentElement.clientHeight, document.body.clientHeight)) - float_height - mobile_adj) {
					document.getElementById("float_nav").style.visibility = "visible"
				} else {
					document.getElementById("float_nav").style.visibility = "hidden"
				}
			}
		}
		if (document.cookie.indexOf("pi-id") > -1) {
			var pi_id = getCookie("pi-id");
			if (typeof exponea !== "undefined") {
				exponea.identify({
					pi_id: pi_id.toLowerCase()
				})
			}
		}
		if (document.getElementById("forums_popup") !== null) {
			if (!isIOSDevice()) {
				document.getElementById("forums_popup").style.display = "block"
			}
			document.getElementById("popup_close").addEventListener("click", function () {
				document.getElementById("forums_popup").style.display = "none";
				document.cookie = "OptInPopupSession=true; expires=0;domain=.patient.info; path=/"
			});
			document.getElementById("btn_Allow").addEventListener("click", function () {
				CheckNativePopupPermission($(".forums-wrapper"));
				document.getElementById("forums_popup").style.display = "none"
			});
			document.getElementById("btn_dontAllow").addEventListener("click", function () {
				subscribePushNotifications(false, $(".forums-wrapper"));
				document.getElementById("forums_popup").style.display = "none"
			})
		}

		function CheckNativePopupPermission(targetElement) {
			if (Notification.permission === "granted") {
				exponea.notifications.subscribe();
				subscribePushNotifications(true, targetElement)
			} else if (Notification.permission === "default") {
				Notification.requestPermission(function (status) {
					if (status === "granted") {
						exponea.notifications.subscribe();
						subscribePushNotifications(true, targetElement)
					} else {
						subscribePushNotifications(false, targetElement)
					}
				})
			}
		}
		var pushCheckbox = document.getElementById("PushNotificationsEnabled");
		if (pushCheckbox !== null) {
			pushCheckbox.addEventListener("change", function () {
				if (pushCheckbox.checked) {
					CheckNativePopupPermission($("body"))
				}
			});
			if (!isIOSDevice()) {
				var pushElement = document.getElementById("PushNotifications");
				pushElement.classList.remove("hidden")
			}
		}

		function subscribePushNotifications(status, dataTargetElement) {
			var url = dataTargetElement.data("authBaseUrl") + "/pushnotification/signup";
			$.ajax({
				url: url,
				data: {
					userId: dataTargetElement.data("userId"),
					pushNotificationsEnabled: status
				},
				type: "POST",
				dataType: "json",
				success: function success(data) {}
			})
		}

		function isIOSDevice() {
			return !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && (navigator.maxTouchPoints > 1 || navigator.userAgent.toLowerCase().search("safari") >= 0 && navigator.userAgent.toLowerCase().search("chrome") < 0)
		}
		if (document.getElementById("memword_popup") !== null) {
			document.getElementById("memword_popup").style.display = "block";
			if (document.getElementById("btn_skipForNow") != null) {
				document.getElementById("btn_skipForNow").addEventListener("click", function () {
					document.getElementById("memword_popup").style.display = "none"
				})
			}
			if (document.getElementById("btn_setUp") != null) {
				document.getElementById("btn_setUp").addEventListener("click", function () {
					document.getElementById("memword_popup").style.display = "none";
					window.location = $("#memword_popup").data("authBaseUrl") + "/memword-notification?returnUrl=" + location.href
				})
			}
		}
		$(window).on("load", function () {
			$($("#professional-articles-with-ads").detach()).insertAfter(".featured-articles");
			var authorElements = $(".featured-articles .teaser__author");
			var trendingElements = $(".featured-articles .teaser__trending");
			for (var i = 0; i < authorElements.length; i++) {
				authorElements[i].setAttribute("aria-label", "by " + authorElements[i].innerText)
			}
			for (var i = 0; i < trendingElements.length; i++) {
				trendingElements[i].setAttribute("aria-label", "Trending article")
			}
			var isTablet = window.matchMedia("only screen and (max-width: 1024px) and (min-width: 768px)").matches;
			if (isTablet) {
				$(".teaser__article--header-date").each(function () {
					var el = $(this).clone();
					$(this).siblings(".teaser__article--header").append(el);
					$(this).remove()
				})
			}
		});
		var isMobileLeaderboard = (typeof window.isMobile == "function" ? window.isMobile() : false) && window.innerWidth < 1025 ? true : false;
		if (isMobileLeaderboard) {
			var _sidebar$;
			var sidebar = document.getElementsByClassName("sidebar");
			(_sidebar$ = sidebar[0]) === null || _sidebar$ === void 0 ? void 0 : _sidebar$.remove()
		}
	}, {}],
	11: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var nativeModal = patient.$document[0].getElementById("modal");
				if (nativeModal) {
					var modal = $(nativeModal);
					var modalToggles = $("[data-modal]");
					var closeButton = modal.find('[data-role="modal-close"]');
					var content = modal.find('[data-role="modal-content"]');
					modalToggles.addClass("modal-toggle");
					modalToggles.on("click", function () {
						var trigger = $(this);
						var target = trigger.attr("data-modal");
						patient.events.trigger("modal.open", [target, trigger]);
						return false
					});
					closeButton.on("click", function (event) {
						patient.events.trigger("modal.close");
						return false
					});
					patient.events.on("modal.open", function (event, target, trigger) {
						patient.events.trigger("modal.opening", modal);
						content.html($(target).html());
						var focus = modal.find("[data-modal-focus]");
						if (focus.length) {
							focus.focus()
						}
						modal.addClass("is-open");
						patient.events.trigger("modal.opened", [modal, trigger])
					});
					patient.events.on("modal.close", function (event) {
						patient.events.trigger("modal.closing", modal);
						modal.removeClass("is-open");
						patient.events.trigger("modal.closed", modal)
					})
				}
			})
		}
	}, {}],
	12: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var playlists = document.querySelectorAll('[data-component="playlist"]');
				var _loop = function _loop() {
					var playlist = playlists[i];
					var toggles = playlist.querySelectorAll(".button--action");
					var videos = playlist.querySelectorAll("[data-video]");
					var player = playlist.querySelector("[data-player]");
					var playerVideo = player.querySelector("iframe");
					var playerTitle = player.querySelector("[data-video-title]");
					var playerPosition = player.querySelector("[data-position]");
					var playerDescription = player.querySelector("[data-description]");
					var playerAuthor = player.querySelector("[data-author]");
					var _loop2 = function _loop2() {
						var video = videos[c];
						video.addEventListener("click", function (e) {
							e.preventDefault();
							playerVideo.setAttribute("src", video.getAttribute("data-video"));
							playerDescription.innerHTML = video.getAttribute("data-description");
							playerTitle.innerHTML = video.querySelector("[data-video-title]").innerHTML;
							playerAuthor.innerHTML = video.getAttribute("data-author");
							playerAuthor.setAttribute("href", video.getAttribute("data-author-path"));
							var parentPos = 1;
							var child = video.parentNode;
							while ((child = child.previousElementSibling) != null) {
								parentPos++
							}
							playerPosition.innerHTML = parentPos;
							playlist.querySelector(".is-active").classList.remove("is-active");
							video.classList.add("is-active")
						})
					};
					for (c = 0, vLen = videos.length; c < vLen; c++) {
						_loop2()
					}
					for (c = 0, tLen = toggles.length; c < tLen; c++) {
						var toggle = toggles[c];
						toggle.addEventListener("click", function (e) {
							e.preventDefault();
							playlist.classList.toggle("is-open")
						})
					}
				};
				for (var i = 0, len = playlists.length; i < len; i++) {
					var c, vLen;
					var c, tLen;
					_loop()
				}
			})
		}
	}, {}],
	13: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var refs = document.querySelectorAll('[data-component="reference"]');
				var _loop = function _loop() {
					var ref = refs[i];
					var toggle = ref.querySelector('[data-role="reference-toggle"]');
					toggle.addEventListener("click", function () {
						ref.classList.toggle("is-open");
						return false
					})
				};
				for (var i = 0, len = refs.length; i < len; i++) {
					_loop()
				}
			})
		}
	}, {}],
	14: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				$('[data-component="feedback"] [data-feedback]').on("click", function () {
					var choice = $(this);
					var component = choice.closest('[data-component="feedback"]');
					if (!component.hasClass("is-disabled")) {
						var thanks = component.find("[data-thanks]");
						choice.addClass("is-selected");
						thanks.show();
						component.addClass("is-disabled");
						patient.events.trigger("feedback.submitted", choice.attr("data-feedback"))
					}
					return false
				})
			})
		}
	}, {}],
	15: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var az = document.querySelectorAll('[data-component="az"]');
				var _loop = function _loop() {
					var azQuery = az[i];
					var panels = azQuery.querySelectorAll("[data-panel]");
					var tabs = azQuery.querySelectorAll("[data-tab]");
					for (c = 0, tLen = tabs.length; c < tLen; c++) {
						tabs[c].addEventListener("click", clickEvent)
					}

					function clickEvent(e) {
						e.preventDefault();
						var tab = e.currentTarget;
						var link = tab.querySelector("a");
						for (var c = 0, tLen = tabs.length; c < tLen; c++) {
							if (!tabs[c].classList.contains("az__tab--active")) continue;
							tabs[c].classList.remove("az__tab--active");
							break
						}
						tab.classList.add("az__tab--active");
						for (var c = 0, pLen = panels.length; c < pLen; c++) {
							if (panels[c].classList.contains("az__panel--active")) {
								panels[c].classList.remove("az__panel--active")
							} else if (panels[c].id == link.getAttribute("href").substr(1)) {
								panels[c].classList.add("az__panel--active")
							}
						}
					}
				};
				for (var i = 0, len = az.length; i < len; i++) {
					var c, tLen;
					_loop()
				}
			})
		}
	}, {}],
	16: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var filter = document.getElementById("search-results-filter");
				if (filter) {
					var toggle = filter.querySelector("[data-toggle]");
					toggle.addEventListener("click", function () {
						filter.classList.toggle("is-open")
					})
				}
				document.querySelectorAll(".searchFilter__priorityOption").forEach(function (item) {
					item.addEventListener("click", function () {
						item.classList.toggle("active");
						item.children[1].toggleAttribute("disabled");
						document.getElementById("SearchResultProFilter").submit()
					})
				});
				var includeOtherFilters = document.getElementById("IncludeOtherFilters");
				var searchClearFilter = document.querySelector(".searchFilter__clearAllFilters");
				if (includeOtherFilters !== null) {
					includeOtherFilters.addEventListener("change", function () {
						var colls = document.getElementsByClassName("patient-type-collections");
						for (var i = 0; i < colls.length; i++) {
							colls[i].toggleAttribute("disabled")
						}
						if (!$(".searchFilter__priorityOption--pro").hasClass("active") && !$(".searchFilter__priorityOption--medicine").hasClass("active") && !includeOtherFilters.checked) {
							document.getElementById("ProfessionalFilter").toggleAttribute("disabled");
							document.getElementById("MedicineFilter").toggleAttribute("disabled")
						}
						document.getElementById("SearchResultProFilter").submit()
					})
				}
				if (searchClearFilter !== null) {
					searchClearFilter.addEventListener("click", function () {
						this.classList.toggle("active");
						document.querySelectorAll(".searchFilter__priorityOption").forEach(function (item) {
							if (!item.classList.contains("active")) {
								item.classList.toggle("active");
								item.children[1].toggleAttribute("disabled")
							}
						});
						if (includeOtherFilters.checked) {
							includeOtherFilters.checked = false;
							var colls = document.getElementsByClassName("patient-type-collections");
							for (var i = 0; i < colls.length; i++) {
								colls[i].toggleAttribute("disabled")
							}
						}
						document.getElementById("SearchResultProFilter").submit()
					})
				}
			})
		}
	}, {}],
	17: [function (require, module, exports) {
		"use strict";
		require("intersection-observer");
		require("whatwg-fetch");
		require("awesomplete");
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var searchElements = document.querySelectorAll('[data-component="search"] [data-search-input]');
				var _loop = function _loop() {
					var input = searchElements[i];
					var search = new Awesomplete(input, {
						minChars: 1,
						autoFirst: true,
						sort: false,
						maxItems: 20
					});
					input.addEventListener("awesomplete-selectcomplete", function (ev) {
						var moreDetailsUrl = (!ev.target.classList.contains("site-search-input") && (location.href.indexOf("/patientplus") !== -1 || location.href.indexOf("/doctor/search.asp") !== -1) ? "/doctor/search.asp?searchterm=" : "/search.asp?searchterm=") + ev.text.value.escape();
						$(ev.target).closest("form").find('input[type="hidden"][name="collections"]').each(function () {
							var thisValue = $(this).val();
							if (thisValue !== "") {
								moreDetailsUrl = moreDetailsUrl + "&collections=" + thisValue
							}
						});
						window.location.href = moreDetailsUrl
					});
					input.addEventListener("keyup", function (e) {
						var code = e.keyCode || e.which;
						if (code === 37 || code === 38 || code === 39 || code === 40 || code === 27 || code === 13) {
							return
						} else {
							if (input.value.length === 0) {
								search.list = []
							} else {
								var murl = window.patientconfig.searchServiceBaseUrl + "/autocomplete?take=20&query=" + input.value;
								fetch(murl, {
									mode: "cors"
								}).then(function (r) {
									return r.json()
								}).then(function (d) {
									search.list = d.map(function (row) {
										return row.name
									})
								})
							}
						}
					});
					if (input.hasAttribute("disabled")) {
						input.removeAttribute("disabled")
					}
				};
				for (var i = 0, len = searchElements.length; i < len; i++) {
					_loop()
				}
			})
		}
	}, {
		awesomplete: 31,
		"intersection-observer": 39,
		"whatwg-fetch": 46
	}],
	18: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				patient.events.on("modal.opened", function (event, modal) {
					var editor = $(modal).find("#note-editor-modal");
					if (editor.length) {
						patient.events.trigger("noteseditor.opened")
					}
				})
			})
		}
	}, {}],
	19: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var helpboxes = document.querySelectorAll('[data-component="helpbox"]');
				var _loop = function _loop() {
					var helpbox = helpboxes[i];
					var toggle = helpbox.querySelector("[data-help-toggle]");
					var content = helpbox.querySelector("[data-help-content]");
					toggle.addEventListener("click", function (e) {
						e.preventDefault();
						if (content.style.display === "none") {
							content.style.display = "block"
						} else {
							content.style.display = "none"
						}
						e.stopPropagation()
					});
					document.addEventListener("click", function (e) {
						content.style.display = "none"
					})
				};
				for (var i = 0, len = helpboxes.length; i < len; i++) {
					_loop()
				}
			})
		}
	}, {}],
	20: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var accordions = document.querySelectorAll('[data-component="accordion"]');
				var _loop = function _loop() {
					var accordion = accordions[i];
					var toggle = accordion.querySelector("[data-accordion-toggle]");
					toggle.addEventListener("click", function () {
						accordion.classList.toggle("is-open")
					})
				};
				for (var i = 0, len = accordions.length; i < len; i++) {
					_loop()
				}
			})
		}
	}, {}],
	21: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var showAlls = document.getElementsByClassName("recipeIngredients__showAll");
				var _loop = function _loop() {
					var showAll = showAlls[i];
					var wrapper = showAll.parentElement.getElementsByClassName("recipeIngredients__wrapper")[0];
					showAll.addEventListener("click", function (e) {
						e.preventDefault();
						wrapper.classList.add("is-open");
						showAll.style.display = "none"
					})
				};
				for (var i = 0, len = showAlls.length; i < len; i++) {
					_loop()
				}
				var allUnits = document.getElementsByClassName("recipeIngredients__unit");
				var ingredientListNative = document.getElementsByClassName("recipeIngredients__list");
				for (var i = 0, len = allUnits.length; i < len; i++) {
					allUnits[i].addEventListener("click", toggleImperial)
				}

				function toggleImperial(e) {
					e.preventDefault();
					var unit = e.currentTarget;
					var selected;
					for (var i = 0, len = allUnits.length; i < len; i++) {
						if (!allUnits[i].classList.contains("selected")) continue;
						selected = allUnits[i];
						break
					}
					selected.classList.remove("selected");
					unit.classList.add("selected");
					var unitData = unit.getAttribute("data-unit");
					for (var i = 0, len = ingredientListNative.length; i < len; i++) {
						var ingredient = ingredientListNative[i];
						if (unitData === "imperial") {
							ingredient.classList.add("show-imperial")
						} else {
							ingredient.classList.remove("show-imperial")
						}
					}
				}
			})
		}
	}, {}],
	22: [function (require, module, exports) {
		"use strict";
		var Popper = require("popper.js");
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var actionMenu = document.getElementById("action-menu");
				if (actionMenu) {
					var closeDropdowns;
					var isHidden;
					var i, len;
					var ua;
					(function () {
						var triggers = actionMenu.querySelectorAll("[data-menu]");
						var dropdowns = [];
						closeDropdowns = function closeDropdowns() {
							dropdowns.forEach(function (el) {
								return el.style.display = "none"
							});
							triggers.forEach(function (el) {
								return el.classList.remove("is-active")
							})
						};
						isHidden = function isHidden(el) {
							return el.offsetParent === null
						};
						actionMenu.addEventListener("click", function (event) {
							return event.stopPropagation()
						});
						document.body.addEventListener("click", function () {
							return closeDropdowns()
						});
						var notesTrigger = actionMenu.querySelector('[data-notes="show"]');
						if (notesTrigger) notesTrigger.addEventListener("click", function () {
							return closeDropdowns()
						});
						var _loop = function _loop() {
							var trigger = triggers[i];
							var dropdown = actionMenu.querySelector(trigger.getAttribute("data-menu"));
							if (dropdown) {
								dropdowns.push(dropdown);
								var popover = new Popper(trigger, dropdown, {
									placement: "bottom"
								});
								window.addEventListener("resize", function () {
									return popover.update()
								});
								trigger.addEventListener("click", function () {
									if (!isHidden(dropdown)) {
										dropdown.style.display = "none";
										trigger.classList.remove("is-active")
									} else {
										for (var c = 0, dLen = dropdowns.length; c < dLen; c++) {
											if (dropdowns[c] === dropdown) continue;
											dropdowns[c].style.display = "none"
										}
										var active;
										for (var b = 0; b < len; b++) {
											if (!triggers[b].classList.contains("is-active")) continue;
											active = triggers[b];
											break
										}
										if (active) active.classList.remove("is-active");
										trigger.classList.add("is-active");
										dropdown.style.display = "block";
										popover.update()
									}
									return false
								})
							}
						};
						for (i = 0, len = triggers.length; i < len; i++) {
							_loop()
						}
						ua = navigator.userAgent.toLowerCase();
						if (ua.indexOf("android") > -1) {
							var downloadTrigger = actionMenu.querySelector(".actionMenu__action--download > a");
							if (downloadTrigger) {
								downloadTrigger.href = "javascript:void(0)";
								downloadTrigger.addEventListener("click", function () {
									var newWin = window.open(this.getAttribute("data-pdfPath"), "_blank", "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes, copyhistory=no, fullscreen=yes");
									newWin.focus()
								})
							}
						}
					})()
				}
			})
		}
	}, {
		"popper.js": 42
	}],
	23: [function (require, module, exports) {
		"use strict";
		var _siema = _interopRequireDefault(require("siema"));

		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : {
				default: obj
			}
		}

		function _createForOfIteratorHelper(o, allowArrayLike) {
			var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
			if (!it) {
				if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
					if (it) o = it;
					var i = 0;
					var F = function F() {};
					return {
						s: F,
						n: function n() {
							if (i >= o.length) return {
								done: true
							};
							return {
								done: false,
								value: o[i++]
							}
						},
						e: function e(_e) {
							throw _e
						},
						f: F
					}
				}
				throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
			}
			var normalCompletion = true,
				didErr = false,
				err;
			return {
				s: function s() {
					it = it.call(o)
				},
				n: function n() {
					var step = it.next();
					normalCompletion = step.done;
					return step
				},
				e: function e(_e2) {
					didErr = true;
					err = _e2
				},
				f: function f() {
					try {
						if (!normalCompletion && it["return"] != null) it["return"]()
					} finally {
						if (didErr) throw err
					}
				}
			}
		}

		function _unsupportedIterableToArray(o, minLen) {
			if (!o) return;
			if (typeof o === "string") return _arrayLikeToArray(o, minLen);
			var n = Object.prototype.toString.call(o).slice(8, -1);
			if (n === "Object" && o.constructor) n = o.constructor.name;
			if (n === "Map" || n === "Set") return Array.from(o);
			if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen)
		}

		function _arrayLikeToArray(arr, len) {
			if (len == null || len > arr.length) len = arr.length;
			for (var i = 0, arr2 = new Array(len); i < len; i++) {
				arr2[i] = arr[i]
			}
			return arr2
		}
		module.exports = function (patientcore) {
			patientcore.prelayout.ready(function () {
				var isMobile = window.matchMedia("only screen and (max-width: 760px)").matches;
				if (!isMobile) {
					var carousels = document.querySelectorAll(".card-carousel");
					var _iterator = _createForOfIteratorHelper(carousels),
						_step;
					try {
						for (_iterator.s(); !(_step = _iterator.n()).done;) {
							var wrapper = _step.value;
							var carousel = wrapper.querySelector(".data-carousel-items");
							var next = wrapper.querySelector("[data-next]");
							var prev = wrapper.querySelector("[data-prev]");
							var siema = new _siema["default"]({
								selector: carousel,
								easing: "ease-out",
								perPage: 4,
								startIndex: 0,
								draggable: false,
								multipleDrag: false,
								threshold: 20,
								loop: false,
								rtl: false,
								onInit: function onInit() {
									_onInit()
								},
								onChange: function onChange() {
									_onChange(siema)
								}
							});
							prev.addEventListener("click", function (e) {
								e.preventDefault();
								siema.prev();
								return false
							});
							next.addEventListener("click", function (e) {
								e.preventDefault();
								siema.next();
								return false
							})
						}
					} catch (err) {
						_iterator.e(err)
					} finally {
						_iterator.f()
					}
				} else {
					$(".card-carousel").removeClass("card-carousel");
					$(".card-carousel__nav--prev, .card-carousel__nav--next").addClass("inactive")
				}
			});

			function _onInit() {
				$(".card-carousel__nav--prev").addClass("inactive");
				$(".card-carousel__nav--next").removeClass("inactive")
			}

			function _onChange(siema) {
				if (siema.currentSlide > 0) {
					$(".card-carousel__nav--prev").removeClass("inactive")
				} else {
					$(".card-carousel__nav--prev").addClass("inactive")
				}
				if (siema.currentSlide < 2) {
					$(".card-carousel__nav--next").removeClass("inactive")
				} else {
					$(".card-carousel__nav--next").addClass("inactive")
				}
			}
		}
	}, {
		siema: 45
	}],
	24: [function (require, module, exports) {
		"use strict";
		var _siema = _interopRequireDefault(require("siema"));

		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : {
				default: obj
			}
		}
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var carousels = document.querySelectorAll('[data-component="card-carousel"]');
				for (var i = 0, len = carousels.length; i < len; i++) {
					var wrapper = carousels[i];
					var carousel = wrapper.querySelector("[data-carousel-items]");
					var next = wrapper.querySelector("[data-next]");
					var prev = wrapper.querySelector("[data-prev]");
					var siema = new _siema["default"]({
						selector: carousel,
						easing: "ease-out",
						perPage: {
							640: 2,
							960: 3
						},
						startIndex: 0,
						draggable: true,
						multipleDrag: true,
						threshold: 20,
						loop: false,
						rtl: false
					});
					prev.addEventListener("click", function (e) {
						e.preventDefault();
						siema.prev();
						return false
					});
					next.addEventListener("click", function (e) {
						e.preventDefault();
						siema.next();
						return false
					})
				}
			})
		}
	}, {
		siema: 45
	}],
	25: [function (require, module, exports) {
		"use strict";
		var _siema = _interopRequireDefault(require("siema"));

		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : {
				default: obj
			}
		}
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var cards = document.querySelectorAll('[data-component="featured-cards"]');
				var _loop = function _loop() {
					var wrapper = cards[i];
					var slider = wrapper.querySelector("[data-slider-items]");
					if (slider) {
						var siema;
						var width = window.patient.getLayout("medium").width;
						if (window.innerWidth < width) {
							siema = new _siema["default"]({
								selector: slider,
								easing: "ease-out",
								perPage: 2,
								startIndex: 0,
								draggable: true,
								multipleDrag: true,
								threshold: 20,
								loop: false,
								rtl: false
							})
						}
						window.addEventListener("resize", function (e) {
							if (!siema && window.innerWidth < width) {
								siema = new _siema["default"]({
									selector: slider,
									easing: "ease-out",
									perPage: 2,
									startIndex: 0,
									draggable: true,
									multipleDrag: true,
									threshold: 20,
									loop: false,
									rtl: false
								})
							}
							if (siema && window.innerWidth >= width) {
								siema.destroy(true);
								siema = null
							}
						})
					}
				};
				for (var i = 0, len = cards.length; i < len; i++) {
					_loop()
				}
			})
		}
	}, {
		siema: 45
	}],
	26: [function (require, module, exports) {
		(function (global) {
			(function () {
				"use strict";
				require("intersection-observer");
				module.exports = function (patientcore, patient) {
					var options = {
						root: null,
						rootMargin: "-50px 5px 50px",
						threshold: .1
					};
					var loadImagesImmediately = function loadImagesImmediately(image) {
						var src = image.dataset.src;
						if (src !== undefined) {
							image.setAttribute("src", src);
							image.onload = function () {
								image.removeAttribute("data-src")
							}
						}
					};
					var handleIntersection = function handleIntersection(entries, observer) {
						for (var i = 0, len = entries.length; i < len; i++) {
							var entry = entries[i];
							if (entry.intersectionRatio > 0) {
								observer.unobserve(entry.target);
								loadImagesImmediately(entry.target)
							}
						}
					};
					global.observer = new IntersectionObserver(handleIntersection, options);
					var images = document.getElementsByClassName("imageLazy");
					if (images.length) {
						for (var i = 0, len = images.length; i < len; i++) {
							observer.observe(images[i])
						}
					}
				}
			}).call(this)
		}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	}, {
		"intersection-observer": 39
	}],
	27: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				var series = patient.$document[0].querySelectorAll('[data-component="series-nav"]');
				if (series.length) {
					var s = $(series);
					var toggle = s.find('[data-role="series-toggle"]');
					toggle.on("click", function () {
						s.toggleClass("is-open");
						return false
					});
					$(".subnav-nav-modal").appendTo("#article-nav-modal .modal__content")
				}
			})
		}
	}, {}],
	28: [function (require, module, exports) {
		"use strict";
		module.exports = function (patientcore, patient) {
			patientcore.prelayout.ready(function () {
				patient.events.on("modal.opened", function (event, modal) {
					var jumpNav = modal[0].querySelector('[data-behaviour="jump"]');
					if (jumpNav) {
						var links = jumpNav.querySelectorAll("[data-subnavmodal-link]");
						var current = jumpNav.querySelector('[href*="'.concat(patient.state.waypoint, '"]'));
						if (!current) {
							current = links[0]
						}
						var active = jumpNav.querySelector(".subNavModal__item--active");
						if (active) active.classList.remove("subNavModal__item--active");
						current.parentNode.classList.add("subNavModal__item--active");
						for (var i = 0, len = links.length; i < len; i++) {
							links[i].addEventListener("click", function () {
								patient.events.trigger("modal.close")
							})
						}
					}
				})
			})
		}
	}, {}],
	29: [function (require, module, exports) {
		(function (global) {
			(function () {
				"use strict";
				var scrollama = global.scrollama = require("scrollama");
				module.exports = function (patientcore, patient) {
					patientcore.prelayout.ready(function () {
						var subnavQuery = document.getElementById("subnav");
						if (subnavQuery && subnavQuery.getAttribute("data-behaviour") === "jump") {
							var label = subnavQuery.querySelector("[data-subnav-label]");
							var links = subnavQuery.querySelectorAll("[data-subnav-link]");
							var scroller = scrollama();
							scroller.setup({
								step: "h2",
								offset: 0
							}).onStepEnter(function (callback) {
								var direction = callback.direction;
								var element = callback.element;
								var active = subnavQuery.getElementsByClassName("subnav__item--active");
								while (active.length > 0) {
									active[0].classList.remove("subnav__item--active")
								}
								var link;
								for (var i = 0, len = links.length; i < len; i++) {
									if (links[i].getAttribute("href").substr(1) !== element.id) continue;
									link = links[i];
									break
								}
								var prev = link.parentNode.previousElementSibling;
								if (direction === "up" && prev) {
									var current = prev.querySelector("[data-subnav-link]");
									prev.classList.add("subnav__item--active");
									label.innerText = current.childNodes[0].nodeValue;
									patient.state.waypoint = current.getAttribute("href")
								} else {
									link.parentNode.classList.add("subnav__item--active");
									label.innerText = element.childNodes[0].nodeValue;
									patient.state.waypoint = link.getAttribute("href")
								}
							})
						}
					})
				}
			}).call(this)
		}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	}, {
		scrollama: 44
	}],
	30: [function (require, module, exports) {
		(function () {
			"use strict";
			var needsTemplate = typeof HTMLTemplateElement === "undefined";
			var brokenDocFragment = !(document.createDocumentFragment().cloneNode() instanceof DocumentFragment);
			var needsDocFrag = false;
			if (/Trident/.test(navigator.userAgent)) {
				(function () {
					needsDocFrag = true;
					var origCloneNode = Node.prototype.cloneNode;
					Node.prototype.cloneNode = function cloneNode(deep) {
						var newDom = origCloneNode.call(this, deep);
						if (this instanceof DocumentFragment) {
							newDom.__proto__ = DocumentFragment.prototype
						}
						return newDom
					};
					DocumentFragment.prototype.querySelectorAll = HTMLElement.prototype.querySelectorAll;
					DocumentFragment.prototype.querySelector = HTMLElement.prototype.querySelector;
					Object.defineProperties(DocumentFragment.prototype, {
						nodeType: {
							get: function () {
								return Node.DOCUMENT_FRAGMENT_NODE
							},
							configurable: true
						},
						localName: {
							get: function () {
								return undefined
							},
							configurable: true
						},
						nodeName: {
							get: function () {
								return "#document-fragment"
							},
							configurable: true
						}
					});
					var origInsertBefore = Node.prototype.insertBefore;

					function insertBefore(newNode, refNode) {
						if (newNode instanceof DocumentFragment) {
							var child;
							while (child = newNode.firstChild) {
								origInsertBefore.call(this, child, refNode)
							}
						} else {
							origInsertBefore.call(this, newNode, refNode)
						}
						return newNode
					}
					Node.prototype.insertBefore = insertBefore;
					var origAppendChild = Node.prototype.appendChild;
					Node.prototype.appendChild = function appendChild(child) {
						if (child instanceof DocumentFragment) {
							insertBefore.call(this, child, null)
						} else {
							origAppendChild.call(this, child)
						}
						return child
					};
					var origRemoveChild = Node.prototype.removeChild;
					var origReplaceChild = Node.prototype.replaceChild;
					Node.prototype.replaceChild = function replaceChild(newChild, oldChild) {
						if (newChild instanceof DocumentFragment) {
							insertBefore.call(this, newChild, oldChild);
							origRemoveChild.call(this, oldChild)
						} else {
							origReplaceChild.call(this, newChild, oldChild)
						}
						return oldChild
					};
					Document.prototype.createDocumentFragment = function createDocumentFragment() {
						var frag = this.createElement("df");
						frag.__proto__ = DocumentFragment.prototype;
						return frag
					};
					var origImportNode = Document.prototype.importNode;
					Document.prototype.importNode = function importNode(impNode, deep) {
						deep = deep || false;
						var newNode = origImportNode.call(this, impNode, deep);
						if (impNode instanceof DocumentFragment) {
							newNode.__proto__ = DocumentFragment.prototype
						}
						return newNode
					}
				})()
			}
			var capturedCloneNode = Node.prototype.cloneNode;
			var capturedCreateElement = Document.prototype.createElement;
			var capturedImportNode = Document.prototype.importNode;
			var capturedRemoveChild = Node.prototype.removeChild;
			var capturedAppendChild = Node.prototype.appendChild;
			var capturedReplaceChild = Node.prototype.replaceChild;
			var capturedParseFromString = DOMParser.prototype.parseFromString;
			var capturedHTMLElementInnerHTML = Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, "innerHTML") || {
				get: function () {
					return this.innerHTML
				},
				set: function (text) {
					this.innerHTML = text
				}
			};
			var capturedChildNodes = Object.getOwnPropertyDescriptor(window.Node.prototype, "childNodes") || {
				get: function () {
					return this.childNodes
				}
			};
			var elementQuerySelectorAll = Element.prototype.querySelectorAll;
			var docQuerySelectorAll = Document.prototype.querySelectorAll;
			var fragQuerySelectorAll = DocumentFragment.prototype.querySelectorAll;
			var scriptSelector = 'script:not([type]),script[type="application/javascript"],script[type="text/javascript"]';

			function QSA(node, selector) {
				if (!node.childNodes.length) {
					return []
				}
				switch (node.nodeType) {
					case Node.DOCUMENT_NODE:
						return docQuerySelectorAll.call(node, selector);
					case Node.DOCUMENT_FRAGMENT_NODE:
						return fragQuerySelectorAll.call(node, selector);
					default:
						return elementQuerySelectorAll.call(node, selector)
				}
			}
			var needsCloning = function () {
				if (!needsTemplate) {
					var t = document.createElement("template");
					var t2 = document.createElement("template");
					t2.content.appendChild(document.createElement("div"));
					t.content.appendChild(t2);
					var clone = t.cloneNode(true);
					return clone.content.childNodes.length === 0 || clone.content.firstChild.content.childNodes.length === 0 || brokenDocFragment
				}
			}();
			var TEMPLATE_TAG = "template";
			var PolyfilledHTMLTemplateElement = function () {};
			if (needsTemplate) {
				var contentDoc = document.implementation.createHTMLDocument("template");
				var canDecorate = true;
				var templateStyle = document.createElement("style");
				templateStyle.textContent = TEMPLATE_TAG + "{display:none;}";
				var head = document.head;
				head.insertBefore(templateStyle, head.firstElementChild);
				PolyfilledHTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);
				var canProtoPatch = !document.createElement("div").hasOwnProperty("innerHTML");
				PolyfilledHTMLTemplateElement.decorate = function (template) {
					if (template.content || template.namespaceURI !== document.documentElement.namespaceURI) {
						return
					}
					template.content = contentDoc.createDocumentFragment();
					var child;
					while (child = template.firstChild) {
						capturedAppendChild.call(template.content, child)
					}
					if (canProtoPatch) {
						template.__proto__ = PolyfilledHTMLTemplateElement.prototype
					} else {
						template.cloneNode = function (deep) {
							return PolyfilledHTMLTemplateElement._cloneNode(this, deep)
						};
						if (canDecorate) {
							try {
								defineInnerHTML(template);
								defineOuterHTML(template)
							} catch (err) {
								canDecorate = false
							}
						}
					}
					PolyfilledHTMLTemplateElement.bootstrap(template.content)
				};
				var topLevelWrappingMap = {
					option: ["select"],
					thead: ["table"],
					col: ["colgroup", "table"],
					tr: ["tbody", "table"],
					th: ["tr", "tbody", "table"],
					td: ["tr", "tbody", "table"]
				};
				var getTagName = function (text) {
					return (/<([a-z][^/\0>\x20\t\r\n\f]+)/i.exec(text) || ["", ""])[1].toLowerCase()
				};
				var defineInnerHTML = function defineInnerHTML(obj) {
					Object.defineProperty(obj, "innerHTML", {
						get: function () {
							return getInnerHTML(this)
						},
						set: function (text) {
							var wrap = topLevelWrappingMap[getTagName(text)];
							if (wrap) {
								for (var i = 0; i < wrap.length; i++) {
									text = "<" + wrap[i] + ">" + text + "</" + wrap[i] + ">"
								}
							}
							contentDoc.body.innerHTML = text;
							PolyfilledHTMLTemplateElement.bootstrap(contentDoc);
							while (this.content.firstChild) {
								capturedRemoveChild.call(this.content, this.content.firstChild)
							}
							var body = contentDoc.body;
							if (wrap) {
								for (var j = 0; j < wrap.length; j++) {
									body = body.lastChild
								}
							}
							while (body.firstChild) {
								capturedAppendChild.call(this.content, body.firstChild)
							}
						},
						configurable: true
					})
				};
				var defineOuterHTML = function defineOuterHTML(obj) {
					Object.defineProperty(obj, "outerHTML", {
						get: function () {
							return "<" + TEMPLATE_TAG + ">" + this.innerHTML + "</" + TEMPLATE_TAG + ">"
						},
						set: function (innerHTML) {
							if (this.parentNode) {
								contentDoc.body.innerHTML = innerHTML;
								var docFrag = this.ownerDocument.createDocumentFragment();
								while (contentDoc.body.firstChild) {
									capturedAppendChild.call(docFrag, contentDoc.body.firstChild)
								}
								capturedReplaceChild.call(this.parentNode, docFrag, this)
							} else {
								throw new Error("Failed to set the 'outerHTML' property on 'Element': This element has no parent node.")
							}
						},
						configurable: true
					})
				};
				defineInnerHTML(PolyfilledHTMLTemplateElement.prototype);
				defineOuterHTML(PolyfilledHTMLTemplateElement.prototype);
				PolyfilledHTMLTemplateElement.bootstrap = function bootstrap(doc) {
					var templates = QSA(doc, TEMPLATE_TAG);
					for (var i = 0, l = templates.length, t; i < l && (t = templates[i]); i++) {
						PolyfilledHTMLTemplateElement.decorate(t)
					}
				};
				document.addEventListener("DOMContentLoaded", function () {
					PolyfilledHTMLTemplateElement.bootstrap(document)
				});
				Document.prototype.createElement = function createElement() {
					var el = capturedCreateElement.apply(this, arguments);
					if (el.localName === "template") {
						PolyfilledHTMLTemplateElement.decorate(el)
					}
					return el
				};
				DOMParser.prototype.parseFromString = function () {
					var el = capturedParseFromString.apply(this, arguments);
					PolyfilledHTMLTemplateElement.bootstrap(el);
					return el
				};
				Object.defineProperty(HTMLElement.prototype, "innerHTML", {
					get: function () {
						return getInnerHTML(this)
					},
					set: function (text) {
						capturedHTMLElementInnerHTML.set.call(this, text);
						PolyfilledHTMLTemplateElement.bootstrap(this)
					},
					configurable: true,
					enumerable: true
				});
				var escapeAttrRegExp = /[&\u00A0"]/g;
				var escapeDataRegExp = /[&\u00A0<>]/g;
				var escapeReplace = function (c) {
					switch (c) {
						case "&":
							return "&amp;";
						case "<":
							return "&lt;";
						case ">":
							return "&gt;";
						case '"':
							return "&quot;";
						case " ":
							return "&nbsp;"
					}
				};
				var escapeAttr = function (s) {
					return s.replace(escapeAttrRegExp, escapeReplace)
				};
				var escapeData = function (s) {
					return s.replace(escapeDataRegExp, escapeReplace)
				};
				var makeSet = function (arr) {
					var set = {};
					for (var i = 0; i < arr.length; i++) {
						set[arr[i]] = true
					}
					return set
				};
				var voidElements = makeSet(["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
				var plaintextParents = makeSet(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);
				var getOuterHTML = function (node, parentNode, callback) {
					switch (node.nodeType) {
						case Node.ELEMENT_NODE: {
							var tagName = node.localName;
							var s = "<" + tagName;
							var attrs = node.attributes;
							for (var i = 0, attr; attr = attrs[i]; i++) {
								s += " " + attr.name + '="' + escapeAttr(attr.value) + '"'
							}
							s += ">";
							if (voidElements[tagName]) {
								return s
							}
							return s + getInnerHTML(node, callback) + "</" + tagName + ">"
						}
						case Node.TEXT_NODE: {
							var data = node.data;
							if (parentNode && plaintextParents[parentNode.localName]) {
								return data
							}
							return escapeData(data)
						}
						case Node.COMMENT_NODE: {
							return "\x3c!--" + node.data + "--\x3e"
						}
						default: {
							window.console.error(node);
							throw new Error("not implemented")
						}
					}
				};
				var getInnerHTML = function (node, callback) {
					if (node.localName === "template") {
						node = node.content
					}
					var s = "";
					var c$ = callback ? callback(node) : capturedChildNodes.get.call(node);
					for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
						s += getOuterHTML(child, node, callback)
					}
					return s
				}
			}
			if (needsTemplate || needsCloning) {
				PolyfilledHTMLTemplateElement._cloneNode = function _cloneNode(template, deep) {
					var clone = capturedCloneNode.call(template, false);
					if (this.decorate) {
						this.decorate(clone)
					}
					if (deep) {
						capturedAppendChild.call(clone.content, capturedCloneNode.call(template.content, true));
						fixClonedDom(clone.content, template.content)
					}
					return clone
				};
				var fixClonedDom = function fixClonedDom(clone, source) {
					if (!source.querySelectorAll) return;
					var s$ = QSA(source, TEMPLATE_TAG);
					if (s$.length === 0) {
						return
					}
					var t$ = QSA(clone, TEMPLATE_TAG);
					for (var i = 0, l = t$.length, t, s; i < l; i++) {
						s = s$[i];
						t = t$[i];
						if (PolyfilledHTMLTemplateElement && PolyfilledHTMLTemplateElement.decorate) {
							PolyfilledHTMLTemplateElement.decorate(s)
						}
						capturedReplaceChild.call(t.parentNode, cloneNode.call(s, true), t)
					}
				};
				var fixClonedScripts = function fixClonedScripts(fragment) {
					var scripts = QSA(fragment, scriptSelector);
					for (var ns, s, i = 0; i < scripts.length; i++) {
						s = scripts[i];
						ns = capturedCreateElement.call(document, "script");
						ns.textContent = s.textContent;
						var attrs = s.attributes;
						for (var ai = 0, a; ai < attrs.length; ai++) {
							a = attrs[ai];
							ns.setAttribute(a.name, a.value)
						}
						capturedReplaceChild.call(s.parentNode, ns, s)
					}
				};
				var cloneNode = Node.prototype.cloneNode = function cloneNode(deep) {
					var dom;
					if (!needsDocFrag && brokenDocFragment && this instanceof DocumentFragment) {
						if (!deep) {
							return this.ownerDocument.createDocumentFragment()
						} else {
							dom = importNode.call(this.ownerDocument, this, true)
						}
					} else if (this.nodeType === Node.ELEMENT_NODE && this.localName === TEMPLATE_TAG && this.namespaceURI == document.documentElement.namespaceURI) {
						dom = PolyfilledHTMLTemplateElement._cloneNode(this, deep)
					} else {
						dom = capturedCloneNode.call(this, deep)
					}
					if (deep) {
						fixClonedDom(dom, this)
					}
					return dom
				};
				var importNode = Document.prototype.importNode = function importNode(element, deep) {
					deep = deep || false;
					if (element.localName === TEMPLATE_TAG) {
						return PolyfilledHTMLTemplateElement._cloneNode(element, deep)
					} else {
						var dom = capturedImportNode.call(this, element, deep);
						if (deep) {
							fixClonedDom(dom, element);
							fixClonedScripts(dom)
						}
						return dom
					}
				}
			}
			if (needsTemplate) {
				window.HTMLTemplateElement = PolyfilledHTMLTemplateElement
			}
		})()
	}, {}],
	31: [function (require, module, exports) {
		(function () {
			var _ = function (input, o) {
				var me = this;
				_.count = (_.count || 0) + 1;
				this.count = _.count;
				this.isOpened = false;
				this.input = $(input);
				this.input.setAttribute("autocomplete", "off");
				this.input.setAttribute("aria-expanded", "false");
				this.input.setAttribute("aria-owns", "awesomplete_list_" + this.count);
				this.input.setAttribute("role", "combobox");
				this.options = o = o || {};
				configure(this, {
					minChars: 2,
					maxItems: 10,
					autoFirst: false,
					data: _.DATA,
					filter: _.FILTER_CONTAINS,
					sort: o.sort === false ? false : _.SORT_BYLENGTH,
					container: _.CONTAINER,
					item: _.ITEM,
					replace: _.REPLACE,
					tabSelect: false
				}, o);
				this.index = -1;
				this.container = this.container(input);
				this.ul = $.create("ul", {
					hidden: "hidden",
					role: "listbox",
					id: "awesomplete_list_" + this.count,
					inside: this.container
				});
				this.status = $.create("span", {
					className: "visually-hidden",
					role: "status",
					"aria-live": "assertive",
					"aria-atomic": true,
					inside: this.container,
					textContent: this.minChars != 0 ? "Type " + this.minChars + " or more characters for results." : "Begin typing for results."
				});
				this._events = {
					input: {
						input: this.evaluate.bind(this),
						blur: this.close.bind(this, {
							reason: "blur"
						}),
						keydown: function (evt) {
							var c = evt.keyCode;
							if (me.opened) {
								if (c === 13 && me.selected) {
									evt.preventDefault();
									me.select(undefined, undefined, evt)
								} else if (c === 9 && me.selected && me.tabSelect) {
									me.select(undefined, undefined, evt)
								} else if (c === 27) {
									me.close({
										reason: "esc"
									})
								} else if (c === 38 || c === 40) {
									evt.preventDefault();
									me[c === 38 ? "previous" : "next"]()
								}
							}
						}
					},
					form: {
						submit: this.close.bind(this, {
							reason: "submit"
						})
					},
					ul: {
						mousedown: function (evt) {
							evt.preventDefault()
						},
						click: function (evt) {
							var li = evt.target;
							if (li !== this) {
								while (li && !/li/i.test(li.nodeName)) {
									li = li.parentNode
								}
								if (li && evt.button === 0) {
									evt.preventDefault();
									me.select(li, evt.target, evt)
								}
							}
						}
					}
				};
				$.bind(this.input, this._events.input);
				$.bind(this.input.form, this._events.form);
				$.bind(this.ul, this._events.ul);
				if (this.input.hasAttribute("list")) {
					this.list = "#" + this.input.getAttribute("list");
					this.input.removeAttribute("list")
				} else {
					this.list = this.input.getAttribute("data-list") || o.list || []
				}
				_.all.push(this)
			};
			_.prototype = {
				set list(list) {
					if (Array.isArray(list)) {
						this._list = list
					} else if (typeof list === "string" && list.indexOf(",") > -1) {
						this._list = list.split(/\s*,\s*/)
					} else {
						list = $(list);
						if (list && list.children) {
							var items = [];
							slice.apply(list.children).forEach(function (el) {
								if (!el.disabled) {
									var text = el.textContent.trim();
									var value = el.value || text;
									var label = el.label || text;
									if (value !== "") {
										items.push({
											label: label,
											value: value
										})
									}
								}
							});
							this._list = items
						}
					}
					if (document.activeElement === this.input) {
						this.evaluate()
					}
				},
				get selected() {
					return this.index > -1
				},
				get opened() {
					return this.isOpened
				},
				close: function (o) {
					if (!this.opened) {
						return
					}
					this.input.setAttribute("aria-expanded", "false");
					this.ul.setAttribute("hidden", "");
					this.isOpened = false;
					this.index = -1;
					this.status.setAttribute("hidden", "");
					$.fire(this.input, "awesomplete-close", o || {})
				},
				open: function () {
					this.input.setAttribute("aria-expanded", "true");
					this.ul.removeAttribute("hidden");
					this.isOpened = true;
					this.status.removeAttribute("hidden");
					if (this.autoFirst && this.index === -1) {
						this.goto(0)
					}
					$.fire(this.input, "awesomplete-open")
				},
				destroy: function () {
					$.unbind(this.input, this._events.input);
					$.unbind(this.input.form, this._events.form);
					if (!this.options.container) {
						var parentNode = this.container.parentNode;
						parentNode.insertBefore(this.input, this.container);
						parentNode.removeChild(this.container)
					}
					this.input.removeAttribute("autocomplete");
					this.input.removeAttribute("aria-autocomplete");
					var indexOfAwesomplete = _.all.indexOf(this);
					if (indexOfAwesomplete !== -1) {
						_.all.splice(indexOfAwesomplete, 1)
					}
				},
				next: function () {
					var count = this.ul.children.length;
					this.goto(this.index < count - 1 ? this.index + 1 : count ? 0 : -1)
				},
				previous: function () {
					var count = this.ul.children.length;
					var pos = this.index - 1;
					this.goto(this.selected && pos !== -1 ? pos : count - 1)
				},
				goto: function (i) {
					var lis = this.ul.children;
					if (this.selected) {
						lis[this.index].setAttribute("aria-selected", "false")
					}
					this.index = i;
					if (i > -1 && lis.length > 0) {
						lis[i].setAttribute("aria-selected", "true");
						this.status.textContent = lis[i].textContent + ", list item " + (i + 1) + " of " + lis.length;
						this.input.setAttribute("aria-activedescendant", this.ul.id + "_item_" + this.index);
						this.ul.scrollTop = lis[i].offsetTop - this.ul.clientHeight + lis[i].clientHeight;
						$.fire(this.input, "awesomplete-highlight", {
							text: this.suggestions[this.index]
						})
					}
				},
				select: function (selected, origin, originalEvent) {
					if (selected) {
						this.index = $.siblingIndex(selected)
					} else {
						selected = this.ul.children[this.index]
					}
					if (selected) {
						var suggestion = this.suggestions[this.index];
						var allowed = $.fire(this.input, "awesomplete-select", {
							text: suggestion,
							origin: origin || selected,
							originalEvent: originalEvent
						});
						if (allowed) {
							this.replace(suggestion);
							this.close({
								reason: "select"
							});
							$.fire(this.input, "awesomplete-selectcomplete", {
								text: suggestion,
								originalEvent: originalEvent
							})
						}
					}
				},
				evaluate: function () {
					var me = this;
					var value = this.input.value;
					if (value.length >= this.minChars && this._list && this._list.length > 0) {
						this.index = -1;
						this.ul.innerHTML = "";
						this.suggestions = this._list.map(function (item) {
							return new Suggestion(me.data(item, value))
						}).filter(function (item) {
							return me.filter(item, value)
						});
						if (this.sort !== false) {
							this.suggestions = this.suggestions.sort(this.sort)
						}
						this.suggestions = this.suggestions.slice(0, this.maxItems);
						this.suggestions.forEach(function (text, index) {
							me.ul.appendChild(me.item(text, value, index))
						});
						if (this.ul.children.length === 0) {
							this.status.textContent = "No results found";
							this.close({
								reason: "nomatches"
							})
						} else {
							this.open();
							this.status.textContent = this.ul.children.length + " results found"
						}
					} else {
						this.close({
							reason: "nomatches"
						});
						this.status.textContent = "No results found"
					}
				}
			};
			_.all = [];
			_.FILTER_CONTAINS = function (text, input) {
				return RegExp($.regExpEscape(input.trim()), "i").test(text)
			};
			_.FILTER_STARTSWITH = function (text, input) {
				return RegExp("^" + $.regExpEscape(input.trim()), "i").test(text)
			};
			_.SORT_BYLENGTH = function (a, b) {
				if (a.length !== b.length) {
					return a.length - b.length
				}
				return a < b ? -1 : 1
			};
			_.CONTAINER = function (input) {
				return $.create("div", {
					className: "awesomplete",
					around: input
				})
			};
			_.ITEM = function (text, input, item_id) {
				var html = input.trim() === "" ? text : text.replace(RegExp($.regExpEscape(input.trim()), "gi"), "<mark>$&</mark>");
				return $.create("li", {
					innerHTML: html,
					role: "option",
					"aria-selected": "false",
					id: "awesomplete_list_" + this.count + "_item_" + item_id
				})
			};
			_.REPLACE = function (text) {
				this.input.value = text.value
			};
			_.DATA = function (item) {
				return item
			};

			function Suggestion(data) {
				var o = Array.isArray(data) ? {
					label: data[0],
					value: data[1]
				} : typeof data === "object" && "label" in data && "value" in data ? data : {
					label: data,
					value: data
				};
				this.label = o.label || o.value;
				this.value = o.value
			}
			Object.defineProperty(Suggestion.prototype = Object.create(String.prototype), "length", {
				get: function () {
					return this.label.length
				}
			});
			Suggestion.prototype.toString = Suggestion.prototype.valueOf = function () {
				return "" + this.label
			};

			function configure(instance, properties, o) {
				for (var i in properties) {
					var initial = properties[i],
						attrValue = instance.input.getAttribute("data-" + i.toLowerCase());
					if (typeof initial === "number") {
						instance[i] = parseInt(attrValue)
					} else if (initial === false) {
						instance[i] = attrValue !== null
					} else if (initial instanceof Function) {
						instance[i] = null
					} else {
						instance[i] = attrValue
					}
					if (!instance[i] && instance[i] !== 0) {
						instance[i] = i in o ? o[i] : initial
					}
				}
			}
			var slice = Array.prototype.slice;

			function $(expr, con) {
				return typeof expr === "string" ? (con || document).querySelector(expr) : expr || null
			}

			function $$(expr, con) {
				return slice.call((con || document).querySelectorAll(expr))
			}
			$.create = function (tag, o) {
				var element = document.createElement(tag);
				for (var i in o) {
					var val = o[i];
					if (i === "inside") {
						$(val).appendChild(element)
					} else if (i === "around") {
						var ref = $(val);
						ref.parentNode.insertBefore(element, ref);
						element.appendChild(ref);
						if (ref.getAttribute("autofocus") != null) {
							ref.focus()
						}
					} else if (i in element) {
						element[i] = val
					} else {
						element.setAttribute(i, val)
					}
				}
				return element
			};
			$.bind = function (element, o) {
				if (element) {
					for (var event in o) {
						var callback = o[event];
						event.split(/\s+/).forEach(function (event) {
							element.addEventListener(event, callback)
						})
					}
				}
			};
			$.unbind = function (element, o) {
				if (element) {
					for (var event in o) {
						var callback = o[event];
						event.split(/\s+/).forEach(function (event) {
							element.removeEventListener(event, callback)
						})
					}
				}
			};
			$.fire = function (target, type, properties) {
				var evt = document.createEvent("HTMLEvents");
				evt.initEvent(type, true, true);
				for (var j in properties) {
					evt[j] = properties[j]
				}
				return target.dispatchEvent(evt)
			};
			$.regExpEscape = function (s) {
				return s.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&")
			};
			$.siblingIndex = function (el) {
				for (var i = 0; el = el.previousElementSibling; i++);
				return i
			};

			function init() {
				$$("input.awesomplete").forEach(function (input) {
					new _(input)
				})
			}
			if (typeof self !== "undefined") {
				self.Awesomplete = _
			}
			if (typeof Document !== "undefined") {
				if (document.readyState !== "loading") {
					init()
				} else {
					document.addEventListener("DOMContentLoaded", init)
				}
			}
			_.$ = $;
			_.$$ = $$;
			if (typeof module === "object" && module.exports) {
				module.exports = _
			}
			return _
		})()
	}, {}],
	32: [function (require, module, exports) {}, {}],
	33: [function (require, module, exports) {
		var QueryHandler = require("./QueryHandler");
		var each = require("./Util").each;

		function MediaQuery(query, isUnconditional) {
			this.query = query;
			this.isUnconditional = isUnconditional;
			this.handlers = [];
			this.mql = window.matchMedia(query);
			var self = this;
			this.listener = function (mql) {
				self.mql = mql.currentTarget || mql;
				self.assess()
			};
			this.mql.addListener(this.listener)
		}
		MediaQuery.prototype = {
			constuctor: MediaQuery,
			addHandler: function (handler) {
				var qh = new QueryHandler(handler);
				this.handlers.push(qh);
				this.matches() && qh.on()
			},
			removeHandler: function (handler) {
				var handlers = this.handlers;
				each(handlers, function (h, i) {
					if (h.equals(handler)) {
						h.destroy();
						return !handlers.splice(i, 1)
					}
				})
			},
			matches: function () {
				return this.mql.matches || this.isUnconditional
			},
			clear: function () {
				each(this.handlers, function (handler) {
					handler.destroy()
				});
				this.mql.removeListener(this.listener);
				this.handlers.length = 0
			},
			assess: function () {
				var action = this.matches() ? "on" : "off";
				each(this.handlers, function (handler) {
					handler[action]()
				})
			}
		};
		module.exports = MediaQuery
	}, {
		"./QueryHandler": 35,
		"./Util": 36
	}],
	34: [function (require, module, exports) {
		var MediaQuery = require("./MediaQuery");
		var Util = require("./Util");
		var each = Util.each;
		var isFunction = Util.isFunction;
		var isArray = Util.isArray;

		function MediaQueryDispatch() {
			if (!window.matchMedia) {
				throw new Error("matchMedia not present, legacy browsers require a polyfill")
			}
			this.queries = {};
			this.browserIsIncapable = !window.matchMedia("only all").matches
		}
		MediaQueryDispatch.prototype = {
			constructor: MediaQueryDispatch,
			register: function (q, options, shouldDegrade) {
				var queries = this.queries,
					isUnconditional = shouldDegrade && this.browserIsIncapable;
				if (!queries[q]) {
					queries[q] = new MediaQuery(q, isUnconditional)
				}
				if (isFunction(options)) {
					options = {
						match: options
					}
				}
				if (!isArray(options)) {
					options = [options]
				}
				each(options, function (handler) {
					if (isFunction(handler)) {
						handler = {
							match: handler
						}
					}
					queries[q].addHandler(handler)
				});
				return this
			},
			unregister: function (q, handler) {
				var query = this.queries[q];
				if (query) {
					if (handler) {
						query.removeHandler(handler)
					} else {
						query.clear();
						delete this.queries[q]
					}
				}
				return this
			}
		};
		module.exports = MediaQueryDispatch
	}, {
		"./MediaQuery": 33,
		"./Util": 36
	}],
	35: [function (require, module, exports) {
		function QueryHandler(options) {
			this.options = options;
			!options.deferSetup && this.setup()
		}
		QueryHandler.prototype = {
			constructor: QueryHandler,
			setup: function () {
				if (this.options.setup) {
					this.options.setup()
				}
				this.initialised = true
			},
			on: function () {
				!this.initialised && this.setup();
				this.options.match && this.options.match()
			},
			off: function () {
				this.options.unmatch && this.options.unmatch()
			},
			destroy: function () {
				this.options.destroy ? this.options.destroy() : this.off()
			},
			equals: function (target) {
				return this.options === target || this.options.match === target
			}
		};
		module.exports = QueryHandler
	}, {}],
	36: [function (require, module, exports) {
		function each(collection, fn) {
			var i = 0,
				length = collection.length,
				cont;
			for (i; i < length; i++) {
				cont = fn(collection[i], i);
				if (cont === false) {
					break
				}
			}
		}

		function isArray(target) {
			return Object.prototype.toString.apply(target) === "[object Array]"
		}

		function isFunction(target) {
			return typeof target === "function"
		}
		module.exports = {
			isFunction: isFunction,
			isArray: isArray,
			each: each
		}
	}, {}],
	37: [function (require, module, exports) {
		var MediaQueryDispatch = require("./MediaQueryDispatch");
		module.exports = new MediaQueryDispatch
	}, {
		"./MediaQueryDispatch": 34
	}],
	38: [function (require, module, exports) {
		(function (process, global) {
			(function () {
				(function (global, factory) {
					typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.ES6Promise = factory()
				})(this, function () {
					"use strict";

					function objectOrFunction(x) {
						var type = typeof x;
						return x !== null && (type === "object" || type === "function")
					}

					function isFunction(x) {
						return typeof x === "function"
					}
					var _isArray = void 0;
					if (Array.isArray) {
						_isArray = Array.isArray
					} else {
						_isArray = function (x) {
							return Object.prototype.toString.call(x) === "[object Array]"
						}
					}
					var isArray = _isArray;
					var len = 0;
					var vertxNext = void 0;
					var customSchedulerFn = void 0;
					var asap = function asap(callback, arg) {
						queue[len] = callback;
						queue[len + 1] = arg;
						len += 2;
						if (len === 2) {
							if (customSchedulerFn) {
								customSchedulerFn(flush)
							} else {
								scheduleFlush()
							}
						}
					};

					function setScheduler(scheduleFn) {
						customSchedulerFn = scheduleFn
					}

					function setAsap(asapFn) {
						asap = asapFn
					}
					var browserWindow = typeof window !== "undefined" ? window : undefined;
					var browserGlobal = browserWindow || {};
					var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
					var isNode = typeof self === "undefined" && typeof process !== "undefined" && {}.toString.call(process) === "[object process]";
					var isWorker = typeof Uint8ClampedArray !== "undefined" && typeof importScripts !== "undefined" && typeof MessageChannel !== "undefined";

					function useNextTick() {
						return function () {
							return process.nextTick(flush)
						}
					}

					function useVertxTimer() {
						if (typeof vertxNext !== "undefined") {
							return function () {
								vertxNext(flush)
							}
						}
						return useSetTimeout()
					}

					function useMutationObserver() {
						var iterations = 0;
						var observer = new BrowserMutationObserver(flush);
						var node = document.createTextNode("");
						observer.observe(node, {
							characterData: true
						});
						return function () {
							node.data = iterations = ++iterations % 2
						}
					}

					function useMessageChannel() {
						var channel = new MessageChannel;
						channel.port1.onmessage = flush;
						return function () {
							return channel.port2.postMessage(0)
						}
					}

					function useSetTimeout() {
						var globalSetTimeout = setTimeout;
						return function () {
							return globalSetTimeout(flush, 1)
						}
					}
					var queue = new Array(1e3);

					function flush() {
						for (var i = 0; i < len; i += 2) {
							var callback = queue[i];
							var arg = queue[i + 1];
							callback(arg);
							queue[i] = undefined;
							queue[i + 1] = undefined
						}
						len = 0
					}

					function attemptVertx() {
						try {
							var vertx = Function("return this")().require("vertx");
							vertxNext = vertx.runOnLoop || vertx.runOnContext;
							return useVertxTimer()
						} catch (e) {
							return useSetTimeout()
						}
					}
					var scheduleFlush = void 0;
					if (isNode) {
						scheduleFlush = useNextTick()
					} else if (BrowserMutationObserver) {
						scheduleFlush = useMutationObserver()
					} else if (isWorker) {
						scheduleFlush = useMessageChannel()
					} else if (browserWindow === undefined && typeof require === "function") {
						scheduleFlush = attemptVertx()
					} else {
						scheduleFlush = useSetTimeout()
					}

					function then(onFulfillment, onRejection) {
						var parent = this;
						var child = new this.constructor(noop);
						if (child[PROMISE_ID] === undefined) {
							makePromise(child)
						}
						var _state = parent._state;
						if (_state) {
							var callback = arguments[_state - 1];
							asap(function () {
								return invokeCallback(_state, child, callback, parent._result)
							})
						} else {
							subscribe(parent, child, onFulfillment, onRejection)
						}
						return child
					}

					function resolve$1(object) {
						var Constructor = this;
						if (object && typeof object === "object" && object.constructor === Constructor) {
							return object
						}
						var promise = new Constructor(noop);
						resolve(promise, object);
						return promise
					}
					var PROMISE_ID = Math.random().toString(36).substring(2);

					function noop() {}
					var PENDING = void 0;
					var FULFILLED = 1;
					var REJECTED = 2;

					function selfFulfillment() {
						return new TypeError("You cannot resolve a promise with itself")
					}

					function cannotReturnOwn() {
						return new TypeError("A promises callback cannot return that same promise.")
					}

					function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
						try {
							then$$1.call(value, fulfillmentHandler, rejectionHandler)
						} catch (e) {
							return e
						}
					}

					function handleForeignThenable(promise, thenable, then$$1) {
						asap(function (promise) {
							var sealed = false;
							var error = tryThen(then$$1, thenable, function (value) {
								if (sealed) {
									return
								}
								sealed = true;
								if (thenable !== value) {
									resolve(promise, value)
								} else {
									fulfill(promise, value)
								}
							}, function (reason) {
								if (sealed) {
									return
								}
								sealed = true;
								reject(promise, reason)
							}, "Settle: " + (promise._label || " unknown promise"));
							if (!sealed && error) {
								sealed = true;
								reject(promise, error)
							}
						}, promise)
					}

					function handleOwnThenable(promise, thenable) {
						if (thenable._state === FULFILLED) {
							fulfill(promise, thenable._result)
						} else if (thenable._state === REJECTED) {
							reject(promise, thenable._result)
						} else {
							subscribe(thenable, undefined, function (value) {
								return resolve(promise, value)
							}, function (reason) {
								return reject(promise, reason)
							})
						}
					}

					function handleMaybeThenable(promise, maybeThenable, then$$1) {
						if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
							handleOwnThenable(promise, maybeThenable)
						} else {
							if (then$$1 === undefined) {
								fulfill(promise, maybeThenable)
							} else if (isFunction(then$$1)) {
								handleForeignThenable(promise, maybeThenable, then$$1)
							} else {
								fulfill(promise, maybeThenable)
							}
						}
					}

					function resolve(promise, value) {
						if (promise === value) {
							reject(promise, selfFulfillment())
						} else if (objectOrFunction(value)) {
							var then$$1 = void 0;
							try {
								then$$1 = value.then
							} catch (error) {
								reject(promise, error);
								return
							}
							handleMaybeThenable(promise, value, then$$1)
						} else {
							fulfill(promise, value)
						}
					}

					function publishRejection(promise) {
						if (promise._onerror) {
							promise._onerror(promise._result)
						}
						publish(promise)
					}

					function fulfill(promise, value) {
						if (promise._state !== PENDING) {
							return
						}
						promise._result = value;
						promise._state = FULFILLED;
						if (promise._subscribers.length !== 0) {
							asap(publish, promise)
						}
					}

					function reject(promise, reason) {
						if (promise._state !== PENDING) {
							return
						}
						promise._state = REJECTED;
						promise._result = reason;
						asap(publishRejection, promise)
					}

					function subscribe(parent, child, onFulfillment, onRejection) {
						var _subscribers = parent._subscribers;
						var length = _subscribers.length;
						parent._onerror = null;
						_subscribers[length] = child;
						_subscribers[length + FULFILLED] = onFulfillment;
						_subscribers[length + REJECTED] = onRejection;
						if (length === 0 && parent._state) {
							asap(publish, parent)
						}
					}

					function publish(promise) {
						var subscribers = promise._subscribers;
						var settled = promise._state;
						if (subscribers.length === 0) {
							return
						}
						var child = void 0,
							callback = void 0,
							detail = promise._result;
						for (var i = 0; i < subscribers.length; i += 3) {
							child = subscribers[i];
							callback = subscribers[i + settled];
							if (child) {
								invokeCallback(settled, child, callback, detail)
							} else {
								callback(detail)
							}
						}
						promise._subscribers.length = 0
					}

					function invokeCallback(settled, promise, callback, detail) {
						var hasCallback = isFunction(callback),
							value = void 0,
							error = void 0,
							succeeded = true;
						if (hasCallback) {
							try {
								value = callback(detail)
							} catch (e) {
								succeeded = false;
								error = e
							}
							if (promise === value) {
								reject(promise, cannotReturnOwn());
								return
							}
						} else {
							value = detail
						}
						if (promise._state !== PENDING) {} else if (hasCallback && succeeded) {
							resolve(promise, value)
						} else if (succeeded === false) {
							reject(promise, error)
						} else if (settled === FULFILLED) {
							fulfill(promise, value)
						} else if (settled === REJECTED) {
							reject(promise, value)
						}
					}

					function initializePromise(promise, resolver) {
						try {
							resolver(function resolvePromise(value) {
								resolve(promise, value)
							}, function rejectPromise(reason) {
								reject(promise, reason)
							})
						} catch (e) {
							reject(promise, e)
						}
					}
					var id = 0;

					function nextId() {
						return id++
					}

					function makePromise(promise) {
						promise[PROMISE_ID] = id++;
						promise._state = undefined;
						promise._result = undefined;
						promise._subscribers = []
					}

					function validationError() {
						return new Error("Array Methods must be provided an Array")
					}
					var Enumerator = function () {
						function Enumerator(Constructor, input) {
							this._instanceConstructor = Constructor;
							this.promise = new Constructor(noop);
							if (!this.promise[PROMISE_ID]) {
								makePromise(this.promise)
							}
							if (isArray(input)) {
								this.length = input.length;
								this._remaining = input.length;
								this._result = new Array(this.length);
								if (this.length === 0) {
									fulfill(this.promise, this._result)
								} else {
									this.length = this.length || 0;
									this._enumerate(input);
									if (this._remaining === 0) {
										fulfill(this.promise, this._result)
									}
								}
							} else {
								reject(this.promise, validationError())
							}
						}
						Enumerator.prototype._enumerate = function _enumerate(input) {
							for (var i = 0; this._state === PENDING && i < input.length; i++) {
								this._eachEntry(input[i], i)
							}
						};
						Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
							var c = this._instanceConstructor;
							var resolve$$1 = c.resolve;
							if (resolve$$1 === resolve$1) {
								var _then = void 0;
								var error = void 0;
								var didError = false;
								try {
									_then = entry.then
								} catch (e) {
									didError = true;
									error = e
								}
								if (_then === then && entry._state !== PENDING) {
									this._settledAt(entry._state, i, entry._result)
								} else if (typeof _then !== "function") {
									this._remaining--;
									this._result[i] = entry
								} else if (c === Promise$1) {
									var promise = new c(noop);
									if (didError) {
										reject(promise, error)
									} else {
										handleMaybeThenable(promise, entry, _then)
									}
									this._willSettleAt(promise, i)
								} else {
									this._willSettleAt(new c(function (resolve$$1) {
										return resolve$$1(entry)
									}), i)
								}
							} else {
								this._willSettleAt(resolve$$1(entry), i)
							}
						};
						Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
							var promise = this.promise;
							if (promise._state === PENDING) {
								this._remaining--;
								if (state === REJECTED) {
									reject(promise, value)
								} else {
									this._result[i] = value
								}
							}
							if (this._remaining === 0) {
								fulfill(promise, this._result)
							}
						};
						Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
							var enumerator = this;
							subscribe(promise, undefined, function (value) {
								return enumerator._settledAt(FULFILLED, i, value)
							}, function (reason) {
								return enumerator._settledAt(REJECTED, i, reason)
							})
						};
						return Enumerator
					}();

					function all(entries) {
						return new Enumerator(this, entries).promise
					}

					function race(entries) {
						var Constructor = this;
						if (!isArray(entries)) {
							return new Constructor(function (_, reject) {
								return reject(new TypeError("You must pass an array to race."))
							})
						} else {
							return new Constructor(function (resolve, reject) {
								var length = entries.length;
								for (var i = 0; i < length; i++) {
									Constructor.resolve(entries[i]).then(resolve, reject)
								}
							})
						}
					}

					function reject$1(reason) {
						var Constructor = this;
						var promise = new Constructor(noop);
						reject(promise, reason);
						return promise
					}

					function needsResolver() {
						throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")
					}

					function needsNew() {
						throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")
					}
					var Promise$1 = function () {
						function Promise(resolver) {
							this[PROMISE_ID] = nextId();
							this._result = this._state = undefined;
							this._subscribers = [];
							if (noop !== resolver) {
								typeof resolver !== "function" && needsResolver();
								this instanceof Promise ? initializePromise(this, resolver) : needsNew()
							}
						}
						Promise.prototype.catch = function _catch(onRejection) {
							return this.then(null, onRejection)
						};
						Promise.prototype.finally = function _finally(callback) {
							var promise = this;
							var constructor = promise.constructor;
							if (isFunction(callback)) {
								return promise.then(function (value) {
									return constructor.resolve(callback()).then(function () {
										return value
									})
								}, function (reason) {
									return constructor.resolve(callback()).then(function () {
										throw reason
									})
								})
							}
							return promise.then(callback, callback)
						};
						return Promise
					}();
					Promise$1.prototype.then = then;
					Promise$1.all = all;
					Promise$1.race = race;
					Promise$1.resolve = resolve$1;
					Promise$1.reject = reject$1;
					Promise$1._setScheduler = setScheduler;
					Promise$1._setAsap = setAsap;
					Promise$1._asap = asap;

					function polyfill() {
						var local = void 0;
						if (typeof global !== "undefined") {
							local = global
						} else if (typeof self !== "undefined") {
							local = self
						} else {
							try {
								local = Function("return this")()
							} catch (e) {
								throw new Error("polyfill failed because global object is unavailable in this environment")
							}
						}
						var P = local.Promise;
						if (P) {
							var promiseToString = null;
							try {
								promiseToString = Object.prototype.toString.call(P.resolve())
							} catch (e) {}
							if (promiseToString === "[object Promise]" && !P.cast) {
								return
							}
						}
						local.Promise = Promise$1
					}
					Promise$1.polyfill = polyfill;
					Promise$1.Promise = Promise$1;
					return Promise$1
				})
			}).call(this)
		}).call(this, require("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	}, {
		_process: 43
	}],
	39: [function (require, module, exports) {
		(function () {
			"use strict";
			if (typeof window !== "object") {
				return
			}
			if ("IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype) {
				if (!("isIntersecting" in window.IntersectionObserverEntry.prototype)) {
					Object.defineProperty(window.IntersectionObserverEntry.prototype, "isIntersecting", {
						get: function () {
							return this.intersectionRatio > 0
						}
					})
				}
				return
			}

			function getFrameElement(doc) {
				try {
					return doc.defaultView && doc.defaultView.frameElement || null
				} catch (e) {
					return null
				}
			}
			var document = function (startDoc) {
				var doc = startDoc;
				var frame = getFrameElement(doc);
				while (frame) {
					doc = frame.ownerDocument;
					frame = getFrameElement(doc)
				}
				return doc
			}(window.document);
			var registry = [];
			var crossOriginUpdater = null;
			var crossOriginRect = null;

			function IntersectionObserverEntry(entry) {
				this.time = entry.time;
				this.target = entry.target;
				this.rootBounds = ensureDOMRect(entry.rootBounds);
				this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);
				this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());
				this.isIntersecting = !!entry.intersectionRect;
				var targetRect = this.boundingClientRect;
				var targetArea = targetRect.width * targetRect.height;
				var intersectionRect = this.intersectionRect;
				var intersectionArea = intersectionRect.width * intersectionRect.height;
				if (targetArea) {
					this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4))
				} else {
					this.intersectionRatio = this.isIntersecting ? 1 : 0
				}
			}

			function IntersectionObserver(callback, opt_options) {
				var options = opt_options || {};
				if (typeof callback != "function") {
					throw new Error("callback must be a function")
				}
				if (options.root && options.root.nodeType != 1 && options.root.nodeType != 9) {
					throw new Error("root must be a Document or Element")
				}
				this._checkForIntersections = throttle(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);
				this._callback = callback;
				this._observationTargets = [];
				this._queuedEntries = [];
				this._rootMarginValues = this._parseRootMargin(options.rootMargin);
				this.thresholds = this._initThresholds(options.threshold);
				this.root = options.root || null;
				this.rootMargin = this._rootMarginValues.map(function (margin) {
					return margin.value + margin.unit
				}).join(" ");
				this._monitoringDocuments = [];
				this._monitoringUnsubscribes = []
			}
			IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;
			IntersectionObserver.prototype.POLL_INTERVAL = null;
			IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;
			IntersectionObserver._setupCrossOriginUpdater = function () {
				if (!crossOriginUpdater) {
					crossOriginUpdater = function (boundingClientRect, intersectionRect) {
						if (!boundingClientRect || !intersectionRect) {
							crossOriginRect = getEmptyRect()
						} else {
							crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect)
						}
						registry.forEach(function (observer) {
							observer._checkForIntersections()
						})
					}
				}
				return crossOriginUpdater
			};
			IntersectionObserver._resetCrossOriginUpdater = function () {
				crossOriginUpdater = null;
				crossOriginRect = null
			};
			IntersectionObserver.prototype.observe = function (target) {
				var isTargetAlreadyObserved = this._observationTargets.some(function (item) {
					return item.element == target
				});
				if (isTargetAlreadyObserved) {
					return
				}
				if (!(target && target.nodeType == 1)) {
					throw new Error("target must be an Element")
				}
				this._registerInstance();
				this._observationTargets.push({
					element: target,
					entry: null
				});
				this._monitorIntersections(target.ownerDocument);
				this._checkForIntersections()
			};
			IntersectionObserver.prototype.unobserve = function (target) {
				this._observationTargets = this._observationTargets.filter(function (item) {
					return item.element != target
				});
				this._unmonitorIntersections(target.ownerDocument);
				if (this._observationTargets.length == 0) {
					this._unregisterInstance()
				}
			};
			IntersectionObserver.prototype.disconnect = function () {
				this._observationTargets = [];
				this._unmonitorAllIntersections();
				this._unregisterInstance()
			};
			IntersectionObserver.prototype.takeRecords = function () {
				var records = this._queuedEntries.slice();
				this._queuedEntries = [];
				return records
			};
			IntersectionObserver.prototype._initThresholds = function (opt_threshold) {
				var threshold = opt_threshold || [0];
				if (!Array.isArray(threshold)) threshold = [threshold];
				return threshold.sort().filter(function (t, i, a) {
					if (typeof t != "number" || isNaN(t) || t < 0 || t > 1) {
						throw new Error("threshold must be a number between 0 and 1 inclusively")
					}
					return t !== a[i - 1]
				})
			};
			IntersectionObserver.prototype._parseRootMargin = function (opt_rootMargin) {
				var marginString = opt_rootMargin || "0px";
				var margins = marginString.split(/\s+/).map(function (margin) {
					var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
					if (!parts) {
						throw new Error("rootMargin must be specified in pixels or percent")
					}
					return {
						value: parseFloat(parts[1]),
						unit: parts[2]
					}
				});
				margins[1] = margins[1] || margins[0];
				margins[2] = margins[2] || margins[0];
				margins[3] = margins[3] || margins[1];
				return margins
			};
			IntersectionObserver.prototype._monitorIntersections = function (doc) {
				var win = doc.defaultView;
				if (!win) {
					return
				}
				if (this._monitoringDocuments.indexOf(doc) != -1) {
					return
				}
				var callback = this._checkForIntersections;
				var monitoringInterval = null;
				var domObserver = null;
				if (this.POLL_INTERVAL) {
					monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL)
				} else {
					addEvent(win, "resize", callback, true);
					addEvent(doc, "scroll", callback, true);
					if (this.USE_MUTATION_OBSERVER && "MutationObserver" in win) {
						domObserver = new win.MutationObserver(callback);
						domObserver.observe(doc, {
							attributes: true,
							childList: true,
							characterData: true,
							subtree: true
						})
					}
				}
				this._monitoringDocuments.push(doc);
				this._monitoringUnsubscribes.push(function () {
					var win = doc.defaultView;
					if (win) {
						if (monitoringInterval) {
							win.clearInterval(monitoringInterval)
						}
						removeEvent(win, "resize", callback, true)
					}
					removeEvent(doc, "scroll", callback, true);
					if (domObserver) {
						domObserver.disconnect()
					}
				});
				var rootDoc = this.root && (this.root.ownerDocument || this.root) || document;
				if (doc != rootDoc) {
					var frame = getFrameElement(doc);
					if (frame) {
						this._monitorIntersections(frame.ownerDocument)
					}
				}
			};
			IntersectionObserver.prototype._unmonitorIntersections = function (doc) {
				var index = this._monitoringDocuments.indexOf(doc);
				if (index == -1) {
					return
				}
				var rootDoc = this.root && (this.root.ownerDocument || this.root) || document;
				var hasDependentTargets = this._observationTargets.some(function (item) {
					var itemDoc = item.element.ownerDocument;
					if (itemDoc == doc) {
						return true
					}
					while (itemDoc && itemDoc != rootDoc) {
						var frame = getFrameElement(itemDoc);
						itemDoc = frame && frame.ownerDocument;
						if (itemDoc == doc) {
							return true
						}
					}
					return false
				});
				if (hasDependentTargets) {
					return
				}
				var unsubscribe = this._monitoringUnsubscribes[index];
				this._monitoringDocuments.splice(index, 1);
				this._monitoringUnsubscribes.splice(index, 1);
				unsubscribe();
				if (doc != rootDoc) {
					var frame = getFrameElement(doc);
					if (frame) {
						this._unmonitorIntersections(frame.ownerDocument)
					}
				}
			};
			IntersectionObserver.prototype._unmonitorAllIntersections = function () {
				var unsubscribes = this._monitoringUnsubscribes.slice(0);
				this._monitoringDocuments.length = 0;
				this._monitoringUnsubscribes.length = 0;
				for (var i = 0; i < unsubscribes.length; i++) {
					unsubscribes[i]()
				}
			};
			IntersectionObserver.prototype._checkForIntersections = function () {
				if (!this.root && crossOriginUpdater && !crossOriginRect) {
					return
				}
				var rootIsInDom = this._rootIsInDom();
				var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();
				this._observationTargets.forEach(function (item) {
					var target = item.element;
					var targetRect = getBoundingClientRect(target);
					var rootContainsTarget = this._rootContainsTarget(target);
					var oldEntry = item.entry;
					var intersectionRect = rootIsInDom && rootContainsTarget && this._computeTargetAndRootIntersection(target, targetRect, rootRect);
					var rootBounds = null;
					if (!this._rootContainsTarget(target)) {
						rootBounds = getEmptyRect()
					} else if (!crossOriginUpdater || this.root) {
						rootBounds = rootRect
					}
					var newEntry = item.entry = new IntersectionObserverEntry({
						time: now(),
						target: target,
						boundingClientRect: targetRect,
						rootBounds: rootBounds,
						intersectionRect: intersectionRect
					});
					if (!oldEntry) {
						this._queuedEntries.push(newEntry)
					} else if (rootIsInDom && rootContainsTarget) {
						if (this._hasCrossedThreshold(oldEntry, newEntry)) {
							this._queuedEntries.push(newEntry)
						}
					} else {
						if (oldEntry && oldEntry.isIntersecting) {
							this._queuedEntries.push(newEntry)
						}
					}
				}, this);
				if (this._queuedEntries.length) {
					this._callback(this.takeRecords(), this)
				}
			};
			IntersectionObserver.prototype._computeTargetAndRootIntersection = function (target, targetRect, rootRect) {
				if (window.getComputedStyle(target).display == "none") return;
				var intersectionRect = targetRect;
				var parent = getParentNode(target);
				var atRoot = false;
				while (!atRoot && parent) {
					var parentRect = null;
					var parentComputedStyle = parent.nodeType == 1 ? window.getComputedStyle(parent) : {};
					if (parentComputedStyle.display == "none") return null;
					if (parent == this.root || parent.nodeType == 9) {
						atRoot = true;
						if (parent == this.root || parent == document) {
							if (crossOriginUpdater && !this.root) {
								if (!crossOriginRect || crossOriginRect.width == 0 && crossOriginRect.height == 0) {
									parent = null;
									parentRect = null;
									intersectionRect = null
								} else {
									parentRect = crossOriginRect
								}
							} else {
								parentRect = rootRect
							}
						} else {
							var frame = getParentNode(parent);
							var frameRect = frame && getBoundingClientRect(frame);
							var frameIntersect = frame && this._computeTargetAndRootIntersection(frame, frameRect, rootRect);
							if (frameRect && frameIntersect) {
								parent = frame;
								parentRect = convertFromParentRect(frameRect, frameIntersect)
							} else {
								parent = null;
								intersectionRect = null
							}
						}
					} else {
						var doc = parent.ownerDocument;
						if (parent != doc.body && parent != doc.documentElement && parentComputedStyle.overflow != "visible") {
							parentRect = getBoundingClientRect(parent)
						}
					}
					if (parentRect) {
						intersectionRect = computeRectIntersection(parentRect, intersectionRect)
					}
					if (!intersectionRect) break;
					parent = parent && getParentNode(parent)
				}
				return intersectionRect
			};
			IntersectionObserver.prototype._getRootRect = function () {
				var rootRect;
				if (this.root && !isDoc(this.root)) {
					rootRect = getBoundingClientRect(this.root)
				} else {
					var doc = isDoc(this.root) ? this.root : document;
					var html = doc.documentElement;
					var body = doc.body;
					rootRect = {
						top: 0,
						left: 0,
						right: html.clientWidth || body.clientWidth,
						width: html.clientWidth || body.clientWidth,
						bottom: html.clientHeight || body.clientHeight,
						height: html.clientHeight || body.clientHeight
					}
				}
				return this._expandRectByRootMargin(rootRect)
			};
			IntersectionObserver.prototype._expandRectByRootMargin = function (rect) {
				var margins = this._rootMarginValues.map(function (margin, i) {
					return margin.unit == "px" ? margin.value : margin.value * (i % 2 ? rect.width : rect.height) / 100
				});
				var newRect = {
					top: rect.top - margins[0],
					right: rect.right + margins[1],
					bottom: rect.bottom + margins[2],
					left: rect.left - margins[3]
				};
				newRect.width = newRect.right - newRect.left;
				newRect.height = newRect.bottom - newRect.top;
				return newRect
			};
			IntersectionObserver.prototype._hasCrossedThreshold = function (oldEntry, newEntry) {
				var oldRatio = oldEntry && oldEntry.isIntersecting ? oldEntry.intersectionRatio || 0 : -1;
				var newRatio = newEntry.isIntersecting ? newEntry.intersectionRatio || 0 : -1;
				if (oldRatio === newRatio) return;
				for (var i = 0; i < this.thresholds.length; i++) {
					var threshold = this.thresholds[i];
					if (threshold == oldRatio || threshold == newRatio || threshold < oldRatio !== threshold < newRatio) {
						return true
					}
				}
			};
			IntersectionObserver.prototype._rootIsInDom = function () {
				return !this.root || containsDeep(document, this.root)
			};
			IntersectionObserver.prototype._rootContainsTarget = function (target) {
				var rootDoc = this.root && (this.root.ownerDocument || this.root) || document;
				return containsDeep(rootDoc, target) && (!this.root || rootDoc == target.ownerDocument)
			};
			IntersectionObserver.prototype._registerInstance = function () {
				if (registry.indexOf(this) < 0) {
					registry.push(this)
				}
			};
			IntersectionObserver.prototype._unregisterInstance = function () {
				var index = registry.indexOf(this);
				if (index != -1) registry.splice(index, 1)
			};

			function now() {
				return window.performance && performance.now && performance.now()
			}

			function throttle(fn, timeout) {
				var timer = null;
				return function () {
					if (!timer) {
						timer = setTimeout(function () {
							fn();
							timer = null
						}, timeout)
					}
				}
			}

			function addEvent(node, event, fn, opt_useCapture) {
				if (typeof node.addEventListener == "function") {
					node.addEventListener(event, fn, opt_useCapture || false)
				} else if (typeof node.attachEvent == "function") {
					node.attachEvent("on" + event, fn)
				}
			}

			function removeEvent(node, event, fn, opt_useCapture) {
				if (typeof node.removeEventListener == "function") {
					node.removeEventListener(event, fn, opt_useCapture || false)
				} else if (typeof node.detatchEvent == "function") {
					node.detatchEvent("on" + event, fn)
				}
			}

			function computeRectIntersection(rect1, rect2) {
				var top = Math.max(rect1.top, rect2.top);
				var bottom = Math.min(rect1.bottom, rect2.bottom);
				var left = Math.max(rect1.left, rect2.left);
				var right = Math.min(rect1.right, rect2.right);
				var width = right - left;
				var height = bottom - top;
				return width >= 0 && height >= 0 && {
					top: top,
					bottom: bottom,
					left: left,
					right: right,
					width: width,
					height: height
				} || null
			}

			function getBoundingClientRect(el) {
				var rect;
				try {
					rect = el.getBoundingClientRect()
				} catch (err) {}
				if (!rect) return getEmptyRect();
				if (!(rect.width && rect.height)) {
					rect = {
						top: rect.top,
						right: rect.right,
						bottom: rect.bottom,
						left: rect.left,
						width: rect.right - rect.left,
						height: rect.bottom - rect.top
					}
				}
				return rect
			}

			function getEmptyRect() {
				return {
					top: 0,
					bottom: 0,
					left: 0,
					right: 0,
					width: 0,
					height: 0
				}
			}

			function ensureDOMRect(rect) {
				if (!rect || "x" in rect) {
					return rect
				}
				return {
					top: rect.top,
					y: rect.top,
					bottom: rect.bottom,
					left: rect.left,
					x: rect.left,
					right: rect.right,
					width: rect.width,
					height: rect.height
				}
			}

			function convertFromParentRect(parentBoundingRect, parentIntersectionRect) {
				var top = parentIntersectionRect.top - parentBoundingRect.top;
				var left = parentIntersectionRect.left - parentBoundingRect.left;
				return {
					top: top,
					left: left,
					height: parentIntersectionRect.height,
					width: parentIntersectionRect.width,
					bottom: top + parentIntersectionRect.height,
					right: left + parentIntersectionRect.width
				}
			}

			function containsDeep(parent, child) {
				var node = child;
				while (node) {
					if (node == parent) return true;
					node = getParentNode(node)
				}
				return false
			}

			function getParentNode(node) {
				var parent = node.parentNode;
				if (node.nodeType == 9 && node != document) {
					return getFrameElement(node)
				}
				if (parent && parent.assignedSlot) {
					parent = parent.assignedSlot.parentNode
				}
				if (parent && parent.nodeType == 11 && parent.host) {
					return parent.host
				}
				return parent
			}

			function isDoc(node) {
				return node && node.nodeType === 9
			}
			window.IntersectionObserver = IntersectionObserver;
			window.IntersectionObserverEntry = IntersectionObserverEntry
		})()
	}, {}],
	40: [function (require, module, exports) {
		(function (global, factory) {
			"use strict";
			if (typeof module === "object" && typeof module.exports === "object") {
				module.exports = global.document ? factory(global, true) : function (w) {
					if (!w.document) {
						throw new Error("jQuery requires a window with a document")
					}
					return factory(w)
				}
			} else {
				factory(global)
			}
		})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
			"use strict";
			var arr = [];
			var getProto = Object.getPrototypeOf;
			var slice = arr.slice;
			var flat = arr.flat ? function (array) {
				return arr.flat.call(array)
			} : function (array) {
				return arr.concat.apply([], array)
			};
			var push = arr.push;
			var indexOf = arr.indexOf;
			var class2type = {};
			var toString = class2type.toString;
			var hasOwn = class2type.hasOwnProperty;
			var fnToString = hasOwn.toString;
			var ObjectFunctionString = fnToString.call(Object);
			var support = {};
			var isFunction = function isFunction(obj) {
				return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function"
			};
			var isWindow = function isWindow(obj) {
				return obj != null && obj === obj.window
			};
			var document = window.document;
			var preservedScriptAttributes = {
				type: true,
				src: true,
				nonce: true,
				noModule: true
			};

			function DOMEval(code, node, doc) {
				doc = doc || document;
				var i, val, script = doc.createElement("script");
				script.text = code;
				if (node) {
					for (i in preservedScriptAttributes) {
						val = node[i] || node.getAttribute && node.getAttribute(i);
						if (val) {
							script.setAttribute(i, val)
						}
					}
				}
				doc.head.appendChild(script).parentNode.removeChild(script)
			}

			function toType(obj) {
				if (obj == null) {
					return obj + ""
				}
				return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj
			}
			var version = "3.6.0",
				jQuery = function (selector, context) {
					return new jQuery.fn.init(selector, context)
				};
			jQuery.fn = jQuery.prototype = {
				jquery: version,
				constructor: jQuery,
				length: 0,
				toArray: function () {
					return slice.call(this)
				},
				get: function (num) {
					if (num == null) {
						return slice.call(this)
					}
					return num < 0 ? this[num + this.length] : this[num]
				},
				pushStack: function (elems) {
					var ret = jQuery.merge(this.constructor(), elems);
					ret.prevObject = this;
					return ret
				},
				each: function (callback) {
					return jQuery.each(this, callback)
				},
				map: function (callback) {
					return this.pushStack(jQuery.map(this, function (elem, i) {
						return callback.call(elem, i, elem)
					}))
				},
				slice: function () {
					return this.pushStack(slice.apply(this, arguments))
				},
				first: function () {
					return this.eq(0)
				},
				last: function () {
					return this.eq(-1)
				},
				even: function () {
					return this.pushStack(jQuery.grep(this, function (_elem, i) {
						return (i + 1) % 2
					}))
				},
				odd: function () {
					return this.pushStack(jQuery.grep(this, function (_elem, i) {
						return i % 2
					}))
				},
				eq: function (i) {
					var len = this.length,
						j = +i + (i < 0 ? len : 0);
					return this.pushStack(j >= 0 && j < len ? [this[j]] : [])
				},
				end: function () {
					return this.prevObject || this.constructor()
				},
				push: push,
				sort: arr.sort,
				splice: arr.splice
			};
			jQuery.extend = jQuery.fn.extend = function () {
				var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
					i = 1,
					length = arguments.length,
					deep = false;
				if (typeof target === "boolean") {
					deep = target;
					target = arguments[i] || {};
					i++
				}
				if (typeof target !== "object" && !isFunction(target)) {
					target = {}
				}
				if (i === length) {
					target = this;
					i--
				}
				for (; i < length; i++) {
					if ((options = arguments[i]) != null) {
						for (name in options) {
							copy = options[name];
							if (name === "__proto__" || target === copy) {
								continue
							}
							if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
								src = target[name];
								if (copyIsArray && !Array.isArray(src)) {
									clone = []
								} else if (!copyIsArray && !jQuery.isPlainObject(src)) {
									clone = {}
								} else {
									clone = src
								}
								copyIsArray = false;
								target[name] = jQuery.extend(deep, clone, copy)
							} else if (copy !== undefined) {
								target[name] = copy
							}
						}
					}
				}
				return target
			};
			jQuery.extend({
				expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
				isReady: true,
				error: function (msg) {
					throw new Error(msg)
				},
				noop: function () {},
				isPlainObject: function (obj) {
					var proto, Ctor;
					if (!obj || toString.call(obj) !== "[object Object]") {
						return false
					}
					proto = getProto(obj);
					if (!proto) {
						return true
					}
					Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
					return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString
				},
				isEmptyObject: function (obj) {
					var name;
					for (name in obj) {
						return false
					}
					return true
				},
				globalEval: function (code, options, doc) {
					DOMEval(code, {
						nonce: options && options.nonce
					}, doc)
				},
				each: function (obj, callback) {
					var length, i = 0;
					if (isArrayLike(obj)) {
						length = obj.length;
						for (; i < length; i++) {
							if (callback.call(obj[i], i, obj[i]) === false) {
								break
							}
						}
					} else {
						for (i in obj) {
							if (callback.call(obj[i], i, obj[i]) === false) {
								break
							}
						}
					}
					return obj
				},
				makeArray: function (arr, results) {
					var ret = results || [];
					if (arr != null) {
						if (isArrayLike(Object(arr))) {
							jQuery.merge(ret, typeof arr === "string" ? [arr] : arr)
						} else {
							push.call(ret, arr)
						}
					}
					return ret
				},
				inArray: function (elem, arr, i) {
					return arr == null ? -1 : indexOf.call(arr, elem, i)
				},
				merge: function (first, second) {
					var len = +second.length,
						j = 0,
						i = first.length;
					for (; j < len; j++) {
						first[i++] = second[j]
					}
					first.length = i;
					return first
				},
				grep: function (elems, callback, invert) {
					var callbackInverse, matches = [],
						i = 0,
						length = elems.length,
						callbackExpect = !invert;
					for (; i < length; i++) {
						callbackInverse = !callback(elems[i], i);
						if (callbackInverse !== callbackExpect) {
							matches.push(elems[i])
						}
					}
					return matches
				},
				map: function (elems, callback, arg) {
					var length, value, i = 0,
						ret = [];
					if (isArrayLike(elems)) {
						length = elems.length;
						for (; i < length; i++) {
							value = callback(elems[i], i, arg);
							if (value != null) {
								ret.push(value)
							}
						}
					} else {
						for (i in elems) {
							value = callback(elems[i], i, arg);
							if (value != null) {
								ret.push(value)
							}
						}
					}
					return flat(ret)
				},
				guid: 1,
				support: support
			});
			if (typeof Symbol === "function") {
				jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]
			}
			jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (_i, name) {
				class2type["[object " + name + "]"] = name.toLowerCase()
			});

			function isArrayLike(obj) {
				var length = !!obj && "length" in obj && obj.length,
					type = toType(obj);
				if (isFunction(obj) || isWindow(obj)) {
					return false
				}
				return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj
			}
			var Sizzle = function (window) {
				var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date,
					preferredDoc = window.document,
					dirruns = 0,
					done = 0,
					classCache = createCache(),
					tokenCache = createCache(),
					compilerCache = createCache(),
					nonnativeSelectorCache = createCache(),
					sortOrder = function (a, b) {
						if (a === b) {
							hasDuplicate = true
						}
						return 0
					},
					hasOwn = {}.hasOwnProperty,
					arr = [],
					pop = arr.pop,
					pushNative = arr.push,
					push = arr.push,
					slice = arr.slice,
					indexOf = function (list, elem) {
						var i = 0,
							len = list.length;
						for (; i < len; i++) {
							if (list[i] === elem) {
								return i
							}
						}
						return -1
					},
					booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" + "ismap|loop|multiple|open|readonly|required|scoped",
					whitespace = "[\\x20\\t\\r\\n\\f]",
					identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
					attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
					pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
					rwhitespace = new RegExp(whitespace + "+", "g"),
					rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
					rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
					rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
					rdescend = new RegExp(whitespace + "|>"),
					rpseudo = new RegExp(pseudos),
					ridentifier = new RegExp("^" + identifier + "$"),
					matchExpr = {
						ID: new RegExp("^#(" + identifier + ")"),
						CLASS: new RegExp("^\\.(" + identifier + ")"),
						TAG: new RegExp("^(" + identifier + "|[*])"),
						ATTR: new RegExp("^" + attributes),
						PSEUDO: new RegExp("^" + pseudos),
						CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
						bool: new RegExp("^(?:" + booleans + ")$", "i"),
						needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
					},
					rhtml = /HTML$/i,
					rinputs = /^(?:input|select|textarea|button)$/i,
					rheader = /^h\d$/i,
					rnative = /^[^{]+\{\s*\[native \w/,
					rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
					rsibling = /[+~]/,
					runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"),
					funescape = function (escape, nonHex) {
						var high = "0x" + escape.slice(1) - 65536;
						return nonHex ? nonHex : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
					},
					rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
					fcssescape = function (ch, asCodePoint) {
						if (asCodePoint) {
							if (ch === "\0") {
								return "�"
							}
							return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " "
						}
						return "\\" + ch
					},
					unloadHandler = function () {
						setDocument()
					},
					inDisabledFieldset = addCombinator(function (elem) {
						return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset"
					}, {
						dir: "parentNode",
						next: "legend"
					});
				try {
					push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
					arr[preferredDoc.childNodes.length].nodeType
				} catch (e) {
					push = {
						apply: arr.length ? function (target, els) {
							pushNative.apply(target, slice.call(els))
						} : function (target, els) {
							var j = target.length,
								i = 0;
							while (target[j++] = els[i++]) {}
							target.length = j - 1
						}
					}
				}

				function Sizzle(selector, context, results, seed) {
					var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument,
						nodeType = context ? context.nodeType : 9;
					results = results || [];
					if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
						return results
					}
					if (!seed) {
						setDocument(context);
						context = context || document;
						if (documentIsHTML) {
							if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
								if (m = match[1]) {
									if (nodeType === 9) {
										if (elem = context.getElementById(m)) {
											if (elem.id === m) {
												results.push(elem);
												return results
											}
										} else {
											return results
										}
									} else {
										if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
											results.push(elem);
											return results
										}
									}
								} else if (match[2]) {
									push.apply(results, context.getElementsByTagName(selector));
									return results
								} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
									push.apply(results, context.getElementsByClassName(m));
									return results
								}
							}
							if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
								newSelector = selector;
								newContext = context;
								if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
									newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
									if (newContext !== context || !support.scope) {
										if (nid = context.getAttribute("id")) {
											nid = nid.replace(rcssescape, fcssescape)
										} else {
											context.setAttribute("id", nid = expando)
										}
									}
									groups = tokenize(selector);
									i = groups.length;
									while (i--) {
										groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i])
									}
									newSelector = groups.join(",")
								}
								try {
									push.apply(results, newContext.querySelectorAll(newSelector));
									return results
								} catch (qsaError) {
									nonnativeSelectorCache(selector, true)
								} finally {
									if (nid === expando) {
										context.removeAttribute("id")
									}
								}
							}
						}
					}
					return select(selector.replace(rtrim, "$1"), context, results, seed)
				}

				function createCache() {
					var keys = [];

					function cache(key, value) {
						if (keys.push(key + " ") > Expr.cacheLength) {
							delete cache[keys.shift()]
						}
						return cache[key + " "] = value
					}
					return cache
				}

				function markFunction(fn) {
					fn[expando] = true;
					return fn
				}

				function assert(fn) {
					var el = document.createElement("fieldset");
					try {
						return !!fn(el)
					} catch (e) {
						return false
					} finally {
						if (el.parentNode) {
							el.parentNode.removeChild(el)
						}
						el = null
					}
				}

				function addHandle(attrs, handler) {
					var arr = attrs.split("|"),
						i = arr.length;
					while (i--) {
						Expr.attrHandle[arr[i]] = handler
					}
				}

				function siblingCheck(a, b) {
					var cur = b && a,
						diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
					if (diff) {
						return diff
					}
					if (cur) {
						while (cur = cur.nextSibling) {
							if (cur === b) {
								return -1
							}
						}
					}
					return a ? 1 : -1
				}

				function createInputPseudo(type) {
					return function (elem) {
						var name = elem.nodeName.toLowerCase();
						return name === "input" && elem.type === type
					}
				}

				function createButtonPseudo(type) {
					return function (elem) {
						var name = elem.nodeName.toLowerCase();
						return (name === "input" || name === "button") && elem.type === type
					}
				}

				function createDisabledPseudo(disabled) {
					return function (elem) {
						if ("form" in elem) {
							if (elem.parentNode && elem.disabled === false) {
								if ("label" in elem) {
									if ("label" in elem.parentNode) {
										return elem.parentNode.disabled === disabled
									} else {
										return elem.disabled === disabled
									}
								}
								return elem.isDisabled === disabled || elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled
							}
							return elem.disabled === disabled
						} else if ("label" in elem) {
							return elem.disabled === disabled
						}
						return false
					}
				}

				function createPositionalPseudo(fn) {
					return markFunction(function (argument) {
						argument = +argument;
						return markFunction(function (seed, matches) {
							var j, matchIndexes = fn([], seed.length, argument),
								i = matchIndexes.length;
							while (i--) {
								if (seed[j = matchIndexes[i]]) {
									seed[j] = !(matches[j] = seed[j])
								}
							}
						})
					})
				}

				function testContext(context) {
					return context && typeof context.getElementsByTagName !== "undefined" && context
				}
				support = Sizzle.support = {};
				isXML = Sizzle.isXML = function (elem) {
					var namespace = elem && elem.namespaceURI,
						docElem = elem && (elem.ownerDocument || elem).documentElement;
					return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML")
				};
				setDocument = Sizzle.setDocument = function (node) {
					var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
					if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
						return document
					}
					document = doc;
					docElem = document.documentElement;
					documentIsHTML = !isXML(document);
					if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
						if (subWindow.addEventListener) {
							subWindow.addEventListener("unload", unloadHandler, false)
						} else if (subWindow.attachEvent) {
							subWindow.attachEvent("onunload", unloadHandler)
						}
					}
					support.scope = assert(function (el) {
						docElem.appendChild(el).appendChild(document.createElement("div"));
						return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length
					});
					support.attributes = assert(function (el) {
						el.className = "i";
						return !el.getAttribute("className")
					});
					support.getElementsByTagName = assert(function (el) {
						el.appendChild(document.createComment(""));
						return !el.getElementsByTagName("*").length
					});
					support.getElementsByClassName = rnative.test(document.getElementsByClassName);
					support.getById = assert(function (el) {
						docElem.appendChild(el).id = expando;
						return !document.getElementsByName || !document.getElementsByName(expando).length
					});
					if (support.getById) {
						Expr.filter["ID"] = function (id) {
							var attrId = id.replace(runescape, funescape);
							return function (elem) {
								return elem.getAttribute("id") === attrId
							}
						};
						Expr.find["ID"] = function (id, context) {
							if (typeof context.getElementById !== "undefined" && documentIsHTML) {
								var elem = context.getElementById(id);
								return elem ? [elem] : []
							}
						}
					} else {
						Expr.filter["ID"] = function (id) {
							var attrId = id.replace(runescape, funescape);
							return function (elem) {
								var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
								return node && node.value === attrId
							}
						};
						Expr.find["ID"] = function (id, context) {
							if (typeof context.getElementById !== "undefined" && documentIsHTML) {
								var node, i, elems, elem = context.getElementById(id);
								if (elem) {
									node = elem.getAttributeNode("id");
									if (node && node.value === id) {
										return [elem]
									}
									elems = context.getElementsByName(id);
									i = 0;
									while (elem = elems[i++]) {
										node = elem.getAttributeNode("id");
										if (node && node.value === id) {
											return [elem]
										}
									}
								}
								return []
							}
						}
					}
					Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
						if (typeof context.getElementsByTagName !== "undefined") {
							return context.getElementsByTagName(tag)
						} else if (support.qsa) {
							return context.querySelectorAll(tag)
						}
					} : function (tag, context) {
						var elem, tmp = [],
							i = 0,
							results = context.getElementsByTagName(tag);
						if (tag === "*") {
							while (elem = results[i++]) {
								if (elem.nodeType === 1) {
									tmp.push(elem)
								}
							}
							return tmp
						}
						return results
					};
					Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
						if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
							return context.getElementsByClassName(className)
						}
					};
					rbuggyMatches = [];
					rbuggyQSA = [];
					if (support.qsa = rnative.test(document.querySelectorAll)) {
						assert(function (el) {
							var input;
							docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
							if (el.querySelectorAll("[msallowcapture^='']").length) {
								rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")")
							}
							if (!el.querySelectorAll("[selected]").length) {
								rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")")
							}
							if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
								rbuggyQSA.push("~=")
							}
							input = document.createElement("input");
							input.setAttribute("name", "");
							el.appendChild(input);
							if (!el.querySelectorAll("[name='']").length) {
								rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")")
							}
							if (!el.querySelectorAll(":checked").length) {
								rbuggyQSA.push(":checked")
							}
							if (!el.querySelectorAll("a#" + expando + "+*").length) {
								rbuggyQSA.push(".#.+[+~]")
							}
							el.querySelectorAll("\\\f");
							rbuggyQSA.push("[\\r\\n\\f]")
						});
						assert(function (el) {
							el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";
							var input = document.createElement("input");
							input.setAttribute("type", "hidden");
							el.appendChild(input).setAttribute("name", "D");
							if (el.querySelectorAll("[name=d]").length) {
								rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=")
							}
							if (el.querySelectorAll(":enabled").length !== 2) {
								rbuggyQSA.push(":enabled", ":disabled")
							}
							docElem.appendChild(el).disabled = true;
							if (el.querySelectorAll(":disabled").length !== 2) {
								rbuggyQSA.push(":enabled", ":disabled")
							}
							el.querySelectorAll("*,:x");
							rbuggyQSA.push(",.*:")
						})
					}
					if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
						assert(function (el) {
							support.disconnectedMatch = matches.call(el, "*");
							matches.call(el, "[s!='']:x");
							rbuggyMatches.push("!=", pseudos)
						})
					}
					rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
					rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
					hasCompare = rnative.test(docElem.compareDocumentPosition);
					contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
						var adown = a.nodeType === 9 ? a.documentElement : a,
							bup = b && b.parentNode;
						return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16))
					} : function (a, b) {
						if (b) {
							while (b = b.parentNode) {
								if (b === a) {
									return true
								}
							}
						}
						return false
					};
					sortOrder = hasCompare ? function (a, b) {
						if (a === b) {
							hasDuplicate = true;
							return 0
						}
						var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
						if (compare) {
							return compare
						}
						compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
						if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
							if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
								return -1
							}
							if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
								return 1
							}
							return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0
						}
						return compare & 4 ? -1 : 1
					} : function (a, b) {
						if (a === b) {
							hasDuplicate = true;
							return 0
						}
						var cur, i = 0,
							aup = a.parentNode,
							bup = b.parentNode,
							ap = [a],
							bp = [b];
						if (!aup || !bup) {
							return a == document ? -1 : b == document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0
						} else if (aup === bup) {
							return siblingCheck(a, b)
						}
						cur = a;
						while (cur = cur.parentNode) {
							ap.unshift(cur)
						}
						cur = b;
						while (cur = cur.parentNode) {
							bp.unshift(cur)
						}
						while (ap[i] === bp[i]) {
							i++
						}
						return i ? siblingCheck(ap[i], bp[i]) : ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 : 0
					};
					return document
				};
				Sizzle.matches = function (expr, elements) {
					return Sizzle(expr, null, null, elements)
				};
				Sizzle.matchesSelector = function (elem, expr) {
					setDocument(elem);
					if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
						try {
							var ret = matches.call(elem, expr);
							if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
								return ret
							}
						} catch (e) {
							nonnativeSelectorCache(expr, true)
						}
					}
					return Sizzle(expr, document, null, [elem]).length > 0
				};
				Sizzle.contains = function (context, elem) {
					if ((context.ownerDocument || context) != document) {
						setDocument(context)
					}
					return contains(context, elem)
				};
				Sizzle.attr = function (elem, name) {
					if ((elem.ownerDocument || elem) != document) {
						setDocument(elem)
					}
					var fn = Expr.attrHandle[name.toLowerCase()],
						val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
					return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
				};
				Sizzle.escape = function (sel) {
					return (sel + "").replace(rcssescape, fcssescape)
				};
				Sizzle.error = function (msg) {
					throw new Error("Syntax error, unrecognized expression: " + msg)
				};
				Sizzle.uniqueSort = function (results) {
					var elem, duplicates = [],
						j = 0,
						i = 0;
					hasDuplicate = !support.detectDuplicates;
					sortInput = !support.sortStable && results.slice(0);
					results.sort(sortOrder);
					if (hasDuplicate) {
						while (elem = results[i++]) {
							if (elem === results[i]) {
								j = duplicates.push(i)
							}
						}
						while (j--) {
							results.splice(duplicates[j], 1)
						}
					}
					sortInput = null;
					return results
				};
				getText = Sizzle.getText = function (elem) {
					var node, ret = "",
						i = 0,
						nodeType = elem.nodeType;
					if (!nodeType) {
						while (node = elem[i++]) {
							ret += getText(node)
						}
					} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
						if (typeof elem.textContent === "string") {
							return elem.textContent
						} else {
							for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
								ret += getText(elem)
							}
						}
					} else if (nodeType === 3 || nodeType === 4) {
						return elem.nodeValue
					}
					return ret
				};
				Expr = Sizzle.selectors = {
					cacheLength: 50,
					createPseudo: markFunction,
					match: matchExpr,
					attrHandle: {},
					find: {},
					relative: {
						">": {
							dir: "parentNode",
							first: true
						},
						" ": {
							dir: "parentNode"
						},
						"+": {
							dir: "previousSibling",
							first: true
						},
						"~": {
							dir: "previousSibling"
						}
					},
					preFilter: {
						ATTR: function (match) {
							match[1] = match[1].replace(runescape, funescape);
							match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
							if (match[2] === "~=") {
								match[3] = " " + match[3] + " "
							}
							return match.slice(0, 4)
						},
						CHILD: function (match) {
							match[1] = match[1].toLowerCase();
							if (match[1].slice(0, 3) === "nth") {
								if (!match[3]) {
									Sizzle.error(match[0])
								}
								match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
								match[5] = +(match[7] + match[8] || match[3] === "odd")
							} else if (match[3]) {
								Sizzle.error(match[0])
							}
							return match
						},
						PSEUDO: function (match) {
							var excess, unquoted = !match[6] && match[2];
							if (matchExpr["CHILD"].test(match[0])) {
								return null
							}
							if (match[3]) {
								match[2] = match[4] || match[5] || ""
							} else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
								match[0] = match[0].slice(0, excess);
								match[2] = unquoted.slice(0, excess)
							}
							return match.slice(0, 3)
						}
					},
					filter: {
						TAG: function (nodeNameSelector) {
							var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
							return nodeNameSelector === "*" ? function () {
								return true
							} : function (elem) {
								return elem.nodeName && elem.nodeName.toLowerCase() === nodeName
							}
						},
						CLASS: function (className) {
							var pattern = classCache[className + " "];
							return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
								return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "")
							})
						},
						ATTR: function (name, operator, check) {
							return function (elem) {
								var result = Sizzle.attr(elem, name);
								if (result == null) {
									return operator === "!="
								}
								if (!operator) {
									return true
								}
								result += "";
								return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false
							}
						},
						CHILD: function (type, what, _argument, first, last) {
							var simple = type.slice(0, 3) !== "nth",
								forward = type.slice(-4) !== "last",
								ofType = what === "of-type";
							return first === 1 && last === 0 ? function (elem) {
								return !!elem.parentNode
							} : function (elem, _context, xml) {
								var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling",
									parent = elem.parentNode,
									name = ofType && elem.nodeName.toLowerCase(),
									useCache = !xml && !ofType,
									diff = false;
								if (parent) {
									if (simple) {
										while (dir) {
											node = elem;
											while (node = node[dir]) {
												if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
													return false
												}
											}
											start = dir = type === "only" && !start && "nextSibling"
										}
										return true
									}
									start = [forward ? parent.firstChild : parent.lastChild];
									if (forward && useCache) {
										node = parent;
										outerCache = node[expando] || (node[expando] = {});
										uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
										cache = uniqueCache[type] || [];
										nodeIndex = cache[0] === dirruns && cache[1];
										diff = nodeIndex && cache[2];
										node = nodeIndex && parent.childNodes[nodeIndex];
										while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
											if (node.nodeType === 1 && ++diff && node === elem) {
												uniqueCache[type] = [dirruns, nodeIndex, diff];
												break
											}
										}
									} else {
										if (useCache) {
											node = elem;
											outerCache = node[expando] || (node[expando] = {});
											uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
											cache = uniqueCache[type] || [];
											nodeIndex = cache[0] === dirruns && cache[1];
											diff = nodeIndex
										}
										if (diff === false) {
											while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
												if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
													if (useCache) {
														outerCache = node[expando] || (node[expando] = {});
														uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
														uniqueCache[type] = [dirruns, diff]
													}
													if (node === elem) {
														break
													}
												}
											}
										}
									}
									diff -= last;
									return diff === first || diff % first === 0 && diff / first >= 0
								}
							}
						},
						PSEUDO: function (pseudo, argument) {
							var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
							if (fn[expando]) {
								return fn(argument)
							}
							if (fn.length > 1) {
								args = [pseudo, pseudo, "", argument];
								return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
									var idx, matched = fn(seed, argument),
										i = matched.length;
									while (i--) {
										idx = indexOf(seed, matched[i]);
										seed[idx] = !(matches[idx] = matched[i])
									}
								}) : function (elem) {
									return fn(elem, 0, args)
								}
							}
							return fn
						}
					},
					pseudos: {
						not: markFunction(function (selector) {
							var input = [],
								results = [],
								matcher = compile(selector.replace(rtrim, "$1"));
							return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {
								var elem, unmatched = matcher(seed, null, xml, []),
									i = seed.length;
								while (i--) {
									if (elem = unmatched[i]) {
										seed[i] = !(matches[i] = elem)
									}
								}
							}) : function (elem, _context, xml) {
								input[0] = elem;
								matcher(input, null, xml, results);
								input[0] = null;
								return !results.pop()
							}
						}),
						has: markFunction(function (selector) {
							return function (elem) {
								return Sizzle(selector, elem).length > 0
							}
						}),
						contains: markFunction(function (text) {
							text = text.replace(runescape, funescape);
							return function (elem) {
								return (elem.textContent || getText(elem)).indexOf(text) > -1
							}
						}),
						lang: markFunction(function (lang) {
							if (!ridentifier.test(lang || "")) {
								Sizzle.error("unsupported lang: " + lang)
							}
							lang = lang.replace(runescape, funescape).toLowerCase();
							return function (elem) {
								var elemLang;
								do {
									if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
										elemLang = elemLang.toLowerCase();
										return elemLang === lang || elemLang.indexOf(lang + "-") === 0
									}
								} while ((elem = elem.parentNode) && elem.nodeType === 1);
								return false
							}
						}),
						target: function (elem) {
							var hash = window.location && window.location.hash;
							return hash && hash.slice(1) === elem.id
						},
						root: function (elem) {
							return elem === docElem
						},
						focus: function (elem) {
							return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex)
						},
						enabled: createDisabledPseudo(false),
						disabled: createDisabledPseudo(true),
						checked: function (elem) {
							var nodeName = elem.nodeName.toLowerCase();
							return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected
						},
						selected: function (elem) {
							if (elem.parentNode) {
								elem.parentNode.selectedIndex
							}
							return elem.selected === true
						},
						empty: function (elem) {
							for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
								if (elem.nodeType < 6) {
									return false
								}
							}
							return true
						},
						parent: function (elem) {
							return !Expr.pseudos["empty"](elem)
						},
						header: function (elem) {
							return rheader.test(elem.nodeName)
						},
						input: function (elem) {
							return rinputs.test(elem.nodeName)
						},
						button: function (elem) {
							var name = elem.nodeName.toLowerCase();
							return name === "input" && elem.type === "button" || name === "button"
						},
						text: function (elem) {
							var attr;
							return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text")
						},
						first: createPositionalPseudo(function () {
							return [0]
						}),
						last: createPositionalPseudo(function (_matchIndexes, length) {
							return [length - 1]
						}),
						eq: createPositionalPseudo(function (_matchIndexes, length, argument) {
							return [argument < 0 ? argument + length : argument]
						}),
						even: createPositionalPseudo(function (matchIndexes, length) {
							var i = 0;
							for (; i < length; i += 2) {
								matchIndexes.push(i)
							}
							return matchIndexes
						}),
						odd: createPositionalPseudo(function (matchIndexes, length) {
							var i = 1;
							for (; i < length; i += 2) {
								matchIndexes.push(i)
							}
							return matchIndexes
						}),
						lt: createPositionalPseudo(function (matchIndexes, length, argument) {
							var i = argument < 0 ? argument + length : argument > length ? length : argument;
							for (; --i >= 0;) {
								matchIndexes.push(i)
							}
							return matchIndexes
						}),
						gt: createPositionalPseudo(function (matchIndexes, length, argument) {
							var i = argument < 0 ? argument + length : argument;
							for (; ++i < length;) {
								matchIndexes.push(i)
							}
							return matchIndexes
						})
					}
				};
				Expr.pseudos["nth"] = Expr.pseudos["eq"];
				for (i in {
						radio: true,
						checkbox: true,
						file: true,
						password: true,
						image: true
					}) {
					Expr.pseudos[i] = createInputPseudo(i)
				}
				for (i in {
						submit: true,
						reset: true
					}) {
					Expr.pseudos[i] = createButtonPseudo(i)
				}

				function setFilters() {}
				setFilters.prototype = Expr.filters = Expr.pseudos;
				Expr.setFilters = new setFilters;
				tokenize = Sizzle.tokenize = function (selector, parseOnly) {
					var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
					if (cached) {
						return parseOnly ? 0 : cached.slice(0)
					}
					soFar = selector;
					groups = [];
					preFilters = Expr.preFilter;
					while (soFar) {
						if (!matched || (match = rcomma.exec(soFar))) {
							if (match) {
								soFar = soFar.slice(match[0].length) || soFar
							}
							groups.push(tokens = [])
						}
						matched = false;
						if (match = rcombinators.exec(soFar)) {
							matched = match.shift();
							tokens.push({
								value: matched,
								type: match[0].replace(rtrim, " ")
							});
							soFar = soFar.slice(matched.length)
						}
						for (type in Expr.filter) {
							if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
								matched = match.shift();
								tokens.push({
									value: matched,
									type: type,
									matches: match
								});
								soFar = soFar.slice(matched.length)
							}
						}
						if (!matched) {
							break
						}
					}
					return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0)
				};

				function toSelector(tokens) {
					var i = 0,
						len = tokens.length,
						selector = "";
					for (; i < len; i++) {
						selector += tokens[i].value
					}
					return selector
				}

				function addCombinator(matcher, combinator, base) {
					var dir = combinator.dir,
						skip = combinator.next,
						key = skip || dir,
						checkNonElements = base && key === "parentNode",
						doneName = done++;
					return combinator.first ? function (elem, context, xml) {
						while (elem = elem[dir]) {
							if (elem.nodeType === 1 || checkNonElements) {
								return matcher(elem, context, xml)
							}
						}
						return false
					} : function (elem, context, xml) {
						var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
						if (xml) {
							while (elem = elem[dir]) {
								if (elem.nodeType === 1 || checkNonElements) {
									if (matcher(elem, context, xml)) {
										return true
									}
								}
							}
						} else {
							while (elem = elem[dir]) {
								if (elem.nodeType === 1 || checkNonElements) {
									outerCache = elem[expando] || (elem[expando] = {});
									uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
									if (skip && skip === elem.nodeName.toLowerCase()) {
										elem = elem[dir] || elem
									} else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
										return newCache[2] = oldCache[2]
									} else {
										uniqueCache[key] = newCache;
										if (newCache[2] = matcher(elem, context, xml)) {
											return true
										}
									}
								}
							}
						}
						return false
					}
				}

				function elementMatcher(matchers) {
					return matchers.length > 1 ? function (elem, context, xml) {
						var i = matchers.length;
						while (i--) {
							if (!matchers[i](elem, context, xml)) {
								return false
							}
						}
						return true
					} : matchers[0]
				}

				function multipleContexts(selector, contexts, results) {
					var i = 0,
						len = contexts.length;
					for (; i < len; i++) {
						Sizzle(selector, contexts[i], results)
					}
					return results
				}

				function condense(unmatched, map, filter, context, xml) {
					var elem, newUnmatched = [],
						i = 0,
						len = unmatched.length,
						mapped = map != null;
					for (; i < len; i++) {
						if (elem = unmatched[i]) {
							if (!filter || filter(elem, context, xml)) {
								newUnmatched.push(elem);
								if (mapped) {
									map.push(i)
								}
							}
						}
					}
					return newUnmatched
				}

				function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
					if (postFilter && !postFilter[expando]) {
						postFilter = setMatcher(postFilter)
					}
					if (postFinder && !postFinder[expando]) {
						postFinder = setMatcher(postFinder, postSelector)
					}
					return markFunction(function (seed, results, context, xml) {
						var temp, i, elem, preMap = [],
							postMap = [],
							preexisting = results.length,
							elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
							matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
							matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
						if (matcher) {
							matcher(matcherIn, matcherOut, context, xml)
						}
						if (postFilter) {
							temp = condense(matcherOut, postMap);
							postFilter(temp, [], context, xml);
							i = temp.length;
							while (i--) {
								if (elem = temp[i]) {
									matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem)
								}
							}
						}
						if (seed) {
							if (postFinder || preFilter) {
								if (postFinder) {
									temp = [];
									i = matcherOut.length;
									while (i--) {
										if (elem = matcherOut[i]) {
											temp.push(matcherIn[i] = elem)
										}
									}
									postFinder(null, matcherOut = [], temp, xml)
								}
								i = matcherOut.length;
								while (i--) {
									if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
										seed[temp] = !(results[temp] = elem)
									}
								}
							}
						} else {
							matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
							if (postFinder) {
								postFinder(null, results, matcherOut, xml)
							} else {
								push.apply(results, matcherOut)
							}
						}
					})
				}

				function matcherFromTokens(tokens) {
					var checkContext, matcher, j, len = tokens.length,
						leadingRelative = Expr.relative[tokens[0].type],
						implicitRelative = leadingRelative || Expr.relative[" "],
						i = leadingRelative ? 1 : 0,
						matchContext = addCombinator(function (elem) {
							return elem === checkContext
						}, implicitRelative, true),
						matchAnyContext = addCombinator(function (elem) {
							return indexOf(checkContext, elem) > -1
						}, implicitRelative, true),
						matchers = [function (elem, context, xml) {
							var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
							checkContext = null;
							return ret
						}];
					for (; i < len; i++) {
						if (matcher = Expr.relative[tokens[i].type]) {
							matchers = [addCombinator(elementMatcher(matchers), matcher)]
						} else {
							matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
							if (matcher[expando]) {
								j = ++i;
								for (; j < len; j++) {
									if (Expr.relative[tokens[j].type]) {
										break
									}
								}
								return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
									value: tokens[i - 2].type === " " ? "*" : ""
								})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens))
							}
							matchers.push(matcher)
						}
					}
					return elementMatcher(matchers)
				}

				function matcherFromGroupMatchers(elementMatchers, setMatchers) {
					var bySet = setMatchers.length > 0,
						byElement = elementMatchers.length > 0,
						superMatcher = function (seed, context, xml, results, outermost) {
							var elem, j, matcher, matchedCount = 0,
								i = "0",
								unmatched = seed && [],
								setMatched = [],
								contextBackup = outermostContext,
								elems = seed || byElement && Expr.find["TAG"]("*", outermost),
								dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || .1,
								len = elems.length;
							if (outermost) {
								outermostContext = context == document || context || outermost
							}
							for (; i !== len && (elem = elems[i]) != null; i++) {
								if (byElement && elem) {
									j = 0;
									if (!context && elem.ownerDocument != document) {
										setDocument(elem);
										xml = !documentIsHTML
									}
									while (matcher = elementMatchers[j++]) {
										if (matcher(elem, context || document, xml)) {
											results.push(elem);
											break
										}
									}
									if (outermost) {
										dirruns = dirrunsUnique
									}
								}
								if (bySet) {
									if (elem = !matcher && elem) {
										matchedCount--
									}
									if (seed) {
										unmatched.push(elem)
									}
								}
							}
							matchedCount += i;
							if (bySet && i !== matchedCount) {
								j = 0;
								while (matcher = setMatchers[j++]) {
									matcher(unmatched, setMatched, context, xml)
								}
								if (seed) {
									if (matchedCount > 0) {
										while (i--) {
											if (!(unmatched[i] || setMatched[i])) {
												setMatched[i] = pop.call(results)
											}
										}
									}
									setMatched = condense(setMatched)
								}
								push.apply(results, setMatched);
								if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
									Sizzle.uniqueSort(results)
								}
							}
							if (outermost) {
								dirruns = dirrunsUnique;
								outermostContext = contextBackup
							}
							return unmatched
						};
					return bySet ? markFunction(superMatcher) : superMatcher
				}
				compile = Sizzle.compile = function (selector, match) {
					var i, setMatchers = [],
						elementMatchers = [],
						cached = compilerCache[selector + " "];
					if (!cached) {
						if (!match) {
							match = tokenize(selector)
						}
						i = match.length;
						while (i--) {
							cached = matcherFromTokens(match[i]);
							if (cached[expando]) {
								setMatchers.push(cached)
							} else {
								elementMatchers.push(cached)
							}
						}
						cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
						cached.selector = selector
					}
					return cached
				};
				select = Sizzle.select = function (selector, context, results, seed) {
					var i, tokens, token, type, find, compiled = typeof selector === "function" && selector,
						match = !seed && tokenize(selector = compiled.selector || selector);
					results = results || [];
					if (match.length === 1) {
						tokens = match[0] = match[0].slice(0);
						if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
							context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
							if (!context) {
								return results
							} else if (compiled) {
								context = context.parentNode
							}
							selector = selector.slice(tokens.shift().value.length)
						}
						i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
						while (i--) {
							token = tokens[i];
							if (Expr.relative[type = token.type]) {
								break
							}
							if (find = Expr.find[type]) {
								if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
									tokens.splice(i, 1);
									selector = seed.length && toSelector(tokens);
									if (!selector) {
										push.apply(results, seed);
										return results
									}
									break
								}
							}
						}
					}(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
					return results
				};
				support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
				support.detectDuplicates = !!hasDuplicate;
				setDocument();
				support.sortDetached = assert(function (el) {
					return el.compareDocumentPosition(document.createElement("fieldset")) & 1
				});
				if (!assert(function (el) {
						el.innerHTML = "<a href='#'></a>";
						return el.firstChild.getAttribute("href") === "#"
					})) {
					addHandle("type|href|height|width", function (elem, name, isXML) {
						if (!isXML) {
							return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2)
						}
					})
				}
				if (!support.attributes || !assert(function (el) {
						el.innerHTML = "<input/>";
						el.firstChild.setAttribute("value", "");
						return el.firstChild.getAttribute("value") === ""
					})) {
					addHandle("value", function (elem, _name, isXML) {
						if (!isXML && elem.nodeName.toLowerCase() === "input") {
							return elem.defaultValue
						}
					})
				}
				if (!assert(function (el) {
						return el.getAttribute("disabled") == null
					})) {
					addHandle(booleans, function (elem, name, isXML) {
						var val;
						if (!isXML) {
							return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
						}
					})
				}
				return Sizzle
			}(window);
			jQuery.find = Sizzle;
			jQuery.expr = Sizzle.selectors;
			jQuery.expr[":"] = jQuery.expr.pseudos;
			jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
			jQuery.text = Sizzle.getText;
			jQuery.isXMLDoc = Sizzle.isXML;
			jQuery.contains = Sizzle.contains;
			jQuery.escapeSelector = Sizzle.escape;
			var dir = function (elem, dir, until) {
				var matched = [],
					truncate = until !== undefined;
				while ((elem = elem[dir]) && elem.nodeType !== 9) {
					if (elem.nodeType === 1) {
						if (truncate && jQuery(elem).is(until)) {
							break
						}
						matched.push(elem)
					}
				}
				return matched
			};
			var siblings = function (n, elem) {
				var matched = [];
				for (; n; n = n.nextSibling) {
					if (n.nodeType === 1 && n !== elem) {
						matched.push(n)
					}
				}
				return matched
			};
			var rneedsContext = jQuery.expr.match.needsContext;

			function nodeName(elem, name) {
				return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()
			}
			var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

			function winnow(elements, qualifier, not) {
				if (isFunction(qualifier)) {
					return jQuery.grep(elements, function (elem, i) {
						return !!qualifier.call(elem, i, elem) !== not
					})
				}
				if (qualifier.nodeType) {
					return jQuery.grep(elements, function (elem) {
						return elem === qualifier !== not
					})
				}
				if (typeof qualifier !== "string") {
					return jQuery.grep(elements, function (elem) {
						return indexOf.call(qualifier, elem) > -1 !== not
					})
				}
				return jQuery.filter(qualifier, elements, not)
			}
			jQuery.filter = function (expr, elems, not) {
				var elem = elems[0];
				if (not) {
					expr = ":not(" + expr + ")"
				}
				if (elems.length === 1 && elem.nodeType === 1) {
					return jQuery.find.matchesSelector(elem, expr) ? [elem] : []
				}
				return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
					return elem.nodeType === 1
				}))
			};
			jQuery.fn.extend({
				find: function (selector) {
					var i, ret, len = this.length,
						self = this;
					if (typeof selector !== "string") {
						return this.pushStack(jQuery(selector).filter(function () {
							for (i = 0; i < len; i++) {
								if (jQuery.contains(self[i], this)) {
									return true
								}
							}
						}))
					}
					ret = this.pushStack([]);
					for (i = 0; i < len; i++) {
						jQuery.find(selector, self[i], ret)
					}
					return len > 1 ? jQuery.uniqueSort(ret) : ret
				},
				filter: function (selector) {
					return this.pushStack(winnow(this, selector || [], false))
				},
				not: function (selector) {
					return this.pushStack(winnow(this, selector || [], true))
				},
				is: function (selector) {
					return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length
				}
			});
			var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
				init = jQuery.fn.init = function (selector, context, root) {
					var match, elem;
					if (!selector) {
						return this
					}
					root = root || rootjQuery;
					if (typeof selector === "string") {
						if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
							match = [null, selector, null]
						} else {
							match = rquickExpr.exec(selector)
						}
						if (match && (match[1] || !context)) {
							if (match[1]) {
								context = context instanceof jQuery ? context[0] : context;
								jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
								if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
									for (match in context) {
										if (isFunction(this[match])) {
											this[match](context[match])
										} else {
											this.attr(match, context[match])
										}
									}
								}
								return this
							} else {
								elem = document.getElementById(match[2]);
								if (elem) {
									this[0] = elem;
									this.length = 1
								}
								return this
							}
						} else if (!context || context.jquery) {
							return (context || root).find(selector)
						} else {
							return this.constructor(context).find(selector)
						}
					} else if (selector.nodeType) {
						this[0] = selector;
						this.length = 1;
						return this
					} else if (isFunction(selector)) {
						return root.ready !== undefined ? root.ready(selector) : selector(jQuery)
					}
					return jQuery.makeArray(selector, this)
				};
			init.prototype = jQuery.fn;
			rootjQuery = jQuery(document);
			var rparentsprev = /^(?:parents|prev(?:Until|All))/,
				guaranteedUnique = {
					children: true,
					contents: true,
					next: true,
					prev: true
				};
			jQuery.fn.extend({
				has: function (target) {
					var targets = jQuery(target, this),
						l = targets.length;
					return this.filter(function () {
						var i = 0;
						for (; i < l; i++) {
							if (jQuery.contains(this, targets[i])) {
								return true
							}
						}
					})
				},
				closest: function (selectors, context) {
					var cur, i = 0,
						l = this.length,
						matched = [],
						targets = typeof selectors !== "string" && jQuery(selectors);
					if (!rneedsContext.test(selectors)) {
						for (; i < l; i++) {
							for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
								if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
									matched.push(cur);
									break
								}
							}
						}
					}
					return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched)
				},
				index: function (elem) {
					if (!elem) {
						return this[0] && this[0].parentNode ? this.first().prevAll().length : -1
					}
					if (typeof elem === "string") {
						return indexOf.call(jQuery(elem), this[0])
					}
					return indexOf.call(this, elem.jquery ? elem[0] : elem)
				},
				add: function (selector, context) {
					return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))))
				},
				addBack: function (selector) {
					return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector))
				}
			});

			function sibling(cur, dir) {
				while ((cur = cur[dir]) && cur.nodeType !== 1) {}
				return cur
			}
			jQuery.each({
				parent: function (elem) {
					var parent = elem.parentNode;
					return parent && parent.nodeType !== 11 ? parent : null
				},
				parents: function (elem) {
					return dir(elem, "parentNode")
				},
				parentsUntil: function (elem, _i, until) {
					return dir(elem, "parentNode", until)
				},
				next: function (elem) {
					return sibling(elem, "nextSibling")
				},
				prev: function (elem) {
					return sibling(elem, "previousSibling")
				},
				nextAll: function (elem) {
					return dir(elem, "nextSibling")
				},
				prevAll: function (elem) {
					return dir(elem, "previousSibling")
				},
				nextUntil: function (elem, _i, until) {
					return dir(elem, "nextSibling", until)
				},
				prevUntil: function (elem, _i, until) {
					return dir(elem, "previousSibling", until)
				},
				siblings: function (elem) {
					return siblings((elem.parentNode || {}).firstChild, elem)
				},
				children: function (elem) {
					return siblings(elem.firstChild)
				},
				contents: function (elem) {
					if (elem.contentDocument != null && getProto(elem.contentDocument)) {
						return elem.contentDocument
					}
					if (nodeName(elem, "template")) {
						elem = elem.content || elem
					}
					return jQuery.merge([], elem.childNodes)
				}
			}, function (name, fn) {
				jQuery.fn[name] = function (until, selector) {
					var matched = jQuery.map(this, fn, until);
					if (name.slice(-5) !== "Until") {
						selector = until
					}
					if (selector && typeof selector === "string") {
						matched = jQuery.filter(selector, matched)
					}
					if (this.length > 1) {
						if (!guaranteedUnique[name]) {
							jQuery.uniqueSort(matched)
						}
						if (rparentsprev.test(name)) {
							matched.reverse()
						}
					}
					return this.pushStack(matched)
				}
			});
			var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;

			function createOptions(options) {
				var object = {};
				jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
					object[flag] = true
				});
				return object
			}
			jQuery.Callbacks = function (options) {
				options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
				var firing, memory, fired, locked, list = [],
					queue = [],
					firingIndex = -1,
					fire = function () {
						locked = locked || options.once;
						fired = firing = true;
						for (; queue.length; firingIndex = -1) {
							memory = queue.shift();
							while (++firingIndex < list.length) {
								if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
									firingIndex = list.length;
									memory = false
								}
							}
						}
						if (!options.memory) {
							memory = false
						}
						firing = false;
						if (locked) {
							if (memory) {
								list = []
							} else {
								list = ""
							}
						}
					},
					self = {
						add: function () {
							if (list) {
								if (memory && !firing) {
									firingIndex = list.length - 1;
									queue.push(memory)
								}(function add(args) {
									jQuery.each(args, function (_, arg) {
										if (isFunction(arg)) {
											if (!options.unique || !self.has(arg)) {
												list.push(arg)
											}
										} else if (arg && arg.length && toType(arg) !== "string") {
											add(arg)
										}
									})
								})(arguments);
								if (memory && !firing) {
									fire()
								}
							}
							return this
						},
						remove: function () {
							jQuery.each(arguments, function (_, arg) {
								var index;
								while ((index = jQuery.inArray(arg, list, index)) > -1) {
									list.splice(index, 1);
									if (index <= firingIndex) {
										firingIndex--
									}
								}
							});
							return this
						},
						has: function (fn) {
							return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0
						},
						empty: function () {
							if (list) {
								list = []
							}
							return this
						},
						disable: function () {
							locked = queue = [];
							list = memory = "";
							return this
						},
						disabled: function () {
							return !list
						},
						lock: function () {
							locked = queue = [];
							if (!memory && !firing) {
								list = memory = ""
							}
							return this
						},
						locked: function () {
							return !!locked
						},
						fireWith: function (context, args) {
							if (!locked) {
								args = args || [];
								args = [context, args.slice ? args.slice() : args];
								queue.push(args);
								if (!firing) {
									fire()
								}
							}
							return this
						},
						fire: function () {
							self.fireWith(this, arguments);
							return this
						},
						fired: function () {
							return !!fired
						}
					};
				return self
			};

			function Identity(v) {
				return v
			}

			function Thrower(ex) {
				throw ex
			}

			function adoptValue(value, resolve, reject, noValue) {
				var method;
				try {
					if (value && isFunction(method = value.promise)) {
						method.call(value).done(resolve).fail(reject)
					} else if (value && isFunction(method = value.then)) {
						method.call(value, resolve, reject)
					} else {
						resolve.apply(undefined, [value].slice(noValue))
					}
				} catch (value) {
					reject.apply(undefined, [value])
				}
			}
			jQuery.extend({
				Deferred: function (func) {
					var tuples = [
							["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2],
							["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"],
							["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]
						],
						state = "pending",
						promise = {
							state: function () {
								return state
							},
							always: function () {
								deferred.done(arguments).fail(arguments);
								return this
							},
							catch: function (fn) {
								return promise.then(null, fn)
							},
							pipe: function () {
								var fns = arguments;
								return jQuery.Deferred(function (newDefer) {
									jQuery.each(tuples, function (_i, tuple) {
										var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
										deferred[tuple[1]](function () {
											var returned = fn && fn.apply(this, arguments);
											if (returned && isFunction(returned.promise)) {
												returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject)
											} else {
												newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments)
											}
										})
									});
									fns = null
								}).promise()
							},
							then: function (onFulfilled, onRejected, onProgress) {
								var maxDepth = 0;

								function resolve(depth, deferred, handler, special) {
									return function () {
										var that = this,
											args = arguments,
											mightThrow = function () {
												var returned, then;
												if (depth < maxDepth) {
													return
												}
												returned = handler.apply(that, args);
												if (returned === deferred.promise()) {
													throw new TypeError("Thenable self-resolution")
												}
												then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
												if (isFunction(then)) {
													if (special) {
														then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special))
													} else {
														maxDepth++;
														then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith))
													}
												} else {
													if (handler !== Identity) {
														that = undefined;
														args = [returned]
													}(special || deferred.resolveWith)(that, args)
												}
											},
											process = special ? mightThrow : function () {
												try {
													mightThrow()
												} catch (e) {
													if (jQuery.Deferred.exceptionHook) {
														jQuery.Deferred.exceptionHook(e, process.stackTrace)
													}
													if (depth + 1 >= maxDepth) {
														if (handler !== Thrower) {
															that = undefined;
															args = [e]
														}
														deferred.rejectWith(that, args)
													}
												}
											};
										if (depth) {
											process()
										} else {
											if (jQuery.Deferred.getStackHook) {
												process.stackTrace = jQuery.Deferred.getStackHook()
											}
											window.setTimeout(process)
										}
									}
								}
								return jQuery.Deferred(function (newDefer) {
									tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
									tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));
									tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower))
								}).promise()
							},
							promise: function (obj) {
								return obj != null ? jQuery.extend(obj, promise) : promise
							}
						},
						deferred = {};
					jQuery.each(tuples, function (i, tuple) {
						var list = tuple[2],
							stateString = tuple[5];
						promise[tuple[1]] = list.add;
						if (stateString) {
							list.add(function () {
								state = stateString
							}, tuples[3 - i][2].disable, tuples[3 - i][3].disable, tuples[0][2].lock, tuples[0][3].lock)
						}
						list.add(tuple[3].fire);
						deferred[tuple[0]] = function () {
							deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
							return this
						};
						deferred[tuple[0] + "With"] = list.fireWith
					});
					promise.promise(deferred);
					if (func) {
						func.call(deferred, deferred)
					}
					return deferred
				},
				when: function (singleValue) {
					var remaining = arguments.length,
						i = remaining,
						resolveContexts = Array(i),
						resolveValues = slice.call(arguments),
						primary = jQuery.Deferred(),
						updateFunc = function (i) {
							return function (value) {
								resolveContexts[i] = this;
								resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
								if (!--remaining) {
									primary.resolveWith(resolveContexts, resolveValues)
								}
							}
						};
					if (remaining <= 1) {
						adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining);
						if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
							return primary.then()
						}
					}
					while (i--) {
						adoptValue(resolveValues[i], updateFunc(i), primary.reject)
					}
					return primary.promise()
				}
			});
			var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
			jQuery.Deferred.exceptionHook = function (error, stack) {
				if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
					window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack)
				}
			};
			jQuery.readyException = function (error) {
				window.setTimeout(function () {
					throw error
				})
			};
			var readyList = jQuery.Deferred();
			jQuery.fn.ready = function (fn) {
				readyList.then(fn).catch(function (error) {
					jQuery.readyException(error)
				});
				return this
			};
			jQuery.extend({
				isReady: false,
				readyWait: 1,
				ready: function (wait) {
					if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
						return
					}
					jQuery.isReady = true;
					if (wait !== true && --jQuery.readyWait > 0) {
						return
					}
					readyList.resolveWith(document, [jQuery])
				}
			});
			jQuery.ready.then = readyList.then;

			function completed() {
				document.removeEventListener("DOMContentLoaded", completed);
				window.removeEventListener("load", completed);
				jQuery.ready()
			}
			if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
				window.setTimeout(jQuery.ready)
			} else {
				document.addEventListener("DOMContentLoaded", completed);
				window.addEventListener("load", completed)
			}
			var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
				var i = 0,
					len = elems.length,
					bulk = key == null;
				if (toType(key) === "object") {
					chainable = true;
					for (i in key) {
						access(elems, fn, i, key[i], true, emptyGet, raw)
					}
				} else if (value !== undefined) {
					chainable = true;
					if (!isFunction(value)) {
						raw = true
					}
					if (bulk) {
						if (raw) {
							fn.call(elems, value);
							fn = null
						} else {
							bulk = fn;
							fn = function (elem, _key, value) {
								return bulk.call(jQuery(elem), value)
							}
						}
					}
					if (fn) {
						for (; i < len; i++) {
							fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)))
						}
					}
				}
				if (chainable) {
					return elems
				}
				if (bulk) {
					return fn.call(elems)
				}
				return len ? fn(elems[0], key) : emptyGet
			};
			var rmsPrefix = /^-ms-/,
				rdashAlpha = /-([a-z])/g;

			function fcamelCase(_all, letter) {
				return letter.toUpperCase()
			}

			function camelCase(string) {
				return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase)
			}
			var acceptData = function (owner) {
				return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType
			};

			function Data() {
				this.expando = jQuery.expando + Data.uid++
			}
			Data.uid = 1;
			Data.prototype = {
				cache: function (owner) {
					var value = owner[this.expando];
					if (!value) {
						value = {};
						if (acceptData(owner)) {
							if (owner.nodeType) {
								owner[this.expando] = value
							} else {
								Object.defineProperty(owner, this.expando, {
									value: value,
									configurable: true
								})
							}
						}
					}
					return value
				},
				set: function (owner, data, value) {
					var prop, cache = this.cache(owner);
					if (typeof data === "string") {
						cache[camelCase(data)] = value
					} else {
						for (prop in data) {
							cache[camelCase(prop)] = data[prop]
						}
					}
					return cache
				},
				get: function (owner, key) {
					return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)]
				},
				access: function (owner, key, value) {
					if (key === undefined || key && typeof key === "string" && value === undefined) {
						return this.get(owner, key)
					}
					this.set(owner, key, value);
					return value !== undefined ? value : key
				},
				remove: function (owner, key) {
					var i, cache = owner[this.expando];
					if (cache === undefined) {
						return
					}
					if (key !== undefined) {
						if (Array.isArray(key)) {
							key = key.map(camelCase)
						} else {
							key = camelCase(key);
							key = key in cache ? [key] : key.match(rnothtmlwhite) || []
						}
						i = key.length;
						while (i--) {
							delete cache[key[i]]
						}
					}
					if (key === undefined || jQuery.isEmptyObject(cache)) {
						if (owner.nodeType) {
							owner[this.expando] = undefined
						} else {
							delete owner[this.expando]
						}
					}
				},
				hasData: function (owner) {
					var cache = owner[this.expando];
					return cache !== undefined && !jQuery.isEmptyObject(cache)
				}
			};
			var dataPriv = new Data;
			var dataUser = new Data;
			var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
				rmultiDash = /[A-Z]/g;

			function getData(data) {
				if (data === "true") {
					return true
				}
				if (data === "false") {
					return false
				}
				if (data === "null") {
					return null
				}
				if (data === +data + "") {
					return +data
				}
				if (rbrace.test(data)) {
					return JSON.parse(data)
				}
				return data
			}

			function dataAttr(elem, key, data) {
				var name;
				if (data === undefined && elem.nodeType === 1) {
					name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
					data = elem.getAttribute(name);
					if (typeof data === "string") {
						try {
							data = getData(data)
						} catch (e) {}
						dataUser.set(elem, key, data)
					} else {
						data = undefined
					}
				}
				return data
			}
			jQuery.extend({
				hasData: function (elem) {
					return dataUser.hasData(elem) || dataPriv.hasData(elem)
				},
				data: function (elem, name, data) {
					return dataUser.access(elem, name, data)
				},
				removeData: function (elem, name) {
					dataUser.remove(elem, name)
				},
				_data: function (elem, name, data) {
					return dataPriv.access(elem, name, data)
				},
				_removeData: function (elem, name) {
					dataPriv.remove(elem, name)
				}
			});
			jQuery.fn.extend({
				data: function (key, value) {
					var i, name, data, elem = this[0],
						attrs = elem && elem.attributes;
					if (key === undefined) {
						if (this.length) {
							data = dataUser.get(elem);
							if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
								i = attrs.length;
								while (i--) {
									if (attrs[i]) {
										name = attrs[i].name;
										if (name.indexOf("data-") === 0) {
											name = camelCase(name.slice(5));
											dataAttr(elem, name, data[name])
										}
									}
								}
								dataPriv.set(elem, "hasDataAttrs", true)
							}
						}
						return data
					}
					if (typeof key === "object") {
						return this.each(function () {
							dataUser.set(this, key)
						})
					}
					return access(this, function (value) {
						var data;
						if (elem && value === undefined) {
							data = dataUser.get(elem, key);
							if (data !== undefined) {
								return data
							}
							data = dataAttr(elem, key);
							if (data !== undefined) {
								return data
							}
							return
						}
						this.each(function () {
							dataUser.set(this, key, value)
						})
					}, null, value, arguments.length > 1, null, true)
				},
				removeData: function (key) {
					return this.each(function () {
						dataUser.remove(this, key)
					})
				}
			});
			jQuery.extend({
				queue: function (elem, type, data) {
					var queue;
					if (elem) {
						type = (type || "fx") + "queue";
						queue = dataPriv.get(elem, type);
						if (data) {
							if (!queue || Array.isArray(data)) {
								queue = dataPriv.access(elem, type, jQuery.makeArray(data))
							} else {
								queue.push(data)
							}
						}
						return queue || []
					}
				},
				dequeue: function (elem, type) {
					type = type || "fx";
					var queue = jQuery.queue(elem, type),
						startLength = queue.length,
						fn = queue.shift(),
						hooks = jQuery._queueHooks(elem, type),
						next = function () {
							jQuery.dequeue(elem, type)
						};
					if (fn === "inprogress") {
						fn = queue.shift();
						startLength--
					}
					if (fn) {
						if (type === "fx") {
							queue.unshift("inprogress")
						}
						delete hooks.stop;
						fn.call(elem, next, hooks)
					}
					if (!startLength && hooks) {
						hooks.empty.fire()
					}
				},
				_queueHooks: function (elem, type) {
					var key = type + "queueHooks";
					return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
						empty: jQuery.Callbacks("once memory").add(function () {
							dataPriv.remove(elem, [type + "queue", key])
						})
					})
				}
			});
			jQuery.fn.extend({
				queue: function (type, data) {
					var setter = 2;
					if (typeof type !== "string") {
						data = type;
						type = "fx";
						setter--
					}
					if (arguments.length < setter) {
						return jQuery.queue(this[0], type)
					}
					return data === undefined ? this : this.each(function () {
						var queue = jQuery.queue(this, type, data);
						jQuery._queueHooks(this, type);
						if (type === "fx" && queue[0] !== "inprogress") {
							jQuery.dequeue(this, type)
						}
					})
				},
				dequeue: function (type) {
					return this.each(function () {
						jQuery.dequeue(this, type)
					})
				},
				clearQueue: function (type) {
					return this.queue(type || "fx", [])
				},
				promise: function (type, obj) {
					var tmp, count = 1,
						defer = jQuery.Deferred(),
						elements = this,
						i = this.length,
						resolve = function () {
							if (!--count) {
								defer.resolveWith(elements, [elements])
							}
						};
					if (typeof type !== "string") {
						obj = type;
						type = undefined
					}
					type = type || "fx";
					while (i--) {
						tmp = dataPriv.get(elements[i], type + "queueHooks");
						if (tmp && tmp.empty) {
							count++;
							tmp.empty.add(resolve)
						}
					}
					resolve();
					return defer.promise(obj)
				}
			});
			var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
			var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
			var cssExpand = ["Top", "Right", "Bottom", "Left"];
			var documentElement = document.documentElement;
			var isAttached = function (elem) {
					return jQuery.contains(elem.ownerDocument, elem)
				},
				composed = {
					composed: true
				};
			if (documentElement.getRootNode) {
				isAttached = function (elem) {
					return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument
				}
			}
			var isHiddenWithinTree = function (elem, el) {
				elem = el || elem;
				return elem.style.display === "none" || elem.style.display === "" && isAttached(elem) && jQuery.css(elem, "display") === "none"
			};

			function adjustCSS(elem, prop, valueParts, tween) {
				var adjusted, scale, maxIterations = 20,
					currentValue = tween ? function () {
						return tween.cur()
					} : function () {
						return jQuery.css(elem, prop, "")
					},
					initial = currentValue(),
					unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
					initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
				if (initialInUnit && initialInUnit[3] !== unit) {
					initial = initial / 2;
					unit = unit || initialInUnit[3];
					initialInUnit = +initial || 1;
					while (maxIterations--) {
						jQuery.style(elem, prop, initialInUnit + unit);
						if ((1 - scale) * (1 - (scale = currentValue() / initial || .5)) <= 0) {
							maxIterations = 0
						}
						initialInUnit = initialInUnit / scale
					}
					initialInUnit = initialInUnit * 2;
					jQuery.style(elem, prop, initialInUnit + unit);
					valueParts = valueParts || []
				}
				if (valueParts) {
					initialInUnit = +initialInUnit || +initial || 0;
					adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
					if (tween) {
						tween.unit = unit;
						tween.start = initialInUnit;
						tween.end = adjusted
					}
				}
				return adjusted
			}
			var defaultDisplayMap = {};

			function getDefaultDisplay(elem) {
				var temp, doc = elem.ownerDocument,
					nodeName = elem.nodeName,
					display = defaultDisplayMap[nodeName];
				if (display) {
					return display
				}
				temp = doc.body.appendChild(doc.createElement(nodeName));
				display = jQuery.css(temp, "display");
				temp.parentNode.removeChild(temp);
				if (display === "none") {
					display = "block"
				}
				defaultDisplayMap[nodeName] = display;
				return display
			}

			function showHide(elements, show) {
				var display, elem, values = [],
					index = 0,
					length = elements.length;
				for (; index < length; index++) {
					elem = elements[index];
					if (!elem.style) {
						continue
					}
					display = elem.style.display;
					if (show) {
						if (display === "none") {
							values[index] = dataPriv.get(elem, "display") || null;
							if (!values[index]) {
								elem.style.display = ""
							}
						}
						if (elem.style.display === "" && isHiddenWithinTree(elem)) {
							values[index] = getDefaultDisplay(elem)
						}
					} else {
						if (display !== "none") {
							values[index] = "none";
							dataPriv.set(elem, "display", display)
						}
					}
				}
				for (index = 0; index < length; index++) {
					if (values[index] != null) {
						elements[index].style.display = values[index]
					}
				}
				return elements
			}
			jQuery.fn.extend({
				show: function () {
					return showHide(this, true)
				},
				hide: function () {
					return showHide(this)
				},
				toggle: function (state) {
					if (typeof state === "boolean") {
						return state ? this.show() : this.hide()
					}
					return this.each(function () {
						if (isHiddenWithinTree(this)) {
							jQuery(this).show()
						} else {
							jQuery(this).hide()
						}
					})
				}
			});
			var rcheckableType = /^(?:checkbox|radio)$/i;
			var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
			var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
			(function () {
				var fragment = document.createDocumentFragment(),
					div = fragment.appendChild(document.createElement("div")),
					input = document.createElement("input");
				input.setAttribute("type", "radio");
				input.setAttribute("checked", "checked");
				input.setAttribute("name", "t");
				div.appendChild(input);
				support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
				div.innerHTML = "<textarea>x</textarea>";
				support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
				div.innerHTML = "<option></option>";
				support.option = !!div.lastChild
			})();
			var wrapMap = {
				thead: [1, "<table>", "</table>"],
				col: [2, "<table><colgroup>", "</colgroup></table>"],
				tr: [2, "<table><tbody>", "</tbody></table>"],
				td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
				_default: [0, "", ""]
			};
			wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
			wrapMap.th = wrapMap.td;
			if (!support.option) {
				wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"]
			}

			function getAll(context, tag) {
				var ret;
				if (typeof context.getElementsByTagName !== "undefined") {
					ret = context.getElementsByTagName(tag || "*")
				} else if (typeof context.querySelectorAll !== "undefined") {
					ret = context.querySelectorAll(tag || "*")
				} else {
					ret = []
				}
				if (tag === undefined || tag && nodeName(context, tag)) {
					return jQuery.merge([context], ret)
				}
				return ret
			}

			function setGlobalEval(elems, refElements) {
				var i = 0,
					l = elems.length;
				for (; i < l; i++) {
					dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"))
				}
			}
			var rhtml = /<|&#?\w+;/;

			function buildFragment(elems, context, scripts, selection, ignored) {
				var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(),
					nodes = [],
					i = 0,
					l = elems.length;
				for (; i < l; i++) {
					elem = elems[i];
					if (elem || elem === 0) {
						if (toType(elem) === "object") {
							jQuery.merge(nodes, elem.nodeType ? [elem] : elem)
						} else if (!rhtml.test(elem)) {
							nodes.push(context.createTextNode(elem))
						} else {
							tmp = tmp || fragment.appendChild(context.createElement("div"));
							tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
							wrap = wrapMap[tag] || wrapMap._default;
							tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
							j = wrap[0];
							while (j--) {
								tmp = tmp.lastChild
							}
							jQuery.merge(nodes, tmp.childNodes);
							tmp = fragment.firstChild;
							tmp.textContent = ""
						}
					}
				}
				fragment.textContent = "";
				i = 0;
				while (elem = nodes[i++]) {
					if (selection && jQuery.inArray(elem, selection) > -1) {
						if (ignored) {
							ignored.push(elem)
						}
						continue
					}
					attached = isAttached(elem);
					tmp = getAll(fragment.appendChild(elem), "script");
					if (attached) {
						setGlobalEval(tmp)
					}
					if (scripts) {
						j = 0;
						while (elem = tmp[j++]) {
							if (rscriptType.test(elem.type || "")) {
								scripts.push(elem)
							}
						}
					}
				}
				return fragment
			}
			var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

			function returnTrue() {
				return true
			}

			function returnFalse() {
				return false
			}

			function expectSync(elem, type) {
				return elem === safeActiveElement() === (type === "focus")
			}

			function safeActiveElement() {
				try {
					return document.activeElement
				} catch (err) {}
			}

			function on(elem, types, selector, data, fn, one) {
				var origFn, type;
				if (typeof types === "object") {
					if (typeof selector !== "string") {
						data = data || selector;
						selector = undefined
					}
					for (type in types) {
						on(elem, type, selector, data, types[type], one)
					}
					return elem
				}
				if (data == null && fn == null) {
					fn = selector;
					data = selector = undefined
				} else if (fn == null) {
					if (typeof selector === "string") {
						fn = data;
						data = undefined
					} else {
						fn = data;
						data = selector;
						selector = undefined
					}
				}
				if (fn === false) {
					fn = returnFalse
				} else if (!fn) {
					return elem
				}
				if (one === 1) {
					origFn = fn;
					fn = function (event) {
						jQuery().off(event);
						return origFn.apply(this, arguments)
					};
					fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)
				}
				return elem.each(function () {
					jQuery.event.add(this, types, fn, data, selector)
				})
			}
			jQuery.event = {
				global: {},
				add: function (elem, types, handler, data, selector) {
					var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
					if (!acceptData(elem)) {
						return
					}
					if (handler.handler) {
						handleObjIn = handler;
						handler = handleObjIn.handler;
						selector = handleObjIn.selector
					}
					if (selector) {
						jQuery.find.matchesSelector(documentElement, selector)
					}
					if (!handler.guid) {
						handler.guid = jQuery.guid++
					}
					if (!(events = elemData.events)) {
						events = elemData.events = Object.create(null)
					}
					if (!(eventHandle = elemData.handle)) {
						eventHandle = elemData.handle = function (e) {
							return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined
						}
					}
					types = (types || "").match(rnothtmlwhite) || [""];
					t = types.length;
					while (t--) {
						tmp = rtypenamespace.exec(types[t]) || [];
						type = origType = tmp[1];
						namespaces = (tmp[2] || "").split(".").sort();
						if (!type) {
							continue
						}
						special = jQuery.event.special[type] || {};
						type = (selector ? special.delegateType : special.bindType) || type;
						special = jQuery.event.special[type] || {};
						handleObj = jQuery.extend({
							type: type,
							origType: origType,
							data: data,
							handler: handler,
							guid: handler.guid,
							selector: selector,
							needsContext: selector && jQuery.expr.match.needsContext.test(selector),
							namespace: namespaces.join(".")
						}, handleObjIn);
						if (!(handlers = events[type])) {
							handlers = events[type] = [];
							handlers.delegateCount = 0;
							if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
								if (elem.addEventListener) {
									elem.addEventListener(type, eventHandle)
								}
							}
						}
						if (special.add) {
							special.add.call(elem, handleObj);
							if (!handleObj.handler.guid) {
								handleObj.handler.guid = handler.guid
							}
						}
						if (selector) {
							handlers.splice(handlers.delegateCount++, 0, handleObj)
						} else {
							handlers.push(handleObj)
						}
						jQuery.event.global[type] = true
					}
				},
				remove: function (elem, types, handler, selector, mappedTypes) {
					var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
					if (!elemData || !(events = elemData.events)) {
						return
					}
					types = (types || "").match(rnothtmlwhite) || [""];
					t = types.length;
					while (t--) {
						tmp = rtypenamespace.exec(types[t]) || [];
						type = origType = tmp[1];
						namespaces = (tmp[2] || "").split(".").sort();
						if (!type) {
							for (type in events) {
								jQuery.event.remove(elem, type + types[t], handler, selector, true)
							}
							continue
						}
						special = jQuery.event.special[type] || {};
						type = (selector ? special.delegateType : special.bindType) || type;
						handlers = events[type] || [];
						tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
						origCount = j = handlers.length;
						while (j--) {
							handleObj = handlers[j];
							if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
								handlers.splice(j, 1);
								if (handleObj.selector) {
									handlers.delegateCount--
								}
								if (special.remove) {
									special.remove.call(elem, handleObj)
								}
							}
						}
						if (origCount && !handlers.length) {
							if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
								jQuery.removeEvent(elem, type, elemData.handle)
							}
							delete events[type]
						}
					}
					if (jQuery.isEmptyObject(events)) {
						dataPriv.remove(elem, "handle events")
					}
				},
				dispatch: function (nativeEvent) {
					var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length),
						event = jQuery.event.fix(nativeEvent),
						handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [],
						special = jQuery.event.special[event.type] || {};
					args[0] = event;
					for (i = 1; i < arguments.length; i++) {
						args[i] = arguments[i]
					}
					event.delegateTarget = this;
					if (special.preDispatch && special.preDispatch.call(this, event) === false) {
						return
					}
					handlerQueue = jQuery.event.handlers.call(this, event, handlers);
					i = 0;
					while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
						event.currentTarget = matched.elem;
						j = 0;
						while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
							if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
								event.handleObj = handleObj;
								event.data = handleObj.data;
								ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
								if (ret !== undefined) {
									if ((event.result = ret) === false) {
										event.preventDefault();
										event.stopPropagation()
									}
								}
							}
						}
					}
					if (special.postDispatch) {
						special.postDispatch.call(this, event)
					}
					return event.result
				},
				handlers: function (event, handlers) {
					var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [],
						delegateCount = handlers.delegateCount,
						cur = event.target;
					if (delegateCount && cur.nodeType && !(event.type === "click" && event.button >= 1)) {
						for (; cur !== this; cur = cur.parentNode || this) {
							if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
								matchedHandlers = [];
								matchedSelectors = {};
								for (i = 0; i < delegateCount; i++) {
									handleObj = handlers[i];
									sel = handleObj.selector + " ";
									if (matchedSelectors[sel] === undefined) {
										matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length
									}
									if (matchedSelectors[sel]) {
										matchedHandlers.push(handleObj)
									}
								}
								if (matchedHandlers.length) {
									handlerQueue.push({
										elem: cur,
										handlers: matchedHandlers
									})
								}
							}
						}
					}
					cur = this;
					if (delegateCount < handlers.length) {
						handlerQueue.push({
							elem: cur,
							handlers: handlers.slice(delegateCount)
						})
					}
					return handlerQueue
				},
				addProp: function (name, hook) {
					Object.defineProperty(jQuery.Event.prototype, name, {
						enumerable: true,
						configurable: true,
						get: isFunction(hook) ? function () {
							if (this.originalEvent) {
								return hook(this.originalEvent)
							}
						} : function () {
							if (this.originalEvent) {
								return this.originalEvent[name]
							}
						},
						set: function (value) {
							Object.defineProperty(this, name, {
								enumerable: true,
								configurable: true,
								writable: true,
								value: value
							})
						}
					})
				},
				fix: function (originalEvent) {
					return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent)
				},
				special: {
					load: {
						noBubble: true
					},
					click: {
						setup: function (data) {
							var el = this || data;
							if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
								leverageNative(el, "click", returnTrue)
							}
							return false
						},
						trigger: function (data) {
							var el = this || data;
							if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
								leverageNative(el, "click")
							}
							return true
						},
						_default: function (event) {
							var target = event.target;
							return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a")
						}
					},
					beforeunload: {
						postDispatch: function (event) {
							if (event.result !== undefined && event.originalEvent) {
								event.originalEvent.returnValue = event.result
							}
						}
					}
				}
			};

			function leverageNative(el, type, expectSync) {
				if (!expectSync) {
					if (dataPriv.get(el, type) === undefined) {
						jQuery.event.add(el, type, returnTrue)
					}
					return
				}
				dataPriv.set(el, type, false);
				jQuery.event.add(el, type, {
					namespace: false,
					handler: function (event) {
						var notAsync, result, saved = dataPriv.get(this, type);
						if (event.isTrigger & 1 && this[type]) {
							if (!saved.length) {
								saved = slice.call(arguments);
								dataPriv.set(this, type, saved);
								notAsync = expectSync(this, type);
								this[type]();
								result = dataPriv.get(this, type);
								if (saved !== result || notAsync) {
									dataPriv.set(this, type, false)
								} else {
									result = {}
								}
								if (saved !== result) {
									event.stopImmediatePropagation();
									event.preventDefault();
									return result && result.value
								}
							} else if ((jQuery.event.special[type] || {}).delegateType) {
								event.stopPropagation()
							}
						} else if (saved.length) {
							dataPriv.set(this, type, {
								value: jQuery.event.trigger(jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
							});
							event.stopImmediatePropagation()
						}
					}
				})
			}
			jQuery.removeEvent = function (elem, type, handle) {
				if (elem.removeEventListener) {
					elem.removeEventListener(type, handle)
				}
			};
			jQuery.Event = function (src, props) {
				if (!(this instanceof jQuery.Event)) {
					return new jQuery.Event(src, props)
				}
				if (src && src.type) {
					this.originalEvent = src;
					this.type = src.type;
					this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
					this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
					this.currentTarget = src.currentTarget;
					this.relatedTarget = src.relatedTarget
				} else {
					this.type = src
				}
				if (props) {
					jQuery.extend(this, props)
				}
				this.timeStamp = src && src.timeStamp || Date.now();
				this[jQuery.expando] = true
			};
			jQuery.Event.prototype = {
				constructor: jQuery.Event,
				isDefaultPrevented: returnFalse,
				isPropagationStopped: returnFalse,
				isImmediatePropagationStopped: returnFalse,
				isSimulated: false,
				preventDefault: function () {
					var e = this.originalEvent;
					this.isDefaultPrevented = returnTrue;
					if (e && !this.isSimulated) {
						e.preventDefault()
					}
				},
				stopPropagation: function () {
					var e = this.originalEvent;
					this.isPropagationStopped = returnTrue;
					if (e && !this.isSimulated) {
						e.stopPropagation()
					}
				},
				stopImmediatePropagation: function () {
					var e = this.originalEvent;
					this.isImmediatePropagationStopped = returnTrue;
					if (e && !this.isSimulated) {
						e.stopImmediatePropagation()
					}
					this.stopPropagation()
				}
			};
			jQuery.each({
				altKey: true,
				bubbles: true,
				cancelable: true,
				changedTouches: true,
				ctrlKey: true,
				detail: true,
				eventPhase: true,
				metaKey: true,
				pageX: true,
				pageY: true,
				shiftKey: true,
				view: true,
				char: true,
				code: true,
				charCode: true,
				key: true,
				keyCode: true,
				button: true,
				buttons: true,
				clientX: true,
				clientY: true,
				offsetX: true,
				offsetY: true,
				pointerId: true,
				pointerType: true,
				screenX: true,
				screenY: true,
				targetTouches: true,
				toElement: true,
				touches: true,
				which: true
			}, jQuery.event.addProp);
			jQuery.each({
				focus: "focusin",
				blur: "focusout"
			}, function (type, delegateType) {
				jQuery.event.special[type] = {
					setup: function () {
						leverageNative(this, type, expectSync);
						return false
					},
					trigger: function () {
						leverageNative(this, type);
						return true
					},
					_default: function () {
						return true
					},
					delegateType: delegateType
				}
			});
			jQuery.each({
				mouseenter: "mouseover",
				mouseleave: "mouseout",
				pointerenter: "pointerover",
				pointerleave: "pointerout"
			}, function (orig, fix) {
				jQuery.event.special[orig] = {
					delegateType: fix,
					bindType: fix,
					handle: function (event) {
						var ret, target = this,
							related = event.relatedTarget,
							handleObj = event.handleObj;
						if (!related || related !== target && !jQuery.contains(target, related)) {
							event.type = handleObj.origType;
							ret = handleObj.handler.apply(this, arguments);
							event.type = fix
						}
						return ret
					}
				}
			});
			jQuery.fn.extend({
				on: function (types, selector, data, fn) {
					return on(this, types, selector, data, fn)
				},
				one: function (types, selector, data, fn) {
					return on(this, types, selector, data, fn, 1)
				},
				off: function (types, selector, fn) {
					var handleObj, type;
					if (types && types.preventDefault && types.handleObj) {
						handleObj = types.handleObj;
						jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
						return this
					}
					if (typeof types === "object") {
						for (type in types) {
							this.off(type, selector, types[type])
						}
						return this
					}
					if (selector === false || typeof selector === "function") {
						fn = selector;
						selector = undefined
					}
					if (fn === false) {
						fn = returnFalse
					}
					return this.each(function () {
						jQuery.event.remove(this, types, fn, selector)
					})
				}
			});
			var rnoInnerhtml = /<script|<style|<link/i,
				rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
				rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

			function manipulationTarget(elem, content) {
				if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
					return jQuery(elem).children("tbody")[0] || elem
				}
				return elem
			}

			function disableScript(elem) {
				elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
				return elem
			}

			function restoreScript(elem) {
				if ((elem.type || "").slice(0, 5) === "true/") {
					elem.type = elem.type.slice(5)
				} else {
					elem.removeAttribute("type")
				}
				return elem
			}

			function cloneCopyEvent(src, dest) {
				var i, l, type, pdataOld, udataOld, udataCur, events;
				if (dest.nodeType !== 1) {
					return
				}
				if (dataPriv.hasData(src)) {
					pdataOld = dataPriv.get(src);
					events = pdataOld.events;
					if (events) {
						dataPriv.remove(dest, "handle events");
						for (type in events) {
							for (i = 0, l = events[type].length; i < l; i++) {
								jQuery.event.add(dest, type, events[type][i])
							}
						}
					}
				}
				if (dataUser.hasData(src)) {
					udataOld = dataUser.access(src);
					udataCur = jQuery.extend({}, udataOld);
					dataUser.set(dest, udataCur)
				}
			}

			function fixInput(src, dest) {
				var nodeName = dest.nodeName.toLowerCase();
				if (nodeName === "input" && rcheckableType.test(src.type)) {
					dest.checked = src.checked
				} else if (nodeName === "input" || nodeName === "textarea") {
					dest.defaultValue = src.defaultValue
				}
			}

			function domManip(collection, args, callback, ignored) {
				args = flat(args);
				var fragment, first, scripts, hasScripts, node, doc, i = 0,
					l = collection.length,
					iNoClone = l - 1,
					value = args[0],
					valueIsFunction = isFunction(value);
				if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
					return collection.each(function (index) {
						var self = collection.eq(index);
						if (valueIsFunction) {
							args[0] = value.call(this, index, self.html())
						}
						domManip(self, args, callback, ignored)
					})
				}
				if (l) {
					fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
					first = fragment.firstChild;
					if (fragment.childNodes.length === 1) {
						fragment = first
					}
					if (first || ignored) {
						scripts = jQuery.map(getAll(fragment, "script"), disableScript);
						hasScripts = scripts.length;
						for (; i < l; i++) {
							node = fragment;
							if (i !== iNoClone) {
								node = jQuery.clone(node, true, true);
								if (hasScripts) {
									jQuery.merge(scripts, getAll(node, "script"))
								}
							}
							callback.call(collection[i], node, i)
						}
						if (hasScripts) {
							doc = scripts[scripts.length - 1].ownerDocument;
							jQuery.map(scripts, restoreScript);
							for (i = 0; i < hasScripts; i++) {
								node = scripts[i];
								if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
									if (node.src && (node.type || "").toLowerCase() !== "module") {
										if (jQuery._evalUrl && !node.noModule) {
											jQuery._evalUrl(node.src, {
												nonce: node.nonce || node.getAttribute("nonce")
											}, doc)
										}
									} else {
										DOMEval(node.textContent.replace(rcleanScript, ""), node, doc)
									}
								}
							}
						}
					}
				}
				return collection
			}

			function remove(elem, selector, keepData) {
				var node, nodes = selector ? jQuery.filter(selector, elem) : elem,
					i = 0;
				for (;
					(node = nodes[i]) != null; i++) {
					if (!keepData && node.nodeType === 1) {
						jQuery.cleanData(getAll(node))
					}
					if (node.parentNode) {
						if (keepData && isAttached(node)) {
							setGlobalEval(getAll(node, "script"))
						}
						node.parentNode.removeChild(node)
					}
				}
				return elem
			}
			jQuery.extend({
				htmlPrefilter: function (html) {
					return html
				},
				clone: function (elem, dataAndEvents, deepDataAndEvents) {
					var i, l, srcElements, destElements, clone = elem.cloneNode(true),
						inPage = isAttached(elem);
					if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
						destElements = getAll(clone);
						srcElements = getAll(elem);
						for (i = 0, l = srcElements.length; i < l; i++) {
							fixInput(srcElements[i], destElements[i])
						}
					}
					if (dataAndEvents) {
						if (deepDataAndEvents) {
							srcElements = srcElements || getAll(elem);
							destElements = destElements || getAll(clone);
							for (i = 0, l = srcElements.length; i < l; i++) {
								cloneCopyEvent(srcElements[i], destElements[i])
							}
						} else {
							cloneCopyEvent(elem, clone)
						}
					}
					destElements = getAll(clone, "script");
					if (destElements.length > 0) {
						setGlobalEval(destElements, !inPage && getAll(elem, "script"))
					}
					return clone
				},
				cleanData: function (elems) {
					var data, elem, type, special = jQuery.event.special,
						i = 0;
					for (;
						(elem = elems[i]) !== undefined; i++) {
						if (acceptData(elem)) {
							if (data = elem[dataPriv.expando]) {
								if (data.events) {
									for (type in data.events) {
										if (special[type]) {
											jQuery.event.remove(elem, type)
										} else {
											jQuery.removeEvent(elem, type, data.handle)
										}
									}
								}
								elem[dataPriv.expando] = undefined
							}
							if (elem[dataUser.expando]) {
								elem[dataUser.expando] = undefined
							}
						}
					}
				}
			});
			jQuery.fn.extend({
				detach: function (selector) {
					return remove(this, selector, true)
				},
				remove: function (selector) {
					return remove(this, selector)
				},
				text: function (value) {
					return access(this, function (value) {
						return value === undefined ? jQuery.text(this) : this.empty().each(function () {
							if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
								this.textContent = value
							}
						})
					}, null, value, arguments.length)
				},
				append: function () {
					return domManip(this, arguments, function (elem) {
						if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
							var target = manipulationTarget(this, elem);
							target.appendChild(elem)
						}
					})
				},
				prepend: function () {
					return domManip(this, arguments, function (elem) {
						if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
							var target = manipulationTarget(this, elem);
							target.insertBefore(elem, target.firstChild)
						}
					})
				},
				before: function () {
					return domManip(this, arguments, function (elem) {
						if (this.parentNode) {
							this.parentNode.insertBefore(elem, this)
						}
					})
				},
				after: function () {
					return domManip(this, arguments, function (elem) {
						if (this.parentNode) {
							this.parentNode.insertBefore(elem, this.nextSibling)
						}
					})
				},
				empty: function () {
					var elem, i = 0;
					for (;
						(elem = this[i]) != null; i++) {
						if (elem.nodeType === 1) {
							jQuery.cleanData(getAll(elem, false));
							elem.textContent = ""
						}
					}
					return this
				},
				clone: function (dataAndEvents, deepDataAndEvents) {
					dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
					deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
					return this.map(function () {
						return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
					})
				},
				html: function (value) {
					return access(this, function (value) {
						var elem = this[0] || {},
							i = 0,
							l = this.length;
						if (value === undefined && elem.nodeType === 1) {
							return elem.innerHTML
						}
						if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
							value = jQuery.htmlPrefilter(value);
							try {
								for (; i < l; i++) {
									elem = this[i] || {};
									if (elem.nodeType === 1) {
										jQuery.cleanData(getAll(elem, false));
										elem.innerHTML = value
									}
								}
								elem = 0
							} catch (e) {}
						}
						if (elem) {
							this.empty().append(value)
						}
					}, null, value, arguments.length)
				},
				replaceWith: function () {
					var ignored = [];
					return domManip(this, arguments, function (elem) {
						var parent = this.parentNode;
						if (jQuery.inArray(this, ignored) < 0) {
							jQuery.cleanData(getAll(this));
							if (parent) {
								parent.replaceChild(elem, this)
							}
						}
					}, ignored)
				}
			});
			jQuery.each({
				appendTo: "append",
				prependTo: "prepend",
				insertBefore: "before",
				insertAfter: "after",
				replaceAll: "replaceWith"
			}, function (name, original) {
				jQuery.fn[name] = function (selector) {
					var elems, ret = [],
						insert = jQuery(selector),
						last = insert.length - 1,
						i = 0;
					for (; i <= last; i++) {
						elems = i === last ? this : this.clone(true);
						jQuery(insert[i])[original](elems);
						push.apply(ret, elems.get())
					}
					return this.pushStack(ret)
				}
			});
			var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
			var getStyles = function (elem) {
				var view = elem.ownerDocument.defaultView;
				if (!view || !view.opener) {
					view = window
				}
				return view.getComputedStyle(elem)
			};
			var swap = function (elem, options, callback) {
				var ret, name, old = {};
				for (name in options) {
					old[name] = elem.style[name];
					elem.style[name] = options[name]
				}
				ret = callback.call(elem);
				for (name in options) {
					elem.style[name] = old[name]
				}
				return ret
			};
			var rboxStyle = new RegExp(cssExpand.join("|"), "i");
			(function () {
				function computeStyleTests() {
					if (!div) {
						return
					}
					container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
					div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
					documentElement.appendChild(container).appendChild(div);
					var divStyle = window.getComputedStyle(div);
					pixelPositionVal = divStyle.top !== "1%";
					reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
					div.style.right = "60%";
					pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
					boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
					div.style.position = "absolute";
					scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
					documentElement.removeChild(container);
					div = null
				}

				function roundPixelMeasures(measure) {
					return Math.round(parseFloat(measure))
				}
				var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document.createElement("div"),
					div = document.createElement("div");
				if (!div.style) {
					return
				}
				div.style.backgroundClip = "content-box";
				div.cloneNode(true).style.backgroundClip = "";
				support.clearCloneStyle = div.style.backgroundClip === "content-box";
				jQuery.extend(support, {
					boxSizingReliable: function () {
						computeStyleTests();
						return boxSizingReliableVal
					},
					pixelBoxStyles: function () {
						computeStyleTests();
						return pixelBoxStylesVal
					},
					pixelPosition: function () {
						computeStyleTests();
						return pixelPositionVal
					},
					reliableMarginLeft: function () {
						computeStyleTests();
						return reliableMarginLeftVal
					},
					scrollboxSize: function () {
						computeStyleTests();
						return scrollboxSizeVal
					},
					reliableTrDimensions: function () {
						var table, tr, trChild, trStyle;
						if (reliableTrDimensionsVal == null) {
							table = document.createElement("table");
							tr = document.createElement("tr");
							trChild = document.createElement("div");
							table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
							tr.style.cssText = "border:1px solid";
							tr.style.height = "1px";
							trChild.style.height = "9px";
							trChild.style.display = "block";
							documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
							trStyle = window.getComputedStyle(tr);
							reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
							documentElement.removeChild(table)
						}
						return reliableTrDimensionsVal
					}
				})
			})();

			function curCSS(elem, name, computed) {
				var width, minWidth, maxWidth, ret, style = elem.style;
				computed = computed || getStyles(elem);
				if (computed) {
					ret = computed.getPropertyValue(name) || computed[name];
					if (ret === "" && !isAttached(elem)) {
						ret = jQuery.style(elem, name)
					}
					if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
						width = style.width;
						minWidth = style.minWidth;
						maxWidth = style.maxWidth;
						style.minWidth = style.maxWidth = style.width = ret;
						ret = computed.width;
						style.width = width;
						style.minWidth = minWidth;
						style.maxWidth = maxWidth
					}
				}
				return ret !== undefined ? ret + "" : ret
			}

			function addGetHookIf(conditionFn, hookFn) {
				return {
					get: function () {
						if (conditionFn()) {
							delete this.get;
							return
						}
						return (this.get = hookFn).apply(this, arguments)
					}
				}
			}
			var cssPrefixes = ["Webkit", "Moz", "ms"],
				emptyStyle = document.createElement("div").style,
				vendorProps = {};

			function vendorPropName(name) {
				var capName = name[0].toUpperCase() + name.slice(1),
					i = cssPrefixes.length;
				while (i--) {
					name = cssPrefixes[i] + capName;
					if (name in emptyStyle) {
						return name
					}
				}
			}

			function finalPropName(name) {
				var final = jQuery.cssProps[name] || vendorProps[name];
				if (final) {
					return final
				}
				if (name in emptyStyle) {
					return name
				}
				return vendorProps[name] = vendorPropName(name) || name
			}
			var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
				rcustomProp = /^--/,
				cssShow = {
					position: "absolute",
					visibility: "hidden",
					display: "block"
				},
				cssNormalTransform = {
					letterSpacing: "0",
					fontWeight: "400"
				};

			function setPositiveNumber(_elem, value, subtract) {
				var matches = rcssNum.exec(value);
				return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value
			}

			function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
				var i = dimension === "width" ? 1 : 0,
					extra = 0,
					delta = 0;
				if (box === (isBorderBox ? "border" : "content")) {
					return 0
				}
				for (; i < 4; i += 2) {
					if (box === "margin") {
						delta += jQuery.css(elem, box + cssExpand[i], true, styles)
					}
					if (!isBorderBox) {
						delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
						if (box !== "padding") {
							delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles)
						} else {
							extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles)
						}
					} else {
						if (box === "content") {
							delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles)
						}
						if (box !== "margin") {
							delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles)
						}
					}
				}
				if (!isBorderBox && computedVal >= 0) {
					delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - .5)) || 0
				}
				return delta
			}

			function getWidthOrHeight(elem, dimension, extra) {
				var styles = getStyles(elem),
					boxSizingNeeded = !support.boxSizingReliable() || extra,
					isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
					valueIsBorderBox = isBorderBox,
					val = curCSS(elem, dimension, styles),
					offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
				if (rnumnonpx.test(val)) {
					if (!extra) {
						return val
					}
					val = "auto"
				}
				if ((!support.boxSizingReliable() && isBorderBox || !support.reliableTrDimensions() && nodeName(elem, "tr") || val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && elem.getClientRects().length) {
					isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
					valueIsBorderBox = offsetProp in elem;
					if (valueIsBorderBox) {
						val = elem[offsetProp]
					}
				}
				val = parseFloat(val) || 0;
				return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, val) + "px"
			}
			jQuery.extend({
				cssHooks: {
					opacity: {
						get: function (elem, computed) {
							if (computed) {
								var ret = curCSS(elem, "opacity");
								return ret === "" ? "1" : ret
							}
						}
					}
				},
				cssNumber: {
					animationIterationCount: true,
					columnCount: true,
					fillOpacity: true,
					flexGrow: true,
					flexShrink: true,
					fontWeight: true,
					gridArea: true,
					gridColumn: true,
					gridColumnEnd: true,
					gridColumnStart: true,
					gridRow: true,
					gridRowEnd: true,
					gridRowStart: true,
					lineHeight: true,
					opacity: true,
					order: true,
					orphans: true,
					widows: true,
					zIndex: true,
					zoom: true
				},
				cssProps: {},
				style: function (elem, name, value, extra) {
					if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
						return
					}
					var ret, type, hooks, origName = camelCase(name),
						isCustomProp = rcustomProp.test(name),
						style = elem.style;
					if (!isCustomProp) {
						name = finalPropName(origName)
					}
					hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
					if (value !== undefined) {
						type = typeof value;
						if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
							value = adjustCSS(elem, name, ret);
							type = "number"
						}
						if (value == null || value !== value) {
							return
						}
						if (type === "number" && !isCustomProp) {
							value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px")
						}
						if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
							style[name] = "inherit"
						}
						if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
							if (isCustomProp) {
								style.setProperty(name, value)
							} else {
								style[name] = value
							}
						}
					} else {
						if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
							return ret
						}
						return style[name]
					}
				},
				css: function (elem, name, extra, styles) {
					var val, num, hooks, origName = camelCase(name),
						isCustomProp = rcustomProp.test(name);
					if (!isCustomProp) {
						name = finalPropName(origName)
					}
					hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
					if (hooks && "get" in hooks) {
						val = hooks.get(elem, true, extra)
					}
					if (val === undefined) {
						val = curCSS(elem, name, styles)
					}
					if (val === "normal" && name in cssNormalTransform) {
						val = cssNormalTransform[name]
					}
					if (extra === "" || extra) {
						num = parseFloat(val);
						return extra === true || isFinite(num) ? num || 0 : val
					}
					return val
				}
			});
			jQuery.each(["height", "width"], function (_i, dimension) {
				jQuery.cssHooks[dimension] = {
					get: function (elem, computed, extra) {
						if (computed) {
							return rdisplayswap.test(jQuery.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
								return getWidthOrHeight(elem, dimension, extra)
							}) : getWidthOrHeight(elem, dimension, extra)
						}
					},
					set: function (elem, value, extra) {
						var matches, styles = getStyles(elem),
							scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute",
							boxSizingNeeded = scrollboxSizeBuggy || extra,
							isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
							subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;
						if (isBorderBox && scrollboxSizeBuggy) {
							subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - .5)
						}
						if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
							elem.style[dimension] = value;
							value = jQuery.css(elem, dimension)
						}
						return setPositiveNumber(elem, value, subtract)
					}
				}
			});
			jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
				if (computed) {
					return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
						marginLeft: 0
					}, function () {
						return elem.getBoundingClientRect().left
					})) + "px"
				}
			});
			jQuery.each({
				margin: "",
				padding: "",
				border: "Width"
			}, function (prefix, suffix) {
				jQuery.cssHooks[prefix + suffix] = {
					expand: function (value) {
						var i = 0,
							expanded = {},
							parts = typeof value === "string" ? value.split(" ") : [value];
						for (; i < 4; i++) {
							expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0]
						}
						return expanded
					}
				};
				if (prefix !== "margin") {
					jQuery.cssHooks[prefix + suffix].set = setPositiveNumber
				}
			});
			jQuery.fn.extend({
				css: function (name, value) {
					return access(this, function (elem, name, value) {
						var styles, len, map = {},
							i = 0;
						if (Array.isArray(name)) {
							styles = getStyles(elem);
							len = name.length;
							for (; i < len; i++) {
								map[name[i]] = jQuery.css(elem, name[i], false, styles)
							}
							return map
						}
						return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name)
					}, name, value, arguments.length > 1)
				}
			});

			function Tween(elem, options, prop, end, easing) {
				return new Tween.prototype.init(elem, options, prop, end, easing)
			}
			jQuery.Tween = Tween;
			Tween.prototype = {
				constructor: Tween,
				init: function (elem, options, prop, end, easing, unit) {
					this.elem = elem;
					this.prop = prop;
					this.easing = easing || jQuery.easing._default;
					this.options = options;
					this.start = this.now = this.cur();
					this.end = end;
					this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px")
				},
				cur: function () {
					var hooks = Tween.propHooks[this.prop];
					return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this)
				},
				run: function (percent) {
					var eased, hooks = Tween.propHooks[this.prop];
					if (this.options.duration) {
						this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration)
					} else {
						this.pos = eased = percent
					}
					this.now = (this.end - this.start) * eased + this.start;
					if (this.options.step) {
						this.options.step.call(this.elem, this.now, this)
					}
					if (hooks && hooks.set) {
						hooks.set(this)
					} else {
						Tween.propHooks._default.set(this)
					}
					return this
				}
			};
			Tween.prototype.init.prototype = Tween.prototype;
			Tween.propHooks = {
				_default: {
					get: function (tween) {
						var result;
						if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
							return tween.elem[tween.prop]
						}
						result = jQuery.css(tween.elem, tween.prop, "");
						return !result || result === "auto" ? 0 : result
					},
					set: function (tween) {
						if (jQuery.fx.step[tween.prop]) {
							jQuery.fx.step[tween.prop](tween)
						} else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
							jQuery.style(tween.elem, tween.prop, tween.now + tween.unit)
						} else {
							tween.elem[tween.prop] = tween.now
						}
					}
				}
			};
			Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
				set: function (tween) {
					if (tween.elem.nodeType && tween.elem.parentNode) {
						tween.elem[tween.prop] = tween.now
					}
				}
			};
			jQuery.easing = {
				linear: function (p) {
					return p
				},
				swing: function (p) {
					return .5 - Math.cos(p * Math.PI) / 2
				},
				_default: "swing"
			};
			jQuery.fx = Tween.prototype.init;
			jQuery.fx.step = {};
			var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/,
				rrun = /queueHooks$/;

			function schedule() {
				if (inProgress) {
					if (document.hidden === false && window.requestAnimationFrame) {
						window.requestAnimationFrame(schedule)
					} else {
						window.setTimeout(schedule, jQuery.fx.interval)
					}
					jQuery.fx.tick()
				}
			}

			function createFxNow() {
				window.setTimeout(function () {
					fxNow = undefined
				});
				return fxNow = Date.now()
			}

			function genFx(type, includeWidth) {
				var which, i = 0,
					attrs = {
						height: type
					};
				includeWidth = includeWidth ? 1 : 0;
				for (; i < 4; i += 2 - includeWidth) {
					which = cssExpand[i];
					attrs["margin" + which] = attrs["padding" + which] = type
				}
				if (includeWidth) {
					attrs.opacity = attrs.width = type
				}
				return attrs
			}

			function createTween(value, prop, animation) {
				var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
					index = 0,
					length = collection.length;
				for (; index < length; index++) {
					if (tween = collection[index].call(animation, prop, value)) {
						return tween
					}
				}
			}

			function defaultPrefilter(elem, props, opts) {
				var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props,
					anim = this,
					orig = {},
					style = elem.style,
					hidden = elem.nodeType && isHiddenWithinTree(elem),
					dataShow = dataPriv.get(elem, "fxshow");
				if (!opts.queue) {
					hooks = jQuery._queueHooks(elem, "fx");
					if (hooks.unqueued == null) {
						hooks.unqueued = 0;
						oldfire = hooks.empty.fire;
						hooks.empty.fire = function () {
							if (!hooks.unqueued) {
								oldfire()
							}
						}
					}
					hooks.unqueued++;
					anim.always(function () {
						anim.always(function () {
							hooks.unqueued--;
							if (!jQuery.queue(elem, "fx").length) {
								hooks.empty.fire()
							}
						})
					})
				}
				for (prop in props) {
					value = props[prop];
					if (rfxtypes.test(value)) {
						delete props[prop];
						toggle = toggle || value === "toggle";
						if (value === (hidden ? "hide" : "show")) {
							if (value === "show" && dataShow && dataShow[prop] !== undefined) {
								hidden = true
							} else {
								continue
							}
						}
						orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop)
					}
				}
				propTween = !jQuery.isEmptyObject(props);
				if (!propTween && jQuery.isEmptyObject(orig)) {
					return
				}
				if (isBox && elem.nodeType === 1) {
					opts.overflow = [style.overflow, style.overflowX, style.overflowY];
					restoreDisplay = dataShow && dataShow.display;
					if (restoreDisplay == null) {
						restoreDisplay = dataPriv.get(elem, "display")
					}
					display = jQuery.css(elem, "display");
					if (display === "none") {
						if (restoreDisplay) {
							display = restoreDisplay
						} else {
							showHide([elem], true);
							restoreDisplay = elem.style.display || restoreDisplay;
							display = jQuery.css(elem, "display");
							showHide([elem])
						}
					}
					if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
						if (jQuery.css(elem, "float") === "none") {
							if (!propTween) {
								anim.done(function () {
									style.display = restoreDisplay
								});
								if (restoreDisplay == null) {
									display = style.display;
									restoreDisplay = display === "none" ? "" : display
								}
							}
							style.display = "inline-block"
						}
					}
				}
				if (opts.overflow) {
					style.overflow = "hidden";
					anim.always(function () {
						style.overflow = opts.overflow[0];
						style.overflowX = opts.overflow[1];
						style.overflowY = opts.overflow[2]
					})
				}
				propTween = false;
				for (prop in orig) {
					if (!propTween) {
						if (dataShow) {
							if ("hidden" in dataShow) {
								hidden = dataShow.hidden
							}
						} else {
							dataShow = dataPriv.access(elem, "fxshow", {
								display: restoreDisplay
							})
						}
						if (toggle) {
							dataShow.hidden = !hidden
						}
						if (hidden) {
							showHide([elem], true)
						}
						anim.done(function () {
							if (!hidden) {
								showHide([elem])
							}
							dataPriv.remove(elem, "fxshow");
							for (prop in orig) {
								jQuery.style(elem, prop, orig[prop])
							}
						})
					}
					propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
					if (!(prop in dataShow)) {
						dataShow[prop] = propTween.start;
						if (hidden) {
							propTween.end = propTween.start;
							propTween.start = 0
						}
					}
				}
			}

			function propFilter(props, specialEasing) {
				var index, name, easing, value, hooks;
				for (index in props) {
					name = camelCase(index);
					easing = specialEasing[name];
					value = props[index];
					if (Array.isArray(value)) {
						easing = value[1];
						value = props[index] = value[0]
					}
					if (index !== name) {
						props[name] = value;
						delete props[index]
					}
					hooks = jQuery.cssHooks[name];
					if (hooks && "expand" in hooks) {
						value = hooks.expand(value);
						delete props[name];
						for (index in value) {
							if (!(index in props)) {
								props[index] = value[index];
								specialEasing[index] = easing
							}
						}
					} else {
						specialEasing[name] = easing
					}
				}
			}

			function Animation(elem, properties, options) {
				var result, stopped, index = 0,
					length = Animation.prefilters.length,
					deferred = jQuery.Deferred().always(function () {
						delete tick.elem
					}),
					tick = function () {
						if (stopped) {
							return false
						}
						var currentTime = fxNow || createFxNow(),
							remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
							temp = remaining / animation.duration || 0,
							percent = 1 - temp,
							index = 0,
							length = animation.tweens.length;
						for (; index < length; index++) {
							animation.tweens[index].run(percent)
						}
						deferred.notifyWith(elem, [animation, percent, remaining]);
						if (percent < 1 && length) {
							return remaining
						}
						if (!length) {
							deferred.notifyWith(elem, [animation, 1, 0])
						}
						deferred.resolveWith(elem, [animation]);
						return false
					},
					animation = deferred.promise({
						elem: elem,
						props: jQuery.extend({}, properties),
						opts: jQuery.extend(true, {
							specialEasing: {},
							easing: jQuery.easing._default
						}, options),
						originalProperties: properties,
						originalOptions: options,
						startTime: fxNow || createFxNow(),
						duration: options.duration,
						tweens: [],
						createTween: function (prop, end) {
							var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
							animation.tweens.push(tween);
							return tween
						},
						stop: function (gotoEnd) {
							var index = 0,
								length = gotoEnd ? animation.tweens.length : 0;
							if (stopped) {
								return this
							}
							stopped = true;
							for (; index < length; index++) {
								animation.tweens[index].run(1)
							}
							if (gotoEnd) {
								deferred.notifyWith(elem, [animation, 1, 0]);
								deferred.resolveWith(elem, [animation, gotoEnd])
							} else {
								deferred.rejectWith(elem, [animation, gotoEnd])
							}
							return this
						}
					}),
					props = animation.props;
				propFilter(props, animation.opts.specialEasing);
				for (; index < length; index++) {
					result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
					if (result) {
						if (isFunction(result.stop)) {
							jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result)
						}
						return result
					}
				}
				jQuery.map(props, createTween, animation);
				if (isFunction(animation.opts.start)) {
					animation.opts.start.call(elem, animation)
				}
				animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
				jQuery.fx.timer(jQuery.extend(tick, {
					elem: elem,
					anim: animation,
					queue: animation.opts.queue
				}));
				return animation
			}
			jQuery.Animation = jQuery.extend(Animation, {
				tweeners: {
					"*": [function (prop, value) {
						var tween = this.createTween(prop, value);
						adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
						return tween
					}]
				},
				tweener: function (props, callback) {
					if (isFunction(props)) {
						callback = props;
						props = ["*"]
					} else {
						props = props.match(rnothtmlwhite)
					}
					var prop, index = 0,
						length = props.length;
					for (; index < length; index++) {
						prop = props[index];
						Animation.tweeners[prop] = Animation.tweeners[prop] || [];
						Animation.tweeners[prop].unshift(callback)
					}
				},
				prefilters: [defaultPrefilter],
				prefilter: function (callback, prepend) {
					if (prepend) {
						Animation.prefilters.unshift(callback)
					} else {
						Animation.prefilters.push(callback)
					}
				}
			});
			jQuery.speed = function (speed, easing, fn) {
				var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
					complete: fn || !fn && easing || isFunction(speed) && speed,
					duration: speed,
					easing: fn && easing || easing && !isFunction(easing) && easing
				};
				if (jQuery.fx.off) {
					opt.duration = 0
				} else {
					if (typeof opt.duration !== "number") {
						if (opt.duration in jQuery.fx.speeds) {
							opt.duration = jQuery.fx.speeds[opt.duration]
						} else {
							opt.duration = jQuery.fx.speeds._default
						}
					}
				}
				if (opt.queue == null || opt.queue === true) {
					opt.queue = "fx"
				}
				opt.old = opt.complete;
				opt.complete = function () {
					if (isFunction(opt.old)) {
						opt.old.call(this)
					}
					if (opt.queue) {
						jQuery.dequeue(this, opt.queue)
					}
				};
				return opt
			};
			jQuery.fn.extend({
				fadeTo: function (speed, to, easing, callback) {
					return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({
						opacity: to
					}, speed, easing, callback)
				},
				animate: function (prop, speed, easing, callback) {
					var empty = jQuery.isEmptyObject(prop),
						optall = jQuery.speed(speed, easing, callback),
						doAnimation = function () {
							var anim = Animation(this, jQuery.extend({}, prop), optall);
							if (empty || dataPriv.get(this, "finish")) {
								anim.stop(true)
							}
						};
					doAnimation.finish = doAnimation;
					return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation)
				},
				stop: function (type, clearQueue, gotoEnd) {
					var stopQueue = function (hooks) {
						var stop = hooks.stop;
						delete hooks.stop;
						stop(gotoEnd)
					};
					if (typeof type !== "string") {
						gotoEnd = clearQueue;
						clearQueue = type;
						type = undefined
					}
					if (clearQueue) {
						this.queue(type || "fx", [])
					}
					return this.each(function () {
						var dequeue = true,
							index = type != null && type + "queueHooks",
							timers = jQuery.timers,
							data = dataPriv.get(this);
						if (index) {
							if (data[index] && data[index].stop) {
								stopQueue(data[index])
							}
						} else {
							for (index in data) {
								if (data[index] && data[index].stop && rrun.test(index)) {
									stopQueue(data[index])
								}
							}
						}
						for (index = timers.length; index--;) {
							if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
								timers[index].anim.stop(gotoEnd);
								dequeue = false;
								timers.splice(index, 1)
							}
						}
						if (dequeue || !gotoEnd) {
							jQuery.dequeue(this, type)
						}
					})
				},
				finish: function (type) {
					if (type !== false) {
						type = type || "fx"
					}
					return this.each(function () {
						var index, data = dataPriv.get(this),
							queue = data[type + "queue"],
							hooks = data[type + "queueHooks"],
							timers = jQuery.timers,
							length = queue ? queue.length : 0;
						data.finish = true;
						jQuery.queue(this, type, []);
						if (hooks && hooks.stop) {
							hooks.stop.call(this, true)
						}
						for (index = timers.length; index--;) {
							if (timers[index].elem === this && timers[index].queue === type) {
								timers[index].anim.stop(true);
								timers.splice(index, 1)
							}
						}
						for (index = 0; index < length; index++) {
							if (queue[index] && queue[index].finish) {
								queue[index].finish.call(this)
							}
						}
						delete data.finish
					})
				}
			});
			jQuery.each(["toggle", "show", "hide"], function (_i, name) {
				var cssFn = jQuery.fn[name];
				jQuery.fn[name] = function (speed, easing, callback) {
					return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback)
				}
			});
			jQuery.each({
				slideDown: genFx("show"),
				slideUp: genFx("hide"),
				slideToggle: genFx("toggle"),
				fadeIn: {
					opacity: "show"
				},
				fadeOut: {
					opacity: "hide"
				},
				fadeToggle: {
					opacity: "toggle"
				}
			}, function (name, props) {
				jQuery.fn[name] = function (speed, easing, callback) {
					return this.animate(props, speed, easing, callback)
				}
			});
			jQuery.timers = [];
			jQuery.fx.tick = function () {
				var timer, i = 0,
					timers = jQuery.timers;
				fxNow = Date.now();
				for (; i < timers.length; i++) {
					timer = timers[i];
					if (!timer() && timers[i] === timer) {
						timers.splice(i--, 1)
					}
				}
				if (!timers.length) {
					jQuery.fx.stop()
				}
				fxNow = undefined
			};
			jQuery.fx.timer = function (timer) {
				jQuery.timers.push(timer);
				jQuery.fx.start()
			};
			jQuery.fx.interval = 13;
			jQuery.fx.start = function () {
				if (inProgress) {
					return
				}
				inProgress = true;
				schedule()
			};
			jQuery.fx.stop = function () {
				inProgress = null
			};
			jQuery.fx.speeds = {
				slow: 600,
				fast: 200,
				_default: 400
			};
			jQuery.fn.delay = function (time, type) {
				time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
				type = type || "fx";
				return this.queue(type, function (next, hooks) {
					var timeout = window.setTimeout(next, time);
					hooks.stop = function () {
						window.clearTimeout(timeout)
					}
				})
			};
			(function () {
				var input = document.createElement("input"),
					select = document.createElement("select"),
					opt = select.appendChild(document.createElement("option"));
				input.type = "checkbox";
				support.checkOn = input.value !== "";
				support.optSelected = opt.selected;
				input = document.createElement("input");
				input.value = "t";
				input.type = "radio";
				support.radioValue = input.value === "t"
			})();
			var boolHook, attrHandle = jQuery.expr.attrHandle;
			jQuery.fn.extend({
				attr: function (name, value) {
					return access(this, jQuery.attr, name, value, arguments.length > 1)
				},
				removeAttr: function (name) {
					return this.each(function () {
						jQuery.removeAttr(this, name)
					})
				}
			});
			jQuery.extend({
				attr: function (elem, name, value) {
					var ret, hooks, nType = elem.nodeType;
					if (nType === 3 || nType === 8 || nType === 2) {
						return
					}
					if (typeof elem.getAttribute === "undefined") {
						return jQuery.prop(elem, name, value)
					}
					if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
						hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined)
					}
					if (value !== undefined) {
						if (value === null) {
							jQuery.removeAttr(elem, name);
							return
						}
						if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
							return ret
						}
						elem.setAttribute(name, value + "");
						return value
					}
					if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
						return ret
					}
					ret = jQuery.find.attr(elem, name);
					return ret == null ? undefined : ret
				},
				attrHooks: {
					type: {
						set: function (elem, value) {
							if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
								var val = elem.value;
								elem.setAttribute("type", value);
								if (val) {
									elem.value = val
								}
								return value
							}
						}
					}
				},
				removeAttr: function (elem, value) {
					var name, i = 0,
						attrNames = value && value.match(rnothtmlwhite);
					if (attrNames && elem.nodeType === 1) {
						while (name = attrNames[i++]) {
							elem.removeAttribute(name)
						}
					}
				}
			});
			boolHook = {
				set: function (elem, value, name) {
					if (value === false) {
						jQuery.removeAttr(elem, name)
					} else {
						elem.setAttribute(name, name)
					}
					return name
				}
			};
			jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (_i, name) {
				var getter = attrHandle[name] || jQuery.find.attr;
				attrHandle[name] = function (elem, name, isXML) {
					var ret, handle, lowercaseName = name.toLowerCase();
					if (!isXML) {
						handle = attrHandle[lowercaseName];
						attrHandle[lowercaseName] = ret;
						ret = getter(elem, name, isXML) != null ? lowercaseName : null;
						attrHandle[lowercaseName] = handle
					}
					return ret
				}
			});
			var rfocusable = /^(?:input|select|textarea|button)$/i,
				rclickable = /^(?:a|area)$/i;
			jQuery.fn.extend({
				prop: function (name, value) {
					return access(this, jQuery.prop, name, value, arguments.length > 1)
				},
				removeProp: function (name) {
					return this.each(function () {
						delete this[jQuery.propFix[name] || name]
					})
				}
			});
			jQuery.extend({
				prop: function (elem, name, value) {
					var ret, hooks, nType = elem.nodeType;
					if (nType === 3 || nType === 8 || nType === 2) {
						return
					}
					if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
						name = jQuery.propFix[name] || name;
						hooks = jQuery.propHooks[name]
					}
					if (value !== undefined) {
						if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
							return ret
						}
						return elem[name] = value
					}
					if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
						return ret
					}
					return elem[name]
				},
				propHooks: {
					tabIndex: {
						get: function (elem) {
							var tabindex = jQuery.find.attr(elem, "tabindex");
							if (tabindex) {
								return parseInt(tabindex, 10)
							}
							if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
								return 0
							}
							return -1
						}
					}
				},
				propFix: {
					for: "htmlFor",
					class: "className"
				}
			});
			if (!support.optSelected) {
				jQuery.propHooks.selected = {
					get: function (elem) {
						var parent = elem.parentNode;
						if (parent && parent.parentNode) {
							parent.parentNode.selectedIndex
						}
						return null
					},
					set: function (elem) {
						var parent = elem.parentNode;
						if (parent) {
							parent.selectedIndex;
							if (parent.parentNode) {
								parent.parentNode.selectedIndex
							}
						}
					}
				}
			}
			jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
				jQuery.propFix[this.toLowerCase()] = this
			});

			function stripAndCollapse(value) {
				var tokens = value.match(rnothtmlwhite) || [];
				return tokens.join(" ")
			}

			function getClass(elem) {
				return elem.getAttribute && elem.getAttribute("class") || ""
			}

			function classesToArray(value) {
				if (Array.isArray(value)) {
					return value
				}
				if (typeof value === "string") {
					return value.match(rnothtmlwhite) || []
				}
				return []
			}
			jQuery.fn.extend({
				addClass: function (value) {
					var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
					if (isFunction(value)) {
						return this.each(function (j) {
							jQuery(this).addClass(value.call(this, j, getClass(this)))
						})
					}
					classes = classesToArray(value);
					if (classes.length) {
						while (elem = this[i++]) {
							curValue = getClass(elem);
							cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
							if (cur) {
								j = 0;
								while (clazz = classes[j++]) {
									if (cur.indexOf(" " + clazz + " ") < 0) {
										cur += clazz + " "
									}
								}
								finalValue = stripAndCollapse(cur);
								if (curValue !== finalValue) {
									elem.setAttribute("class", finalValue)
								}
							}
						}
					}
					return this
				},
				removeClass: function (value) {
					var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
					if (isFunction(value)) {
						return this.each(function (j) {
							jQuery(this).removeClass(value.call(this, j, getClass(this)))
						})
					}
					if (!arguments.length) {
						return this.attr("class", "")
					}
					classes = classesToArray(value);
					if (classes.length) {
						while (elem = this[i++]) {
							curValue = getClass(elem);
							cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
							if (cur) {
								j = 0;
								while (clazz = classes[j++]) {
									while (cur.indexOf(" " + clazz + " ") > -1) {
										cur = cur.replace(" " + clazz + " ", " ")
									}
								}
								finalValue = stripAndCollapse(cur);
								if (curValue !== finalValue) {
									elem.setAttribute("class", finalValue)
								}
							}
						}
					}
					return this
				},
				toggleClass: function (value, stateVal) {
					var type = typeof value,
						isValidValue = type === "string" || Array.isArray(value);
					if (typeof stateVal === "boolean" && isValidValue) {
						return stateVal ? this.addClass(value) : this.removeClass(value)
					}
					if (isFunction(value)) {
						return this.each(function (i) {
							jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal)
						})
					}
					return this.each(function () {
						var className, i, self, classNames;
						if (isValidValue) {
							i = 0;
							self = jQuery(this);
							classNames = classesToArray(value);
							while (className = classNames[i++]) {
								if (self.hasClass(className)) {
									self.removeClass(className)
								} else {
									self.addClass(className)
								}
							}
						} else if (value === undefined || type === "boolean") {
							className = getClass(this);
							if (className) {
								dataPriv.set(this, "__className__", className)
							}
							if (this.setAttribute) {
								this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "")
							}
						}
					})
				},
				hasClass: function (selector) {
					var className, elem, i = 0;
					className = " " + selector + " ";
					while (elem = this[i++]) {
						if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
							return true
						}
					}
					return false
				}
			});
			var rreturn = /\r/g;
			jQuery.fn.extend({
				val: function (value) {
					var hooks, ret, valueIsFunction, elem = this[0];
					if (!arguments.length) {
						if (elem) {
							hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
							if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
								return ret
							}
							ret = elem.value;
							if (typeof ret === "string") {
								return ret.replace(rreturn, "")
							}
							return ret == null ? "" : ret
						}
						return
					}
					valueIsFunction = isFunction(value);
					return this.each(function (i) {
						var val;
						if (this.nodeType !== 1) {
							return
						}
						if (valueIsFunction) {
							val = value.call(this, i, jQuery(this).val())
						} else {
							val = value
						}
						if (val == null) {
							val = ""
						} else if (typeof val === "number") {
							val += ""
						} else if (Array.isArray(val)) {
							val = jQuery.map(val, function (value) {
								return value == null ? "" : value + ""
							})
						}
						hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
						if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
							this.value = val
						}
					})
				}
			});
			jQuery.extend({
				valHooks: {
					option: {
						get: function (elem) {
							var val = jQuery.find.attr(elem, "value");
							return val != null ? val : stripAndCollapse(jQuery.text(elem))
						}
					},
					select: {
						get: function (elem) {
							var value, option, i, options = elem.options,
								index = elem.selectedIndex,
								one = elem.type === "select-one",
								values = one ? null : [],
								max = one ? index + 1 : options.length;
							if (index < 0) {
								i = max
							} else {
								i = one ? index : 0
							}
							for (; i < max; i++) {
								option = options[i];
								if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
									value = jQuery(option).val();
									if (one) {
										return value
									}
									values.push(value)
								}
							}
							return values
						},
						set: function (elem, value) {
							var optionSet, option, options = elem.options,
								values = jQuery.makeArray(value),
								i = options.length;
							while (i--) {
								option = options[i];
								if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
									optionSet = true
								}
							}
							if (!optionSet) {
								elem.selectedIndex = -1
							}
							return values
						}
					}
				}
			});
			jQuery.each(["radio", "checkbox"], function () {
				jQuery.valHooks[this] = {
					set: function (elem, value) {
						if (Array.isArray(value)) {
							return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1
						}
					}
				};
				if (!support.checkOn) {
					jQuery.valHooks[this].get = function (elem) {
						return elem.getAttribute("value") === null ? "on" : elem.value
					}
				}
			});
			support.focusin = "onfocusin" in window;
			var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
				stopPropagationCallback = function (e) {
					e.stopPropagation()
				};
			jQuery.extend(jQuery.event, {
				trigger: function (event, data, elem, onlyHandlers) {
					var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document],
						type = hasOwn.call(event, "type") ? event.type : event,
						namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
					cur = lastElement = tmp = elem = elem || document;
					if (elem.nodeType === 3 || elem.nodeType === 8) {
						return
					}
					if (rfocusMorph.test(type + jQuery.event.triggered)) {
						return
					}
					if (type.indexOf(".") > -1) {
						namespaces = type.split(".");
						type = namespaces.shift();
						namespaces.sort()
					}
					ontype = type.indexOf(":") < 0 && "on" + type;
					event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
					event.isTrigger = onlyHandlers ? 2 : 3;
					event.namespace = namespaces.join(".");
					event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
					event.result = undefined;
					if (!event.target) {
						event.target = elem
					}
					data = data == null ? [event] : jQuery.makeArray(data, [event]);
					special = jQuery.event.special[type] || {};
					if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
						return
					}
					if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
						bubbleType = special.delegateType || type;
						if (!rfocusMorph.test(bubbleType + type)) {
							cur = cur.parentNode
						}
						for (; cur; cur = cur.parentNode) {
							eventPath.push(cur);
							tmp = cur
						}
						if (tmp === (elem.ownerDocument || document)) {
							eventPath.push(tmp.defaultView || tmp.parentWindow || window)
						}
					}
					i = 0;
					while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
						lastElement = cur;
						event.type = i > 1 ? bubbleType : special.bindType || type;
						handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");
						if (handle) {
							handle.apply(cur, data)
						}
						handle = ontype && cur[ontype];
						if (handle && handle.apply && acceptData(cur)) {
							event.result = handle.apply(cur, data);
							if (event.result === false) {
								event.preventDefault()
							}
						}
					}
					event.type = type;
					if (!onlyHandlers && !event.isDefaultPrevented()) {
						if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
							if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
								tmp = elem[ontype];
								if (tmp) {
									elem[ontype] = null
								}
								jQuery.event.triggered = type;
								if (event.isPropagationStopped()) {
									lastElement.addEventListener(type, stopPropagationCallback)
								}
								elem[type]();
								if (event.isPropagationStopped()) {
									lastElement.removeEventListener(type, stopPropagationCallback)
								}
								jQuery.event.triggered = undefined;
								if (tmp) {
									elem[ontype] = tmp
								}
							}
						}
					}
					return event.result
				},
				simulate: function (type, elem, event) {
					var e = jQuery.extend(new jQuery.Event, event, {
						type: type,
						isSimulated: true
					});
					jQuery.event.trigger(e, null, elem)
				}
			});
			jQuery.fn.extend({
				trigger: function (type, data) {
					return this.each(function () {
						jQuery.event.trigger(type, data, this)
					})
				},
				triggerHandler: function (type, data) {
					var elem = this[0];
					if (elem) {
						return jQuery.event.trigger(type, data, elem, true)
					}
				}
			});
			if (!support.focusin) {
				jQuery.each({
					focus: "focusin",
					blur: "focusout"
				}, function (orig, fix) {
					var handler = function (event) {
						jQuery.event.simulate(fix, event.target, jQuery.event.fix(event))
					};
					jQuery.event.special[fix] = {
						setup: function () {
							var doc = this.ownerDocument || this.document || this,
								attaches = dataPriv.access(doc, fix);
							if (!attaches) {
								doc.addEventListener(orig, handler, true)
							}
							dataPriv.access(doc, fix, (attaches || 0) + 1)
						},
						teardown: function () {
							var doc = this.ownerDocument || this.document || this,
								attaches = dataPriv.access(doc, fix) - 1;
							if (!attaches) {
								doc.removeEventListener(orig, handler, true);
								dataPriv.remove(doc, fix)
							} else {
								dataPriv.access(doc, fix, attaches)
							}
						}
					}
				})
			}
			var location = window.location;
			var nonce = {
				guid: Date.now()
			};
			var rquery = /\?/;
			jQuery.parseXML = function (data) {
				var xml, parserErrorElem;
				if (!data || typeof data !== "string") {
					return null
				}
				try {
					xml = (new window.DOMParser).parseFromString(data, "text/xml")
				} catch (e) {}
				parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
				if (!xml || parserErrorElem) {
					jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function (el) {
						return el.textContent
					}).join("\n") : data))
				}
				return xml
			};
			var rbracket = /\[\]$/,
				rCRLF = /\r?\n/g,
				rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
				rsubmittable = /^(?:input|select|textarea|keygen)/i;

			function buildParams(prefix, obj, traditional, add) {
				var name;
				if (Array.isArray(obj)) {
					jQuery.each(obj, function (i, v) {
						if (traditional || rbracket.test(prefix)) {
							add(prefix, v)
						} else {
							buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add)
						}
					})
				} else if (!traditional && toType(obj) === "object") {
					for (name in obj) {
						buildParams(prefix + "[" + name + "]", obj[name], traditional, add)
					}
				} else {
					add(prefix, obj)
				}
			}
			jQuery.param = function (a, traditional) {
				var prefix, s = [],
					add = function (key, valueOrFunction) {
						var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
						s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value)
					};
				if (a == null) {
					return ""
				}
				if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
					jQuery.each(a, function () {
						add(this.name, this.value)
					})
				} else {
					for (prefix in a) {
						buildParams(prefix, a[prefix], traditional, add)
					}
				}
				return s.join("&")
			};
			jQuery.fn.extend({
				serialize: function () {
					return jQuery.param(this.serializeArray())
				},
				serializeArray: function () {
					return this.map(function () {
						var elements = jQuery.prop(this, "elements");
						return elements ? jQuery.makeArray(elements) : this
					}).filter(function () {
						var type = this.type;
						return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type))
					}).map(function (_i, elem) {
						var val = jQuery(this).val();
						if (val == null) {
							return null
						}
						if (Array.isArray(val)) {
							return jQuery.map(val, function (val) {
								return {
									name: elem.name,
									value: val.replace(rCRLF, "\r\n")
								}
							})
						}
						return {
							name: elem.name,
							value: val.replace(rCRLF, "\r\n")
						}
					}).get()
				}
			});
			var r20 = /%20/g,
				rhash = /#.*$/,
				rantiCache = /([?&])_=[^&]*/,
				rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
				rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
				rnoContent = /^(?:GET|HEAD)$/,
				rprotocol = /^\/\//,
				prefilters = {},
				transports = {},
				allTypes = "*/".concat("*"),
				originAnchor = document.createElement("a");
			originAnchor.href = location.href;

			function addToPrefiltersOrTransports(structure) {
				return function (dataTypeExpression, func) {
					if (typeof dataTypeExpression !== "string") {
						func = dataTypeExpression;
						dataTypeExpression = "*"
					}
					var dataType, i = 0,
						dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
					if (isFunction(func)) {
						while (dataType = dataTypes[i++]) {
							if (dataType[0] === "+") {
								dataType = dataType.slice(1) || "*";
								(structure[dataType] = structure[dataType] || []).unshift(func)
							} else {
								(structure[dataType] = structure[dataType] || []).push(func)
							}
						}
					}
				}
			}

			function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
				var inspected = {},
					seekingTransport = structure === transports;

				function inspect(dataType) {
					var selected;
					inspected[dataType] = true;
					jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
						var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
						if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
							options.dataTypes.unshift(dataTypeOrTransport);
							inspect(dataTypeOrTransport);
							return false
						} else if (seekingTransport) {
							return !(selected = dataTypeOrTransport)
						}
					});
					return selected
				}
				return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*")
			}

			function ajaxExtend(target, src) {
				var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
				for (key in src) {
					if (src[key] !== undefined) {
						(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]
					}
				}
				if (deep) {
					jQuery.extend(true, target, deep)
				}
				return target
			}

			function ajaxHandleResponses(s, jqXHR, responses) {
				var ct, type, finalDataType, firstDataType, contents = s.contents,
					dataTypes = s.dataTypes;
				while (dataTypes[0] === "*") {
					dataTypes.shift();
					if (ct === undefined) {
						ct = s.mimeType || jqXHR.getResponseHeader("Content-Type")
					}
				}
				if (ct) {
					for (type in contents) {
						if (contents[type] && contents[type].test(ct)) {
							dataTypes.unshift(type);
							break
						}
					}
				}
				if (dataTypes[0] in responses) {
					finalDataType = dataTypes[0]
				} else {
					for (type in responses) {
						if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
							finalDataType = type;
							break
						}
						if (!firstDataType) {
							firstDataType = type
						}
					}
					finalDataType = finalDataType || firstDataType
				}
				if (finalDataType) {
					if (finalDataType !== dataTypes[0]) {
						dataTypes.unshift(finalDataType)
					}
					return responses[finalDataType]
				}
			}

			function ajaxConvert(s, response, jqXHR, isSuccess) {
				var conv2, current, conv, tmp, prev, converters = {},
					dataTypes = s.dataTypes.slice();
				if (dataTypes[1]) {
					for (conv in s.converters) {
						converters[conv.toLowerCase()] = s.converters[conv]
					}
				}
				current = dataTypes.shift();
				while (current) {
					if (s.responseFields[current]) {
						jqXHR[s.responseFields[current]] = response
					}
					if (!prev && isSuccess && s.dataFilter) {
						response = s.dataFilter(response, s.dataType)
					}
					prev = current;
					current = dataTypes.shift();
					if (current) {
						if (current === "*") {
							current = prev
						} else if (prev !== "*" && prev !== current) {
							conv = converters[prev + " " + current] || converters["* " + current];
							if (!conv) {
								for (conv2 in converters) {
									tmp = conv2.split(" ");
									if (tmp[1] === current) {
										conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
										if (conv) {
											if (conv === true) {
												conv = converters[conv2]
											} else if (converters[conv2] !== true) {
												current = tmp[0];
												dataTypes.unshift(tmp[1])
											}
											break
										}
									}
								}
							}
							if (conv !== true) {
								if (conv && s.throws) {
									response = conv(response)
								} else {
									try {
										response = conv(response)
									} catch (e) {
										return {
											state: "parsererror",
											error: conv ? e : "No conversion from " + prev + " to " + current
										}
									}
								}
							}
						}
					}
				}
				return {
					state: "success",
					data: response
				}
			}
			jQuery.extend({
				active: 0,
				lastModified: {},
				etag: {},
				ajaxSettings: {
					url: location.href,
					type: "GET",
					isLocal: rlocalProtocol.test(location.protocol),
					global: true,
					processData: true,
					async: true,
					contentType: "application/x-www-form-urlencoded; charset=UTF-8",
					accepts: {
						"*": allTypes,
						text: "text/plain",
						html: "text/html",
						xml: "application/xml, text/xml",
						json: "application/json, text/javascript"
					},
					contents: {
						xml: /\bxml\b/,
						html: /\bhtml/,
						json: /\bjson\b/
					},
					responseFields: {
						xml: "responseXML",
						text: "responseText",
						json: "responseJSON"
					},
					converters: {
						"* text": String,
						"text html": true,
						"text json": JSON.parse,
						"text xml": jQuery.parseXML
					},
					flatOptions: {
						url: true,
						context: true
					}
				},
				ajaxSetup: function (target, settings) {
					return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target)
				},
				ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
				ajaxTransport: addToPrefiltersOrTransports(transports),
				ajax: function (url, options) {
					if (typeof url === "object") {
						options = url;
						url = undefined
					}
					options = options || {};
					var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options),
						callbackContext = s.context || s,
						globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
						deferred = jQuery.Deferred(),
						completeDeferred = jQuery.Callbacks("once memory"),
						statusCode = s.statusCode || {},
						requestHeaders = {},
						requestHeadersNames = {},
						strAbort = "canceled",
						jqXHR = {
							readyState: 0,
							getResponseHeader: function (key) {
								var match;
								if (completed) {
									if (!responseHeaders) {
										responseHeaders = {};
										while (match = rheaders.exec(responseHeadersString)) {
											responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2])
										}
									}
									match = responseHeaders[key.toLowerCase() + " "]
								}
								return match == null ? null : match.join(", ")
							},
							getAllResponseHeaders: function () {
								return completed ? responseHeadersString : null
							},
							setRequestHeader: function (name, value) {
								if (completed == null) {
									name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
									requestHeaders[name] = value
								}
								return this
							},
							overrideMimeType: function (type) {
								if (completed == null) {
									s.mimeType = type
								}
								return this
							},
							statusCode: function (map) {
								var code;
								if (map) {
									if (completed) {
										jqXHR.always(map[jqXHR.status])
									} else {
										for (code in map) {
											statusCode[code] = [statusCode[code], map[code]]
										}
									}
								}
								return this
							},
							abort: function (statusText) {
								var finalText = statusText || strAbort;
								if (transport) {
									transport.abort(finalText)
								}
								done(0, finalText);
								return this
							}
						};
					deferred.promise(jqXHR);
					s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
					s.type = options.method || options.type || s.method || s.type;
					s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
					if (s.crossDomain == null) {
						urlAnchor = document.createElement("a");
						try {
							urlAnchor.href = s.url;
							urlAnchor.href = urlAnchor.href;
							s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host
						} catch (e) {
							s.crossDomain = true
						}
					}
					if (s.data && s.processData && typeof s.data !== "string") {
						s.data = jQuery.param(s.data, s.traditional)
					}
					inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
					if (completed) {
						return jqXHR
					}
					fireGlobals = jQuery.event && s.global;
					if (fireGlobals && jQuery.active++ === 0) {
						jQuery.event.trigger("ajaxStart")
					}
					s.type = s.type.toUpperCase();
					s.hasContent = !rnoContent.test(s.type);
					cacheURL = s.url.replace(rhash, "");
					if (!s.hasContent) {
						uncached = s.url.slice(cacheURL.length);
						if (s.data && (s.processData || typeof s.data === "string")) {
							cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
							delete s.data
						}
						if (s.cache === false) {
							cacheURL = cacheURL.replace(rantiCache, "$1");
							uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached
						}
						s.url = cacheURL + uncached
					} else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
						s.data = s.data.replace(r20, "+")
					}
					if (s.ifModified) {
						if (jQuery.lastModified[cacheURL]) {
							jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL])
						}
						if (jQuery.etag[cacheURL]) {
							jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])
						}
					}
					if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
						jqXHR.setRequestHeader("Content-Type", s.contentType)
					}
					jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
					for (i in s.headers) {
						jqXHR.setRequestHeader(i, s.headers[i])
					}
					if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
						return jqXHR.abort()
					}
					strAbort = "abort";
					completeDeferred.add(s.complete);
					jqXHR.done(s.success);
					jqXHR.fail(s.error);
					transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
					if (!transport) {
						done(-1, "No Transport")
					} else {
						jqXHR.readyState = 1;
						if (fireGlobals) {
							globalEventContext.trigger("ajaxSend", [jqXHR, s])
						}
						if (completed) {
							return jqXHR
						}
						if (s.async && s.timeout > 0) {
							timeoutTimer = window.setTimeout(function () {
								jqXHR.abort("timeout")
							}, s.timeout)
						}
						try {
							completed = false;
							transport.send(requestHeaders, done)
						} catch (e) {
							if (completed) {
								throw e
							}
							done(-1, e)
						}
					}

					function done(status, nativeStatusText, responses, headers) {
						var isSuccess, success, error, response, modified, statusText = nativeStatusText;
						if (completed) {
							return
						}
						completed = true;
						if (timeoutTimer) {
							window.clearTimeout(timeoutTimer)
						}
						transport = undefined;
						responseHeadersString = headers || "";
						jqXHR.readyState = status > 0 ? 4 : 0;
						isSuccess = status >= 200 && status < 300 || status === 304;
						if (responses) {
							response = ajaxHandleResponses(s, jqXHR, responses)
						}
						if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
							s.converters["text script"] = function () {}
						}
						response = ajaxConvert(s, response, jqXHR, isSuccess);
						if (isSuccess) {
							if (s.ifModified) {
								modified = jqXHR.getResponseHeader("Last-Modified");
								if (modified) {
									jQuery.lastModified[cacheURL] = modified
								}
								modified = jqXHR.getResponseHeader("etag");
								if (modified) {
									jQuery.etag[cacheURL] = modified
								}
							}
							if (status === 204 || s.type === "HEAD") {
								statusText = "nocontent"
							} else if (status === 304) {
								statusText = "notmodified"
							} else {
								statusText = response.state;
								success = response.data;
								error = response.error;
								isSuccess = !error
							}
						} else {
							error = statusText;
							if (status || !statusText) {
								statusText = "error";
								if (status < 0) {
									status = 0
								}
							}
						}
						jqXHR.status = status;
						jqXHR.statusText = (nativeStatusText || statusText) + "";
						if (isSuccess) {
							deferred.resolveWith(callbackContext, [success, statusText, jqXHR])
						} else {
							deferred.rejectWith(callbackContext, [jqXHR, statusText, error])
						}
						jqXHR.statusCode(statusCode);
						statusCode = undefined;
						if (fireGlobals) {
							globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error])
						}
						completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
						if (fireGlobals) {
							globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
							if (!--jQuery.active) {
								jQuery.event.trigger("ajaxStop")
							}
						}
					}
					return jqXHR
				},
				getJSON: function (url, data, callback) {
					return jQuery.get(url, data, callback, "json")
				},
				getScript: function (url, callback) {
					return jQuery.get(url, undefined, callback, "script")
				}
			});
			jQuery.each(["get", "post"], function (_i, method) {
				jQuery[method] = function (url, data, callback, type) {
					if (isFunction(data)) {
						type = type || callback;
						callback = data;
						data = undefined
					}
					return jQuery.ajax(jQuery.extend({
						url: url,
						type: method,
						dataType: type,
						data: data,
						success: callback
					}, jQuery.isPlainObject(url) && url))
				}
			});
			jQuery.ajaxPrefilter(function (s) {
				var i;
				for (i in s.headers) {
					if (i.toLowerCase() === "content-type") {
						s.contentType = s.headers[i] || ""
					}
				}
			});
			jQuery._evalUrl = function (url, options, doc) {
				return jQuery.ajax({
					url: url,
					type: "GET",
					dataType: "script",
					cache: true,
					async: false,
					global: false,
					converters: {
						"text script": function () {}
					},
					dataFilter: function (response) {
						jQuery.globalEval(response, options, doc)
					}
				})
			};
			jQuery.fn.extend({
				wrapAll: function (html) {
					var wrap;
					if (this[0]) {
						if (isFunction(html)) {
							html = html.call(this[0])
						}
						wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
						if (this[0].parentNode) {
							wrap.insertBefore(this[0])
						}
						wrap.map(function () {
							var elem = this;
							while (elem.firstElementChild) {
								elem = elem.firstElementChild
							}
							return elem
						}).append(this)
					}
					return this
				},
				wrapInner: function (html) {
					if (isFunction(html)) {
						return this.each(function (i) {
							jQuery(this).wrapInner(html.call(this, i))
						})
					}
					return this.each(function () {
						var self = jQuery(this),
							contents = self.contents();
						if (contents.length) {
							contents.wrapAll(html)
						} else {
							self.append(html)
						}
					})
				},
				wrap: function (html) {
					var htmlIsFunction = isFunction(html);
					return this.each(function (i) {
						jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html)
					})
				},
				unwrap: function (selector) {
					this.parent(selector).not("body").each(function () {
						jQuery(this).replaceWith(this.childNodes)
					});
					return this
				}
			});
			jQuery.expr.pseudos.hidden = function (elem) {
				return !jQuery.expr.pseudos.visible(elem)
			};
			jQuery.expr.pseudos.visible = function (elem) {
				return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length)
			};
			jQuery.ajaxSettings.xhr = function () {
				try {
					return new window.XMLHttpRequest
				} catch (e) {}
			};
			var xhrSuccessStatus = {
					0: 200,
					1223: 204
				},
				xhrSupported = jQuery.ajaxSettings.xhr();
			support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
			support.ajax = xhrSupported = !!xhrSupported;
			jQuery.ajaxTransport(function (options) {
				var callback, errorCallback;
				if (support.cors || xhrSupported && !options.crossDomain) {
					return {
						send: function (headers, complete) {
							var i, xhr = options.xhr();
							xhr.open(options.type, options.url, options.async, options.username, options.password);
							if (options.xhrFields) {
								for (i in options.xhrFields) {
									xhr[i] = options.xhrFields[i]
								}
							}
							if (options.mimeType && xhr.overrideMimeType) {
								xhr.overrideMimeType(options.mimeType)
							}
							if (!options.crossDomain && !headers["X-Requested-With"]) {
								headers["X-Requested-With"] = "XMLHttpRequest"
							}
							for (i in headers) {
								xhr.setRequestHeader(i, headers[i])
							}
							callback = function (type) {
								return function () {
									if (callback) {
										callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
										if (type === "abort") {
											xhr.abort()
										} else if (type === "error") {
											if (typeof xhr.status !== "number") {
												complete(0, "error")
											} else {
												complete(xhr.status, xhr.statusText)
											}
										} else {
											complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
												binary: xhr.response
											} : {
												text: xhr.responseText
											}, xhr.getAllResponseHeaders())
										}
									}
								}
							};
							xhr.onload = callback();
							errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
							if (xhr.onabort !== undefined) {
								xhr.onabort = errorCallback
							} else {
								xhr.onreadystatechange = function () {
									if (xhr.readyState === 4) {
										window.setTimeout(function () {
											if (callback) {
												errorCallback()
											}
										})
									}
								}
							}
							callback = callback("abort");
							try {
								xhr.send(options.hasContent && options.data || null)
							} catch (e) {
								if (callback) {
									throw e
								}
							}
						},
						abort: function () {
							if (callback) {
								callback()
							}
						}
					}
				}
			});
			jQuery.ajaxPrefilter(function (s) {
				if (s.crossDomain) {
					s.contents.script = false
				}
			});
			jQuery.ajaxSetup({
				accepts: {
					script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
				},
				contents: {
					script: /\b(?:java|ecma)script\b/
				},
				converters: {
					"text script": function (text) {
						jQuery.globalEval(text);
						return text
					}
				}
			});
			jQuery.ajaxPrefilter("script", function (s) {
				if (s.cache === undefined) {
					s.cache = false
				}
				if (s.crossDomain) {
					s.type = "GET"
				}
			});
			jQuery.ajaxTransport("script", function (s) {
				if (s.crossDomain || s.scriptAttrs) {
					var script, callback;
					return {
						send: function (_, complete) {
							script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
								charset: s.scriptCharset,
								src: s.url
							}).on("load error", callback = function (evt) {
								script.remove();
								callback = null;
								if (evt) {
									complete(evt.type === "error" ? 404 : 200, evt.type)
								}
							});
							document.head.appendChild(script[0])
						},
						abort: function () {
							if (callback) {
								callback()
							}
						}
					}
				}
			});
			var oldCallbacks = [],
				rjsonp = /(=)\?(?=&|$)|\?\?/;
			jQuery.ajaxSetup({
				jsonp: "callback",
				jsonpCallback: function () {
					var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
					this[callback] = true;
					return callback
				}
			});
			jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
				var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
				if (jsonProp || s.dataTypes[0] === "jsonp") {
					callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
					if (jsonProp) {
						s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName)
					} else if (s.jsonp !== false) {
						s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName
					}
					s.converters["script json"] = function () {
						if (!responseContainer) {
							jQuery.error(callbackName + " was not called")
						}
						return responseContainer[0]
					};
					s.dataTypes[0] = "json";
					overwritten = window[callbackName];
					window[callbackName] = function () {
						responseContainer = arguments
					};
					jqXHR.always(function () {
						if (overwritten === undefined) {
							jQuery(window).removeProp(callbackName)
						} else {
							window[callbackName] = overwritten
						}
						if (s[callbackName]) {
							s.jsonpCallback = originalSettings.jsonpCallback;
							oldCallbacks.push(callbackName)
						}
						if (responseContainer && isFunction(overwritten)) {
							overwritten(responseContainer[0])
						}
						responseContainer = overwritten = undefined
					});
					return "script"
				}
			});
			support.createHTMLDocument = function () {
				var body = document.implementation.createHTMLDocument("").body;
				body.innerHTML = "<form></form><form></form>";
				return body.childNodes.length === 2
			}();
			jQuery.parseHTML = function (data, context, keepScripts) {
				if (typeof data !== "string") {
					return []
				}
				if (typeof context === "boolean") {
					keepScripts = context;
					context = false
				}
				var base, parsed, scripts;
				if (!context) {
					if (support.createHTMLDocument) {
						context = document.implementation.createHTMLDocument("");
						base = context.createElement("base");
						base.href = document.location.href;
						context.head.appendChild(base)
					} else {
						context = document
					}
				}
				parsed = rsingleTag.exec(data);
				scripts = !keepScripts && [];
				if (parsed) {
					return [context.createElement(parsed[1])]
				}
				parsed = buildFragment([data], context, scripts);
				if (scripts && scripts.length) {
					jQuery(scripts).remove()
				}
				return jQuery.merge([], parsed.childNodes)
			};
			jQuery.fn.load = function (url, params, callback) {
				var selector, type, response, self = this,
					off = url.indexOf(" ");
				if (off > -1) {
					selector = stripAndCollapse(url.slice(off));
					url = url.slice(0, off)
				}
				if (isFunction(params)) {
					callback = params;
					params = undefined
				} else if (params && typeof params === "object") {
					type = "POST"
				}
				if (self.length > 0) {
					jQuery.ajax({
						url: url,
						type: type || "GET",
						dataType: "html",
						data: params
					}).done(function (responseText) {
						response = arguments;
						self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText)
					}).always(callback && function (jqXHR, status) {
						self.each(function () {
							callback.apply(this, response || [jqXHR.responseText, status, jqXHR])
						})
					})
				}
				return this
			};
			jQuery.expr.pseudos.animated = function (elem) {
				return jQuery.grep(jQuery.timers, function (fn) {
					return elem === fn.elem
				}).length
			};
			jQuery.offset = {
				setOffset: function (elem, options, i) {
					var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"),
						curElem = jQuery(elem),
						props = {};
					if (position === "static") {
						elem.style.position = "relative"
					}
					curOffset = curElem.offset();
					curCSSTop = jQuery.css(elem, "top");
					curCSSLeft = jQuery.css(elem, "left");
					calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
					if (calculatePosition) {
						curPosition = curElem.position();
						curTop = curPosition.top;
						curLeft = curPosition.left
					} else {
						curTop = parseFloat(curCSSTop) || 0;
						curLeft = parseFloat(curCSSLeft) || 0
					}
					if (isFunction(options)) {
						options = options.call(elem, i, jQuery.extend({}, curOffset))
					}
					if (options.top != null) {
						props.top = options.top - curOffset.top + curTop
					}
					if (options.left != null) {
						props.left = options.left - curOffset.left + curLeft
					}
					if ("using" in options) {
						options.using.call(elem, props)
					} else {
						curElem.css(props)
					}
				}
			};
			jQuery.fn.extend({
				offset: function (options) {
					if (arguments.length) {
						return options === undefined ? this : this.each(function (i) {
							jQuery.offset.setOffset(this, options, i)
						})
					}
					var rect, win, elem = this[0];
					if (!elem) {
						return
					}
					if (!elem.getClientRects().length) {
						return {
							top: 0,
							left: 0
						}
					}
					rect = elem.getBoundingClientRect();
					win = elem.ownerDocument.defaultView;
					return {
						top: rect.top + win.pageYOffset,
						left: rect.left + win.pageXOffset
					}
				},
				position: function () {
					if (!this[0]) {
						return
					}
					var offsetParent, offset, doc, elem = this[0],
						parentOffset = {
							top: 0,
							left: 0
						};
					if (jQuery.css(elem, "position") === "fixed") {
						offset = elem.getBoundingClientRect()
					} else {
						offset = this.offset();
						doc = elem.ownerDocument;
						offsetParent = elem.offsetParent || doc.documentElement;
						while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
							offsetParent = offsetParent.parentNode
						}
						if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
							parentOffset = jQuery(offsetParent).offset();
							parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
							parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true)
						}
					}
					return {
						top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
						left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
					}
				},
				offsetParent: function () {
					return this.map(function () {
						var offsetParent = this.offsetParent;
						while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
							offsetParent = offsetParent.offsetParent
						}
						return offsetParent || documentElement
					})
				}
			});
			jQuery.each({
				scrollLeft: "pageXOffset",
				scrollTop: "pageYOffset"
			}, function (method, prop) {
				var top = "pageYOffset" === prop;
				jQuery.fn[method] = function (val) {
					return access(this, function (elem, method, val) {
						var win;
						if (isWindow(elem)) {
							win = elem
						} else if (elem.nodeType === 9) {
							win = elem.defaultView
						}
						if (val === undefined) {
							return win ? win[prop] : elem[method]
						}
						if (win) {
							win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset)
						} else {
							elem[method] = val
						}
					}, method, val, arguments.length)
				}
			});
			jQuery.each(["top", "left"], function (_i, prop) {
				jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
					if (computed) {
						computed = curCSS(elem, prop);
						return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed
					}
				})
			});
			jQuery.each({
				Height: "height",
				Width: "width"
			}, function (name, type) {
				jQuery.each({
					padding: "inner" + name,
					content: type,
					"": "outer" + name
				}, function (defaultExtra, funcName) {
					jQuery.fn[funcName] = function (margin, value) {
						var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
							extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
						return access(this, function (elem, type, value) {
							var doc;
							if (isWindow(elem)) {
								return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name]
							}
							if (elem.nodeType === 9) {
								doc = elem.documentElement;
								return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])
							}
							return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra)
						}, type, chainable ? margin : undefined, chainable)
					}
				})
			});
			jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (_i, type) {
				jQuery.fn[type] = function (fn) {
					return this.on(type, fn)
				}
			});
			jQuery.fn.extend({
				bind: function (types, data, fn) {
					return this.on(types, null, data, fn)
				},
				unbind: function (types, fn) {
					return this.off(types, null, fn)
				},
				delegate: function (selector, types, data, fn) {
					return this.on(types, selector, data, fn)
				},
				undelegate: function (selector, types, fn) {
					return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn)
				},
				hover: function (fnOver, fnOut) {
					return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
				}
			});
			jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (_i, name) {
				jQuery.fn[name] = function (data, fn) {
					return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name)
				}
			});
			var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
			jQuery.proxy = function (fn, context) {
				var tmp, args, proxy;
				if (typeof context === "string") {
					tmp = fn[context];
					context = fn;
					fn = tmp
				}
				if (!isFunction(fn)) {
					return undefined
				}
				args = slice.call(arguments, 2);
				proxy = function () {
					return fn.apply(context || this, args.concat(slice.call(arguments)))
				};
				proxy.guid = fn.guid = fn.guid || jQuery.guid++;
				return proxy
			};
			jQuery.holdReady = function (hold) {
				if (hold) {
					jQuery.readyWait++
				} else {
					jQuery.ready(true)
				}
			};
			jQuery.isArray = Array.isArray;
			jQuery.parseJSON = JSON.parse;
			jQuery.nodeName = nodeName;
			jQuery.isFunction = isFunction;
			jQuery.isWindow = isWindow;
			jQuery.camelCase = camelCase;
			jQuery.type = toType;
			jQuery.now = Date.now;
			jQuery.isNumeric = function (obj) {
				var type = jQuery.type(obj);
				return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj))
			};
			jQuery.trim = function (text) {
				return text == null ? "" : (text + "").replace(rtrim, "")
			};
			if (typeof define === "function" && define.amd) {
				define("jquery", [], function () {
					return jQuery
				})
			}
			var _jQuery = window.jQuery,
				_$ = window.$;
			jQuery.noConflict = function (deep) {
				if (window.$ === jQuery) {
					window.$ = _$
				}
				if (deep && window.jQuery === jQuery) {
					window.jQuery = _jQuery
				}
				return jQuery
			};
			if (typeof noGlobal === "undefined") {
				window.jQuery = window.$ = jQuery
			}
			return jQuery
		})
	}, {}],
	41: [function (require, module, exports) {
		(function (root, factory) {
			"use strict";
			var moment;
			if (typeof exports === "object") {
				try {
					moment = require("moment")
				} catch (e) {}
				module.exports = factory(moment)
			} else if (typeof define === "function" && define.amd) {
				define(function (req) {
					var id = "moment";
					try {
						moment = req(id)
					} catch (e) {}
					return factory(moment)
				})
			} else {
				root.Pikaday = factory(root.moment)
			}
		})(this, function (moment) {
			"use strict";
			var hasMoment = typeof moment === "function",
				hasEventListeners = !!window.addEventListener,
				document = window.document,
				sto = window.setTimeout,
				addEvent = function (el, e, callback, capture) {
					if (hasEventListeners) {
						el.addEventListener(e, callback, !!capture)
					} else {
						el.attachEvent("on" + e, callback)
					}
				},
				removeEvent = function (el, e, callback, capture) {
					if (hasEventListeners) {
						el.removeEventListener(e, callback, !!capture)
					} else {
						el.detachEvent("on" + e, callback)
					}
				},
				trim = function (str) {
					return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "")
				},
				hasClass = function (el, cn) {
					return (" " + el.className + " ").indexOf(" " + cn + " ") !== -1
				},
				addClass = function (el, cn) {
					if (!hasClass(el, cn)) {
						el.className = el.className === "" ? cn : el.className + " " + cn
					}
				},
				removeClass = function (el, cn) {
					el.className = trim((" " + el.className + " ").replace(" " + cn + " ", " "))
				},
				isArray = function (obj) {
					return /Array/.test(Object.prototype.toString.call(obj))
				},
				isDate = function (obj) {
					return /Date/.test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime())
				},
				isWeekend = function (date) {
					var day = date.getDay();
					return day === 0 || day === 6
				},
				isLeapYear = function (year) {
					return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0
				},
				getDaysInMonth = function (year, month) {
					return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month]
				},
				setToStartOfDay = function (date) {
					if (isDate(date)) date.setHours(0, 0, 0, 0)
				},
				compareDates = function (a, b) {
					return a.getTime() === b.getTime()
				},
				extend = function (to, from, overwrite) {
					var prop, hasProp;
					for (prop in from) {
						hasProp = to[prop] !== undefined;
						if (hasProp && typeof from[prop] === "object" && from[prop] !== null && from[prop].nodeName === undefined) {
							if (isDate(from[prop])) {
								if (overwrite) {
									to[prop] = new Date(from[prop].getTime())
								}
							} else if (isArray(from[prop])) {
								if (overwrite) {
									to[prop] = from[prop].slice(0)
								}
							} else {
								to[prop] = extend({}, from[prop], overwrite)
							}
						} else if (overwrite || !hasProp) {
							to[prop] = from[prop]
						}
					}
					return to
				},
				fireEvent = function (el, eventName, data) {
					var ev;
					if (document.createEvent) {
						ev = document.createEvent("HTMLEvents");
						ev.initEvent(eventName, true, false);
						ev = extend(ev, data);
						el.dispatchEvent(ev)
					} else if (document.createEventObject) {
						ev = document.createEventObject();
						ev = extend(ev, data);
						el.fireEvent("on" + eventName, ev)
					}
				},
				adjustCalendar = function (calendar) {
					if (calendar.month < 0) {
						calendar.year -= Math.ceil(Math.abs(calendar.month) / 12);
						calendar.month += 12
					}
					if (calendar.month > 11) {
						calendar.year += Math.floor(Math.abs(calendar.month) / 12);
						calendar.month -= 12
					}
					return calendar
				},
				defaults = {
					field: null,
					bound: undefined,
					ariaLabel: "Use the arrow keys to pick a date",
					position: "bottom left",
					reposition: true,
					format: "YYYY-MM-DD",
					toString: null,
					parse: null,
					defaultDate: null,
					setDefaultDate: false,
					firstDay: 0,
					firstWeekOfYearMinDays: 4,
					formatStrict: false,
					minDate: null,
					maxDate: null,
					yearRange: 10,
					showWeekNumber: false,
					pickWholeWeek: false,
					minYear: 0,
					maxYear: 9999,
					minMonth: undefined,
					maxMonth: undefined,
					startRange: null,
					endRange: null,
					isRTL: false,
					yearSuffix: "",
					showMonthAfterYear: false,
					showDaysInNextAndPreviousMonths: false,
					enableSelectionDaysInNextAndPreviousMonths: false,
					numberOfMonths: 1,
					mainCalendar: "left",
					container: undefined,
					blurFieldOnSelect: true,
					i18n: {
						previousMonth: "Previous Month",
						nextMonth: "Next Month",
						months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
						weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
						weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
					},
					theme: null,
					events: [],
					onSelect: null,
					onOpen: null,
					onClose: null,
					onDraw: null,
					keyboardInput: true
				},
				renderDayName = function (opts, day, abbr) {
					day += opts.firstDay;
					while (day >= 7) {
						day -= 7
					}
					return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day]
				},
				renderDay = function (opts) {
					var arr = [];
					var ariaSelected = "false";
					if (opts.isEmpty) {
						if (opts.showDaysInNextAndPreviousMonths) {
							arr.push("is-outside-current-month");
							if (!opts.enableSelectionDaysInNextAndPreviousMonths) {
								arr.push("is-selection-disabled")
							}
						} else {
							return '<td class="is-empty"></td>'
						}
					}
					if (opts.isDisabled) {
						arr.push("is-disabled")
					}
					if (opts.isToday) {
						arr.push("is-today")
					}
					if (opts.isSelected) {
						arr.push("is-selected");
						ariaSelected = "true"
					}
					if (opts.hasEvent) {
						arr.push("has-event")
					}
					if (opts.isInRange) {
						arr.push("is-inrange")
					}
					if (opts.isStartRange) {
						arr.push("is-startrange")
					}
					if (opts.isEndRange) {
						arr.push("is-endrange")
					}
					return '<td data-day="' + opts.day + '" class="' + arr.join(" ") + '" aria-selected="' + ariaSelected + '">' + '<button class="pika-button pika-day" type="button" ' + 'data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' + opts.day + "</button>" + "</td>"
				},
				isoWeek = function (date, firstWeekOfYearMinDays) {
					date.setHours(0, 0, 0, 0);
					var yearDay = date.getDate(),
						weekDay = date.getDay(),
						dayInFirstWeek = firstWeekOfYearMinDays,
						dayShift = dayInFirstWeek - 1,
						daysPerWeek = 7,
						prevWeekDay = function (day) {
							return (day + daysPerWeek - 1) % daysPerWeek
						};
					date.setDate(yearDay + dayShift - prevWeekDay(weekDay));
					var jan4th = new Date(date.getFullYear(), 0, dayInFirstWeek),
						msPerDay = 24 * 60 * 60 * 1e3,
						daysBetween = (date.getTime() - jan4th.getTime()) / msPerDay,
						weekNum = 1 + Math.round((daysBetween - dayShift + prevWeekDay(jan4th.getDay())) / daysPerWeek);
					return weekNum
				},
				renderWeek = function (d, m, y, firstWeekOfYearMinDays) {
					var date = new Date(y, m, d),
						week = hasMoment ? moment(date).isoWeek() : isoWeek(date, firstWeekOfYearMinDays);
					return '<td class="pika-week">' + week + "</td>"
				},
				renderRow = function (days, isRTL, pickWholeWeek, isRowSelected) {
					return '<tr class="pika-row' + (pickWholeWeek ? " pick-whole-week" : "") + (isRowSelected ? " is-selected" : "") + '">' + (isRTL ? days.reverse() : days).join("") + "</tr>"
				},
				renderBody = function (rows) {
					return "<tbody>" + rows.join("") + "</tbody>"
				},
				renderHead = function (opts) {
					var i, arr = [];
					if (opts.showWeekNumber) {
						arr.push("<th></th>")
					}
					for (i = 0; i < 7; i++) {
						arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + "</abbr></th>")
					}
					return "<thead><tr>" + (opts.isRTL ? arr.reverse() : arr).join("") + "</tr></thead>"
				},
				renderTitle = function (instance, c, year, month, refYear, randId) {
					var i, j, arr, opts = instance._o,
						isMinYear = year === opts.minYear,
						isMaxYear = year === opts.maxYear,
						html = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">',
						monthHtml, yearHtml, prev = true,
						next = true;
					for (arr = [], i = 0; i < 12; i++) {
						arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' + (i === month ? ' selected="selected"' : "") + (isMinYear && i < opts.minMonth || isMaxYear && i > opts.maxMonth ? ' disabled="disabled"' : "") + ">" + opts.i18n.months[i] + "</option>")
					}
					monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join("") + "</select></div>";
					if (isArray(opts.yearRange)) {
						i = opts.yearRange[0];
						j = opts.yearRange[1] + 1
					} else {
						i = year - opts.yearRange;
						j = 1 + year + opts.yearRange
					}
					for (arr = []; i < j && i <= opts.maxYear; i++) {
						if (i >= opts.minYear) {
							arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"' : "") + ">" + i + "</option>")
						}
					}
					yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join("") + "</select></div>";
					if (opts.showMonthAfterYear) {
						html += yearHtml + monthHtml
					} else {
						html += monthHtml + yearHtml
					}
					if (isMinYear && (month === 0 || opts.minMonth >= month)) {
						prev = false
					}
					if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
						next = false
					}
					if (c === 0) {
						html += '<button class="pika-prev' + (prev ? "" : " is-disabled") + '" type="button">' + opts.i18n.previousMonth + "</button>"
					}
					if (c === instance._o.numberOfMonths - 1) {
						html += '<button class="pika-next' + (next ? "" : " is-disabled") + '" type="button">' + opts.i18n.nextMonth + "</button>"
					}
					return html += "</div>"
				},
				renderTable = function (opts, data, randId) {
					return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + "</table>"
				},
				Pikaday = function (options) {
					var self = this,
						opts = self.config(options);
					self._onMouseDown = function (e) {
						if (!self._v) {
							return
						}
						e = e || window.event;
						var target = e.target || e.srcElement;
						if (!target) {
							return
						}
						if (!hasClass(target, "is-disabled")) {
							if (hasClass(target, "pika-button") && !hasClass(target, "is-empty") && !hasClass(target.parentNode, "is-disabled")) {
								self.setDate(new Date(target.getAttribute("data-pika-year"), target.getAttribute("data-pika-month"), target.getAttribute("data-pika-day")));
								if (opts.bound) {
									sto(function () {
										self.hide();
										if (opts.blurFieldOnSelect && opts.field) {
											opts.field.blur()
										}
									}, 100)
								}
							} else if (hasClass(target, "pika-prev")) {
								self.prevMonth()
							} else if (hasClass(target, "pika-next")) {
								self.nextMonth()
							}
						}
						if (!hasClass(target, "pika-select")) {
							if (e.preventDefault) {
								e.preventDefault()
							} else {
								e.returnValue = false;
								return false
							}
						} else {
							self._c = true
						}
					};
					self._onChange = function (e) {
						e = e || window.event;
						var target = e.target || e.srcElement;
						if (!target) {
							return
						}
						if (hasClass(target, "pika-select-month")) {
							self.gotoMonth(target.value)
						} else if (hasClass(target, "pika-select-year")) {
							self.gotoYear(target.value)
						}
					};
					self._onKeyChange = function (e) {
						e = e || window.event;
						if (self.isVisible()) {
							switch (e.keyCode) {
								case 13:
								case 27:
									if (opts.field) {
										opts.field.blur()
									}
									break;
								case 37:
									self.adjustDate("subtract", 1);
									break;
								case 38:
									self.adjustDate("subtract", 7);
									break;
								case 39:
									self.adjustDate("add", 1);
									break;
								case 40:
									self.adjustDate("add", 7);
									break;
								case 8:
								case 46:
									self.setDate(null);
									break
							}
						}
					};
					self._parseFieldValue = function () {
						if (opts.parse) {
							return opts.parse(opts.field.value, opts.format)
						} else if (hasMoment) {
							var date = moment(opts.field.value, opts.format, opts.formatStrict);
							return date && date.isValid() ? date.toDate() : null
						} else {
							return new Date(Date.parse(opts.field.value))
						}
					};
					self._onInputChange = function (e) {
						var date;
						if (e.firedBy === self) {
							return
						}
						date = self._parseFieldValue();
						if (isDate(date)) {
							self.setDate(date)
						}
						if (!self._v) {
							self.show()
						}
					};
					self._onInputFocus = function () {
						self.show()
					};
					self._onInputClick = function () {
						self.show()
					};
					self._onInputBlur = function () {
						var pEl = document.activeElement;
						do {
							if (hasClass(pEl, "pika-single")) {
								return
							}
						} while (pEl = pEl.parentNode);
						if (!self._c) {
							self._b = sto(function () {
								self.hide()
							}, 50)
						}
						self._c = false
					};
					self._onClick = function (e) {
						e = e || window.event;
						var target = e.target || e.srcElement,
							pEl = target;
						if (!target) {
							return
						}
						if (!hasEventListeners && hasClass(target, "pika-select")) {
							if (!target.onchange) {
								target.setAttribute("onchange", "return;");
								addEvent(target, "change", self._onChange)
							}
						}
						do {
							if (hasClass(pEl, "pika-single") || pEl === opts.trigger) {
								return
							}
						} while (pEl = pEl.parentNode);
						if (self._v && target !== opts.trigger && pEl !== opts.trigger) {
							self.hide()
						}
					};
					self.el = document.createElement("div");
					self.el.className = "pika-single" + (opts.isRTL ? " is-rtl" : "") + (opts.theme ? " " + opts.theme : "");
					addEvent(self.el, "mousedown", self._onMouseDown, true);
					addEvent(self.el, "touchend", self._onMouseDown, true);
					addEvent(self.el, "change", self._onChange);
					if (opts.keyboardInput) {
						addEvent(document, "keydown", self._onKeyChange)
					}
					if (opts.field) {
						if (opts.container) {
							opts.container.appendChild(self.el)
						} else if (opts.bound) {
							document.body.appendChild(self.el)
						} else {
							opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling)
						}
						addEvent(opts.field, "change", self._onInputChange);
						if (!opts.defaultDate) {
							opts.defaultDate = self._parseFieldValue();
							opts.setDefaultDate = true
						}
					}
					var defDate = opts.defaultDate;
					if (isDate(defDate)) {
						if (opts.setDefaultDate) {
							self.setDate(defDate, true)
						} else {
							self.gotoDate(defDate)
						}
					} else {
						self.gotoDate(new Date)
					}
					if (opts.bound) {
						this.hide();
						self.el.className += " is-bound";
						addEvent(opts.trigger, "click", self._onInputClick);
						addEvent(opts.trigger, "focus", self._onInputFocus);
						addEvent(opts.trigger, "blur", self._onInputBlur)
					} else {
						this.show()
					}
				};
			Pikaday.prototype = {
				config: function (options) {
					if (!this._o) {
						this._o = extend({}, defaults, true)
					}
					var opts = extend(this._o, options, true);
					opts.isRTL = !!opts.isRTL;
					opts.field = opts.field && opts.field.nodeName ? opts.field : null;
					opts.theme = typeof opts.theme === "string" && opts.theme ? opts.theme : null;
					opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);
					opts.trigger = opts.trigger && opts.trigger.nodeName ? opts.trigger : opts.field;
					opts.disableWeekends = !!opts.disableWeekends;
					opts.disableDayFn = typeof opts.disableDayFn === "function" ? opts.disableDayFn : null;
					var nom = parseInt(opts.numberOfMonths, 10) || 1;
					opts.numberOfMonths = nom > 4 ? 4 : nom;
					if (!isDate(opts.minDate)) {
						opts.minDate = false
					}
					if (!isDate(opts.maxDate)) {
						opts.maxDate = false
					}
					if (opts.minDate && opts.maxDate && opts.maxDate < opts.minDate) {
						opts.maxDate = opts.minDate = false
					}
					if (opts.minDate) {
						this.setMinDate(opts.minDate)
					}
					if (opts.maxDate) {
						this.setMaxDate(opts.maxDate)
					}
					if (isArray(opts.yearRange)) {
						var fallback = (new Date).getFullYear() - 10;
						opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
						opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback
					} else {
						opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
						if (opts.yearRange > 100) {
							opts.yearRange = 100
						}
					}
					return opts
				},
				toString: function (format) {
					format = format || this._o.format;
					if (!isDate(this._d)) {
						return ""
					}
					if (this._o.toString) {
						return this._o.toString(this._d, format)
					}
					if (hasMoment) {
						return moment(this._d).format(format)
					}
					return this._d.toDateString()
				},
				getMoment: function () {
					return hasMoment ? moment(this._d) : null
				},
				setMoment: function (date, preventOnSelect) {
					if (hasMoment && moment.isMoment(date)) {
						this.setDate(date.toDate(), preventOnSelect)
					}
				},
				getDate: function () {
					return isDate(this._d) ? new Date(this._d.getTime()) : null
				},
				setDate: function (date, preventOnSelect) {
					if (!date) {
						this._d = null;
						if (this._o.field) {
							this._o.field.value = "";
							fireEvent(this._o.field, "change", {
								firedBy: this
							})
						}
						return this.draw()
					}
					if (typeof date === "string") {
						date = new Date(Date.parse(date))
					}
					if (!isDate(date)) {
						return
					}
					var min = this._o.minDate,
						max = this._o.maxDate;
					if (isDate(min) && date < min) {
						date = min
					} else if (isDate(max) && date > max) {
						date = max
					}
					this._d = new Date(date.getTime());
					setToStartOfDay(this._d);
					this.gotoDate(this._d);
					if (this._o.field) {
						this._o.field.value = this.toString();
						fireEvent(this._o.field, "change", {
							firedBy: this
						})
					}
					if (!preventOnSelect && typeof this._o.onSelect === "function") {
						this._o.onSelect.call(this, this.getDate())
					}
				},
				clear: function () {
					this.setDate(null)
				},
				gotoDate: function (date) {
					var newCalendar = true;
					if (!isDate(date)) {
						return
					}
					if (this.calendars) {
						var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
							lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1),
							visibleDate = date.getTime();
						lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
						lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
						newCalendar = visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate
					}
					if (newCalendar) {
						this.calendars = [{
							month: date.getMonth(),
							year: date.getFullYear()
						}];
						if (this._o.mainCalendar === "right") {
							this.calendars[0].month += 1 - this._o.numberOfMonths
						}
					}
					this.adjustCalendars()
				},
				adjustDate: function (sign, days) {
					var day = this.getDate() || new Date;
					var difference = parseInt(days) * 24 * 60 * 60 * 1e3;
					var newDay;
					if (sign === "add") {
						newDay = new Date(day.valueOf() + difference)
					} else if (sign === "subtract") {
						newDay = new Date(day.valueOf() - difference)
					}
					this.setDate(newDay)
				},
				adjustCalendars: function () {
					this.calendars[0] = adjustCalendar(this.calendars[0]);
					for (var c = 1; c < this._o.numberOfMonths; c++) {
						this.calendars[c] = adjustCalendar({
							month: this.calendars[0].month + c,
							year: this.calendars[0].year
						})
					}
					this.draw()
				},
				gotoToday: function () {
					this.gotoDate(new Date)
				},
				gotoMonth: function (month) {
					if (!isNaN(month)) {
						this.calendars[0].month = parseInt(month, 10);
						this.adjustCalendars()
					}
				},
				nextMonth: function () {
					this.calendars[0].month++;
					this.adjustCalendars()
				},
				prevMonth: function () {
					this.calendars[0].month--;
					this.adjustCalendars()
				},
				gotoYear: function (year) {
					if (!isNaN(year)) {
						this.calendars[0].year = parseInt(year, 10);
						this.adjustCalendars()
					}
				},
				setMinDate: function (value) {
					if (value instanceof Date) {
						setToStartOfDay(value);
						this._o.minDate = value;
						this._o.minYear = value.getFullYear();
						this._o.minMonth = value.getMonth()
					} else {
						this._o.minDate = defaults.minDate;
						this._o.minYear = defaults.minYear;
						this._o.minMonth = defaults.minMonth;
						this._o.startRange = defaults.startRange
					}
					this.draw()
				},
				setMaxDate: function (value) {
					if (value instanceof Date) {
						setToStartOfDay(value);
						this._o.maxDate = value;
						this._o.maxYear = value.getFullYear();
						this._o.maxMonth = value.getMonth()
					} else {
						this._o.maxDate = defaults.maxDate;
						this._o.maxYear = defaults.maxYear;
						this._o.maxMonth = defaults.maxMonth;
						this._o.endRange = defaults.endRange
					}
					this.draw()
				},
				setStartRange: function (value) {
					this._o.startRange = value
				},
				setEndRange: function (value) {
					this._o.endRange = value
				},
				draw: function (force) {
					if (!this._v && !force) {
						return
					}
					var opts = this._o,
						minYear = opts.minYear,
						maxYear = opts.maxYear,
						minMonth = opts.minMonth,
						maxMonth = opts.maxMonth,
						html = "",
						randId;
					if (this._y <= minYear) {
						this._y = minYear;
						if (!isNaN(minMonth) && this._m < minMonth) {
							this._m = minMonth
						}
					}
					if (this._y >= maxYear) {
						this._y = maxYear;
						if (!isNaN(maxMonth) && this._m > maxMonth) {
							this._m = maxMonth
						}
					}
					for (var c = 0; c < opts.numberOfMonths; c++) {
						randId = "pika-title-" + Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 2);
						html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId) + "</div>"
					}
					this.el.innerHTML = html;
					if (opts.bound) {
						if (opts.field.type !== "hidden") {
							sto(function () {
								opts.trigger.focus()
							}, 1)
						}
					}
					if (typeof this._o.onDraw === "function") {
						this._o.onDraw(this)
					}
					if (opts.bound) {
						opts.field.setAttribute("aria-label", opts.ariaLabel)
					}
				},
				adjustPosition: function () {
					var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect, leftAligned, bottomAligned;
					if (this._o.container) return;
					this.el.style.position = "absolute";
					field = this._o.trigger;
					pEl = field;
					width = this.el.offsetWidth;
					height = this.el.offsetHeight;
					viewportWidth = window.innerWidth || document.documentElement.clientWidth;
					viewportHeight = window.innerHeight || document.documentElement.clientHeight;
					scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;
					leftAligned = true;
					bottomAligned = true;
					if (typeof field.getBoundingClientRect === "function") {
						clientRect = field.getBoundingClientRect();
						left = clientRect.left + window.pageXOffset;
						top = clientRect.bottom + window.pageYOffset
					} else {
						left = pEl.offsetLeft;
						top = pEl.offsetTop + pEl.offsetHeight;
						while (pEl = pEl.offsetParent) {
							left += pEl.offsetLeft;
							top += pEl.offsetTop
						}
					}
					if (this._o.reposition && left + width > viewportWidth || this._o.position.indexOf("right") > -1 && left - width + field.offsetWidth > 0) {
						left = left - width + field.offsetWidth;
						leftAligned = false
					}
					if (this._o.reposition && top + height > viewportHeight + scrollTop || this._o.position.indexOf("top") > -1 && top - height - field.offsetHeight > 0) {
						top = top - height - field.offsetHeight;
						bottomAligned = false
					}
					this.el.style.left = left + "px";
					this.el.style.top = top + "px";
					addClass(this.el, leftAligned ? "left-aligned" : "right-aligned");
					addClass(this.el, bottomAligned ? "bottom-aligned" : "top-aligned");
					removeClass(this.el, !leftAligned ? "left-aligned" : "right-aligned");
					removeClass(this.el, !bottomAligned ? "bottom-aligned" : "top-aligned")
				},
				render: function (year, month, randId) {
					var opts = this._o,
						now = new Date,
						days = getDaysInMonth(year, month),
						before = new Date(year, month, 1).getDay(),
						data = [],
						row = [];
					setToStartOfDay(now);
					if (opts.firstDay > 0) {
						before -= opts.firstDay;
						if (before < 0) {
							before += 7
						}
					}
					var previousMonth = month === 0 ? 11 : month - 1,
						nextMonth = month === 11 ? 0 : month + 1,
						yearOfPreviousMonth = month === 0 ? year - 1 : year,
						yearOfNextMonth = month === 11 ? year + 1 : year,
						daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, previousMonth);
					var cells = days + before,
						after = cells;
					while (after > 7) {
						after -= 7
					}
					cells += 7 - after;
					var isWeekSelected = false;
					for (var i = 0, r = 0; i < cells; i++) {
						var day = new Date(year, month, 1 + (i - before)),
							isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
							isToday = compareDates(day, now),
							hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false,
							isEmpty = i < before || i >= days + before,
							dayNumber = 1 + (i - before),
							monthNumber = month,
							yearNumber = year,
							isStartRange = opts.startRange && compareDates(opts.startRange, day),
							isEndRange = opts.endRange && compareDates(opts.endRange, day),
							isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
							isDisabled = opts.minDate && day < opts.minDate || opts.maxDate && day > opts.maxDate || opts.disableWeekends && isWeekend(day) || opts.disableDayFn && opts.disableDayFn(day);
						if (isEmpty) {
							if (i < before) {
								dayNumber = daysInPreviousMonth + dayNumber;
								monthNumber = previousMonth;
								yearNumber = yearOfPreviousMonth
							} else {
								dayNumber = dayNumber - days;
								monthNumber = nextMonth;
								yearNumber = yearOfNextMonth
							}
						}
						var dayConfig = {
							day: dayNumber,
							month: monthNumber,
							year: yearNumber,
							hasEvent: hasEvent,
							isSelected: isSelected,
							isToday: isToday,
							isDisabled: isDisabled,
							isEmpty: isEmpty,
							isStartRange: isStartRange,
							isEndRange: isEndRange,
							isInRange: isInRange,
							showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
							enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
						};
						if (opts.pickWholeWeek && isSelected) {
							isWeekSelected = true
						}
						row.push(renderDay(dayConfig));
						if (++r === 7) {
							if (opts.showWeekNumber) {
								row.unshift(renderWeek(i - before, month, year, opts.firstWeekOfYearMinDays))
							}
							data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
							row = [];
							r = 0;
							isWeekSelected = false
						}
					}
					return renderTable(opts, data, randId)
				},
				isVisible: function () {
					return this._v
				},
				show: function () {
					if (!this.isVisible()) {
						this._v = true;
						this.draw();
						removeClass(this.el, "is-hidden");
						if (this._o.bound) {
							addEvent(document, "click", this._onClick);
							this.adjustPosition()
						}
						if (typeof this._o.onOpen === "function") {
							this._o.onOpen.call(this)
						}
					}
				},
				hide: function () {
					var v = this._v;
					if (v !== false) {
						if (this._o.bound) {
							removeEvent(document, "click", this._onClick)
						}
						if (!this._o.container) {
							this.el.style.position = "static";
							this.el.style.left = "auto";
							this.el.style.top = "auto"
						}
						addClass(this.el, "is-hidden");
						this._v = false;
						if (v !== undefined && typeof this._o.onClose === "function") {
							this._o.onClose.call(this)
						}
					}
				},
				destroy: function () {
					var opts = this._o;
					this.hide();
					removeEvent(this.el, "mousedown", this._onMouseDown, true);
					removeEvent(this.el, "touchend", this._onMouseDown, true);
					removeEvent(this.el, "change", this._onChange);
					if (opts.keyboardInput) {
						removeEvent(document, "keydown", this._onKeyChange)
					}
					if (opts.field) {
						removeEvent(opts.field, "change", this._onInputChange);
						if (opts.bound) {
							removeEvent(opts.trigger, "click", this._onInputClick);
							removeEvent(opts.trigger, "focus", this._onInputFocus);
							removeEvent(opts.trigger, "blur", this._onInputBlur)
						}
					}
					if (this.el.parentNode) {
						this.el.parentNode.removeChild(this.el)
					}
				}
			};
			return Pikaday
		})
	}, {
		moment: 32
	}],
	42: [function (require, module, exports) {
		(function (global) {
			(function () {
				(function (global, factory) {
					typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.Popper = factory()
				})(this, function () {
					"use strict";
					var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
					var longerTimeoutBrowsers = ["Edge", "Trident", "Firefox"];
					var timeoutDuration = 0;
					for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
						if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
							timeoutDuration = 1;
							break
						}
					}

					function microtaskDebounce(fn) {
						var called = false;
						return function () {
							if (called) {
								return
							}
							called = true;
							window.Promise.resolve().then(function () {
								called = false;
								fn()
							})
						}
					}

					function taskDebounce(fn) {
						var scheduled = false;
						return function () {
							if (!scheduled) {
								scheduled = true;
								setTimeout(function () {
									scheduled = false;
									fn()
								}, timeoutDuration)
							}
						}
					}
					var supportsMicroTasks = isBrowser && window.Promise;
					var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

					function isFunction(functionToCheck) {
						var getType = {};
						return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]"
					}

					function getStyleComputedProperty(element, property) {
						if (element.nodeType !== 1) {
							return []
						}
						var window = element.ownerDocument.defaultView;
						var css = window.getComputedStyle(element, null);
						return property ? css[property] : css
					}

					function getParentNode(element) {
						if (element.nodeName === "HTML") {
							return element
						}
						return element.parentNode || element.host
					}

					function getScrollParent(element) {
						if (!element) {
							return document.body
						}
						switch (element.nodeName) {
							case "HTML":
							case "BODY":
								return element.ownerDocument.body;
							case "#document":
								return element.body
						}
						var _getStyleComputedProp = getStyleComputedProperty(element),
							overflow = _getStyleComputedProp.overflow,
							overflowX = _getStyleComputedProp.overflowX,
							overflowY = _getStyleComputedProp.overflowY;
						if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
							return element
						}
						return getScrollParent(getParentNode(element))
					}
					var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
					var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

					function isIE(version) {
						if (version === 11) {
							return isIE11
						}
						if (version === 10) {
							return isIE10
						}
						return isIE11 || isIE10
					}

					function getOffsetParent(element) {
						if (!element) {
							return document.documentElement
						}
						var noOffsetParent = isIE(10) ? document.body : null;
						var offsetParent = element.offsetParent || null;
						while (offsetParent === noOffsetParent && element.nextElementSibling) {
							offsetParent = (element = element.nextElementSibling).offsetParent
						}
						var nodeName = offsetParent && offsetParent.nodeName;
						if (!nodeName || nodeName === "BODY" || nodeName === "HTML") {
							return element ? element.ownerDocument.documentElement : document.documentElement
						}
						if (["TH", "TD", "TABLE"].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, "position") === "static") {
							return getOffsetParent(offsetParent)
						}
						return offsetParent
					}

					function isOffsetContainer(element) {
						var nodeName = element.nodeName;
						if (nodeName === "BODY") {
							return false
						}
						return nodeName === "HTML" || getOffsetParent(element.firstElementChild) === element
					}

					function getRoot(node) {
						if (node.parentNode !== null) {
							return getRoot(node.parentNode)
						}
						return node
					}

					function findCommonOffsetParent(element1, element2) {
						if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
							return document.documentElement
						}
						var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
						var start = order ? element1 : element2;
						var end = order ? element2 : element1;
						var range = document.createRange();
						range.setStart(start, 0);
						range.setEnd(end, 0);
						var commonAncestorContainer = range.commonAncestorContainer;
						if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
							if (isOffsetContainer(commonAncestorContainer)) {
								return commonAncestorContainer
							}
							return getOffsetParent(commonAncestorContainer)
						}
						var element1root = getRoot(element1);
						if (element1root.host) {
							return findCommonOffsetParent(element1root.host, element2)
						} else {
							return findCommonOffsetParent(element1, getRoot(element2).host)
						}
					}

					function getScroll(element) {
						var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "top";
						var upperSide = side === "top" ? "scrollTop" : "scrollLeft";
						var nodeName = element.nodeName;
						if (nodeName === "BODY" || nodeName === "HTML") {
							var html = element.ownerDocument.documentElement;
							var scrollingElement = element.ownerDocument.scrollingElement || html;
							return scrollingElement[upperSide]
						}
						return element[upperSide]
					}

					function includeScroll(rect, element) {
						var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
						var scrollTop = getScroll(element, "top");
						var scrollLeft = getScroll(element, "left");
						var modifier = subtract ? -1 : 1;
						rect.top += scrollTop * modifier;
						rect.bottom += scrollTop * modifier;
						rect.left += scrollLeft * modifier;
						rect.right += scrollLeft * modifier;
						return rect
					}

					function getBordersSize(styles, axis) {
						var sideA = axis === "x" ? "Left" : "Top";
						var sideB = sideA === "Left" ? "Right" : "Bottom";
						return parseFloat(styles["border" + sideA + "Width"], 10) + parseFloat(styles["border" + sideB + "Width"], 10)
					}

					function getSize(axis, body, html, computedStyle) {
						return Math.max(body["offset" + axis], body["scroll" + axis], html["client" + axis], html["offset" + axis], html["scroll" + axis], isIE(10) ? parseInt(html["offset" + axis]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Top" : "Left")]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Bottom" : "Right")]) : 0)
					}

					function getWindowSizes(document) {
						var body = document.body;
						var html = document.documentElement;
						var computedStyle = isIE(10) && getComputedStyle(html);
						return {
							height: getSize("Height", body, html, computedStyle),
							width: getSize("Width", body, html, computedStyle)
						}
					}
					var classCallCheck = function (instance, Constructor) {
						if (!(instance instanceof Constructor)) {
							throw new TypeError("Cannot call a class as a function")
						}
					};
					var createClass = function () {
						function defineProperties(target, props) {
							for (var i = 0; i < props.length; i++) {
								var descriptor = props[i];
								descriptor.enumerable = descriptor.enumerable || false;
								descriptor.configurable = true;
								if ("value" in descriptor) descriptor.writable = true;
								Object.defineProperty(target, descriptor.key, descriptor)
							}
						}
						return function (Constructor, protoProps, staticProps) {
							if (protoProps) defineProperties(Constructor.prototype, protoProps);
							if (staticProps) defineProperties(Constructor, staticProps);
							return Constructor
						}
					}();
					var defineProperty = function (obj, key, value) {
						if (key in obj) {
							Object.defineProperty(obj, key, {
								value: value,
								enumerable: true,
								configurable: true,
								writable: true
							})
						} else {
							obj[key] = value
						}
						return obj
					};
					var _extends = Object.assign || function (target) {
						for (var i = 1; i < arguments.length; i++) {
							var source = arguments[i];
							for (var key in source) {
								if (Object.prototype.hasOwnProperty.call(source, key)) {
									target[key] = source[key]
								}
							}
						}
						return target
					};

					function getClientRect(offsets) {
						return _extends({}, offsets, {
							right: offsets.left + offsets.width,
							bottom: offsets.top + offsets.height
						})
					}

					function getBoundingClientRect(element) {
						var rect = {};
						try {
							if (isIE(10)) {
								rect = element.getBoundingClientRect();
								var scrollTop = getScroll(element, "top");
								var scrollLeft = getScroll(element, "left");
								rect.top += scrollTop;
								rect.left += scrollLeft;
								rect.bottom += scrollTop;
								rect.right += scrollLeft
							} else {
								rect = element.getBoundingClientRect()
							}
						} catch (e) {}
						var result = {
							left: rect.left,
							top: rect.top,
							width: rect.right - rect.left,
							height: rect.bottom - rect.top
						};
						var sizes = element.nodeName === "HTML" ? getWindowSizes(element.ownerDocument) : {};
						var width = sizes.width || element.clientWidth || result.right - result.left;
						var height = sizes.height || element.clientHeight || result.bottom - result.top;
						var horizScrollbar = element.offsetWidth - width;
						var vertScrollbar = element.offsetHeight - height;
						if (horizScrollbar || vertScrollbar) {
							var styles = getStyleComputedProperty(element);
							horizScrollbar -= getBordersSize(styles, "x");
							vertScrollbar -= getBordersSize(styles, "y");
							result.width -= horizScrollbar;
							result.height -= vertScrollbar
						}
						return getClientRect(result)
					}

					function getOffsetRectRelativeToArbitraryNode(children, parent) {
						var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
						var isIE10 = isIE(10);
						var isHTML = parent.nodeName === "HTML";
						var childrenRect = getBoundingClientRect(children);
						var parentRect = getBoundingClientRect(parent);
						var scrollParent = getScrollParent(children);
						var styles = getStyleComputedProperty(parent);
						var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
						var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);
						if (fixedPosition && isHTML) {
							parentRect.top = Math.max(parentRect.top, 0);
							parentRect.left = Math.max(parentRect.left, 0)
						}
						var offsets = getClientRect({
							top: childrenRect.top - parentRect.top - borderTopWidth,
							left: childrenRect.left - parentRect.left - borderLeftWidth,
							width: childrenRect.width,
							height: childrenRect.height
						});
						offsets.marginTop = 0;
						offsets.marginLeft = 0;
						if (!isIE10 && isHTML) {
							var marginTop = parseFloat(styles.marginTop, 10);
							var marginLeft = parseFloat(styles.marginLeft, 10);
							offsets.top -= borderTopWidth - marginTop;
							offsets.bottom -= borderTopWidth - marginTop;
							offsets.left -= borderLeftWidth - marginLeft;
							offsets.right -= borderLeftWidth - marginLeft;
							offsets.marginTop = marginTop;
							offsets.marginLeft = marginLeft
						}
						if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== "BODY") {
							offsets = includeScroll(offsets, parent)
						}
						return offsets
					}

					function getViewportOffsetRectRelativeToArtbitraryNode(element) {
						var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
						var html = element.ownerDocument.documentElement;
						var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
						var width = Math.max(html.clientWidth, window.innerWidth || 0);
						var height = Math.max(html.clientHeight, window.innerHeight || 0);
						var scrollTop = !excludeScroll ? getScroll(html) : 0;
						var scrollLeft = !excludeScroll ? getScroll(html, "left") : 0;
						var offset = {
							top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
							left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
							width: width,
							height: height
						};
						return getClientRect(offset)
					}

					function isFixed(element) {
						var nodeName = element.nodeName;
						if (nodeName === "BODY" || nodeName === "HTML") {
							return false
						}
						if (getStyleComputedProperty(element, "position") === "fixed") {
							return true
						}
						return isFixed(getParentNode(element))
					}

					function getFixedPositionOffsetParent(element) {
						if (!element || !element.parentElement || isIE()) {
							return document.documentElement
						}
						var el = element.parentElement;
						while (el && getStyleComputedProperty(el, "transform") === "none") {
							el = el.parentElement
						}
						return el || document.documentElement
					}

					function getBoundaries(popper, reference, padding, boundariesElement) {
						var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
						var boundaries = {
							top: 0,
							left: 0
						};
						var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
						if (boundariesElement === "viewport") {
							boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition)
						} else {
							var boundariesNode = void 0;
							if (boundariesElement === "scrollParent") {
								boundariesNode = getScrollParent(getParentNode(reference));
								if (boundariesNode.nodeName === "BODY") {
									boundariesNode = popper.ownerDocument.documentElement
								}
							} else if (boundariesElement === "window") {
								boundariesNode = popper.ownerDocument.documentElement
							} else {
								boundariesNode = boundariesElement
							}
							var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
							if (boundariesNode.nodeName === "HTML" && !isFixed(offsetParent)) {
								var _getWindowSizes = getWindowSizes(popper.ownerDocument),
									height = _getWindowSizes.height,
									width = _getWindowSizes.width;
								boundaries.top += offsets.top - offsets.marginTop;
								boundaries.bottom = height + offsets.top;
								boundaries.left += offsets.left - offsets.marginLeft;
								boundaries.right = width + offsets.left
							} else {
								boundaries = offsets
							}
						}
						padding = padding || 0;
						var isPaddingNumber = typeof padding === "number";
						boundaries.left += isPaddingNumber ? padding : padding.left || 0;
						boundaries.top += isPaddingNumber ? padding : padding.top || 0;
						boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
						boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
						return boundaries
					}

					function getArea(_ref) {
						var width = _ref.width,
							height = _ref.height;
						return width * height
					}

					function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
						var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
						if (placement.indexOf("auto") === -1) {
							return placement
						}
						var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
						var rects = {
							top: {
								width: boundaries.width,
								height: refRect.top - boundaries.top
							},
							right: {
								width: boundaries.right - refRect.right,
								height: boundaries.height
							},
							bottom: {
								width: boundaries.width,
								height: boundaries.bottom - refRect.bottom
							},
							left: {
								width: refRect.left - boundaries.left,
								height: boundaries.height
							}
						};
						var sortedAreas = Object.keys(rects).map(function (key) {
							return _extends({
								key: key
							}, rects[key], {
								area: getArea(rects[key])
							})
						}).sort(function (a, b) {
							return b.area - a.area
						});
						var filteredAreas = sortedAreas.filter(function (_ref2) {
							var width = _ref2.width,
								height = _ref2.height;
							return width >= popper.clientWidth && height >= popper.clientHeight
						});
						var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
						var variation = placement.split("-")[1];
						return computedPlacement + (variation ? "-" + variation : "")
					}

					function getReferenceOffsets(state, popper, reference) {
						var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
						var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
						return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition)
					}

					function getOuterSizes(element) {
						var window = element.ownerDocument.defaultView;
						var styles = window.getComputedStyle(element);
						var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
						var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
						var result = {
							width: element.offsetWidth + y,
							height: element.offsetHeight + x
						};
						return result
					}

					function getOppositePlacement(placement) {
						var hash = {
							left: "right",
							right: "left",
							bottom: "top",
							top: "bottom"
						};
						return placement.replace(/left|right|bottom|top/g, function (matched) {
							return hash[matched]
						})
					}

					function getPopperOffsets(popper, referenceOffsets, placement) {
						placement = placement.split("-")[0];
						var popperRect = getOuterSizes(popper);
						var popperOffsets = {
							width: popperRect.width,
							height: popperRect.height
						};
						var isHoriz = ["right", "left"].indexOf(placement) !== -1;
						var mainSide = isHoriz ? "top" : "left";
						var secondarySide = isHoriz ? "left" : "top";
						var measurement = isHoriz ? "height" : "width";
						var secondaryMeasurement = !isHoriz ? "height" : "width";
						popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
						if (placement === secondarySide) {
							popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement]
						} else {
							popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)]
						}
						return popperOffsets
					}

					function find(arr, check) {
						if (Array.prototype.find) {
							return arr.find(check)
						}
						return arr.filter(check)[0]
					}

					function findIndex(arr, prop, value) {
						if (Array.prototype.findIndex) {
							return arr.findIndex(function (cur) {
								return cur[prop] === value
							})
						}
						var match = find(arr, function (obj) {
							return obj[prop] === value
						});
						return arr.indexOf(match)
					}

					function runModifiers(modifiers, data, ends) {
						var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, "name", ends));
						modifiersToRun.forEach(function (modifier) {
							if (modifier["function"]) {
								console.warn("`modifier.function` is deprecated, use `modifier.fn`!")
							}
							var fn = modifier["function"] || modifier.fn;
							if (modifier.enabled && isFunction(fn)) {
								data.offsets.popper = getClientRect(data.offsets.popper);
								data.offsets.reference = getClientRect(data.offsets.reference);
								data = fn(data, modifier)
							}
						});
						return data
					}

					function update() {
						if (this.state.isDestroyed) {
							return
						}
						var data = {
							instance: this,
							styles: {},
							arrowStyles: {},
							attributes: {},
							flipped: false,
							offsets: {}
						};
						data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
						data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
						data.originalPlacement = data.placement;
						data.positionFixed = this.options.positionFixed;
						data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
						data.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute";
						data = runModifiers(this.modifiers, data);
						if (!this.state.isCreated) {
							this.state.isCreated = true;
							this.options.onCreate(data)
						} else {
							this.options.onUpdate(data)
						}
					}

					function isModifierEnabled(modifiers, modifierName) {
						return modifiers.some(function (_ref) {
							var name = _ref.name,
								enabled = _ref.enabled;
							return enabled && name === modifierName
						})
					}

					function getSupportedPropertyName(property) {
						var prefixes = [false, "ms", "Webkit", "Moz", "O"];
						var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
						for (var i = 0; i < prefixes.length; i++) {
							var prefix = prefixes[i];
							var toCheck = prefix ? "" + prefix + upperProp : property;
							if (typeof document.body.style[toCheck] !== "undefined") {
								return toCheck
							}
						}
						return null
					}

					function destroy() {
						this.state.isDestroyed = true;
						if (isModifierEnabled(this.modifiers, "applyStyle")) {
							this.popper.removeAttribute("x-placement");
							this.popper.style.position = "";
							this.popper.style.top = "";
							this.popper.style.left = "";
							this.popper.style.right = "";
							this.popper.style.bottom = "";
							this.popper.style.willChange = "";
							this.popper.style[getSupportedPropertyName("transform")] = ""
						}
						this.disableEventListeners();
						if (this.options.removeOnDestroy) {
							this.popper.parentNode.removeChild(this.popper)
						}
						return this
					}

					function getWindow(element) {
						var ownerDocument = element.ownerDocument;
						return ownerDocument ? ownerDocument.defaultView : window
					}

					function attachToScrollParents(scrollParent, event, callback, scrollParents) {
						var isBody = scrollParent.nodeName === "BODY";
						var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
						target.addEventListener(event, callback, {
							passive: true
						});
						if (!isBody) {
							attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents)
						}
						scrollParents.push(target)
					}

					function setupEventListeners(reference, options, state, updateBound) {
						state.updateBound = updateBound;
						getWindow(reference).addEventListener("resize", state.updateBound, {
							passive: true
						});
						var scrollElement = getScrollParent(reference);
						attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents);
						state.scrollElement = scrollElement;
						state.eventsEnabled = true;
						return state
					}

					function enableEventListeners() {
						if (!this.state.eventsEnabled) {
							this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate)
						}
					}

					function removeEventListeners(reference, state) {
						getWindow(reference).removeEventListener("resize", state.updateBound);
						state.scrollParents.forEach(function (target) {
							target.removeEventListener("scroll", state.updateBound)
						});
						state.updateBound = null;
						state.scrollParents = [];
						state.scrollElement = null;
						state.eventsEnabled = false;
						return state
					}

					function disableEventListeners() {
						if (this.state.eventsEnabled) {
							cancelAnimationFrame(this.scheduleUpdate);
							this.state = removeEventListeners(this.reference, this.state)
						}
					}

					function isNumeric(n) {
						return n !== "" && !isNaN(parseFloat(n)) && isFinite(n)
					}

					function setStyles(element, styles) {
						Object.keys(styles).forEach(function (prop) {
							var unit = "";
							if (["width", "height", "top", "right", "bottom", "left"].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
								unit = "px"
							}
							element.style[prop] = styles[prop] + unit
						})
					}

					function setAttributes(element, attributes) {
						Object.keys(attributes).forEach(function (prop) {
							var value = attributes[prop];
							if (value !== false) {
								element.setAttribute(prop, attributes[prop])
							} else {
								element.removeAttribute(prop)
							}
						})
					}

					function applyStyle(data) {
						setStyles(data.instance.popper, data.styles);
						setAttributes(data.instance.popper, data.attributes);
						if (data.arrowElement && Object.keys(data.arrowStyles).length) {
							setStyles(data.arrowElement, data.arrowStyles)
						}
						return data
					}

					function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
						var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
						var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
						popper.setAttribute("x-placement", placement);
						setStyles(popper, {
							position: options.positionFixed ? "fixed" : "absolute"
						});
						return options
					}

					function getRoundedOffsets(data, shouldRound) {
						var _data$offsets = data.offsets,
							popper = _data$offsets.popper,
							reference = _data$offsets.reference;
						var isVertical = ["left", "right"].indexOf(data.placement) !== -1;
						var isVariation = data.placement.indexOf("-") !== -1;
						var sameWidthOddness = reference.width % 2 === popper.width % 2;
						var bothOddWidth = reference.width % 2 === 1 && popper.width % 2 === 1;
						var noRound = function noRound(v) {
							return v
						};
						var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthOddness ? Math.round : Math.floor;
						var verticalToInteger = !shouldRound ? noRound : Math.round;
						return {
							left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
							top: verticalToInteger(popper.top),
							bottom: verticalToInteger(popper.bottom),
							right: horizontalToInteger(popper.right)
						}
					}
					var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

					function computeStyle(data, options) {
						var x = options.x,
							y = options.y;
						var popper = data.offsets.popper;
						var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
							return modifier.name === "applyStyle"
						}).gpuAcceleration;
						if (legacyGpuAccelerationOption !== undefined) {
							console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!")
						}
						var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
						var offsetParent = getOffsetParent(data.instance.popper);
						var offsetParentRect = getBoundingClientRect(offsetParent);
						var styles = {
							position: popper.position
						};
						var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
						var sideA = x === "bottom" ? "top" : "bottom";
						var sideB = y === "right" ? "left" : "right";
						var prefixedProperty = getSupportedPropertyName("transform");
						var left = void 0,
							top = void 0;
						if (sideA === "bottom") {
							if (offsetParent.nodeName === "HTML") {
								top = -offsetParent.clientHeight + offsets.bottom
							} else {
								top = -offsetParentRect.height + offsets.bottom
							}
						} else {
							top = offsets.top
						}
						if (sideB === "right") {
							if (offsetParent.nodeName === "HTML") {
								left = -offsetParent.clientWidth + offsets.right
							} else {
								left = -offsetParentRect.width + offsets.right
							}
						} else {
							left = offsets.left
						}
						if (gpuAcceleration && prefixedProperty) {
							styles[prefixedProperty] = "translate3d(" + left + "px, " + top + "px, 0)";
							styles[sideA] = 0;
							styles[sideB] = 0;
							styles.willChange = "transform"
						} else {
							var invertTop = sideA === "bottom" ? -1 : 1;
							var invertLeft = sideB === "right" ? -1 : 1;
							styles[sideA] = top * invertTop;
							styles[sideB] = left * invertLeft;
							styles.willChange = sideA + ", " + sideB
						}
						var attributes = {
							"x-placement": data.placement
						};
						data.attributes = _extends({}, attributes, data.attributes);
						data.styles = _extends({}, styles, data.styles);
						data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
						return data
					}

					function isModifierRequired(modifiers, requestingName, requestedName) {
						var requesting = find(modifiers, function (_ref) {
							var name = _ref.name;
							return name === requestingName
						});
						var isRequired = !!requesting && modifiers.some(function (modifier) {
							return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order
						});
						if (!isRequired) {
							var _requesting = "`" + requestingName + "`";
							var requested = "`" + requestedName + "`";
							console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!")
						}
						return isRequired
					}

					function arrow(data, options) {
						var _data$offsets$arrow;
						if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) {
							return data
						}
						var arrowElement = options.element;
						if (typeof arrowElement === "string") {
							arrowElement = data.instance.popper.querySelector(arrowElement);
							if (!arrowElement) {
								return data
							}
						} else {
							if (!data.instance.popper.contains(arrowElement)) {
								console.warn("WARNING: `arrow.element` must be child of its popper element!");
								return data
							}
						}
						var placement = data.placement.split("-")[0];
						var _data$offsets = data.offsets,
							popper = _data$offsets.popper,
							reference = _data$offsets.reference;
						var isVertical = ["left", "right"].indexOf(placement) !== -1;
						var len = isVertical ? "height" : "width";
						var sideCapitalized = isVertical ? "Top" : "Left";
						var side = sideCapitalized.toLowerCase();
						var altSide = isVertical ? "left" : "top";
						var opSide = isVertical ? "bottom" : "right";
						var arrowElementSize = getOuterSizes(arrowElement)[len];
						if (reference[opSide] - arrowElementSize < popper[side]) {
							data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize)
						}
						if (reference[side] + arrowElementSize > popper[opSide]) {
							data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide]
						}
						data.offsets.popper = getClientRect(data.offsets.popper);
						var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
						var css = getStyleComputedProperty(data.instance.popper);
						var popperMarginSide = parseFloat(css["margin" + sideCapitalized], 10);
						var popperBorderSide = parseFloat(css["border" + sideCapitalized + "Width"], 10);
						var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
						sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
						data.arrowElement = arrowElement;
						data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ""), _data$offsets$arrow);
						return data
					}

					function getOppositeVariation(variation) {
						if (variation === "end") {
							return "start"
						} else if (variation === "start") {
							return "end"
						}
						return variation
					}
					var placements = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"];
					var validPlacements = placements.slice(3);

					function clockwise(placement) {
						var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
						var index = validPlacements.indexOf(placement);
						var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
						return counter ? arr.reverse() : arr
					}
					var BEHAVIORS = {
						FLIP: "flip",
						CLOCKWISE: "clockwise",
						COUNTERCLOCKWISE: "counterclockwise"
					};

					function flip(data, options) {
						if (isModifierEnabled(data.instance.modifiers, "inner")) {
							return data
						}
						if (data.flipped && data.placement === data.originalPlacement) {
							return data
						}
						var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
						var placement = data.placement.split("-")[0];
						var placementOpposite = getOppositePlacement(placement);
						var variation = data.placement.split("-")[1] || "";
						var flipOrder = [];
						switch (options.behavior) {
							case BEHAVIORS.FLIP:
								flipOrder = [placement, placementOpposite];
								break;
							case BEHAVIORS.CLOCKWISE:
								flipOrder = clockwise(placement);
								break;
							case BEHAVIORS.COUNTERCLOCKWISE:
								flipOrder = clockwise(placement, true);
								break;
							default:
								flipOrder = options.behavior
						}
						flipOrder.forEach(function (step, index) {
							if (placement !== step || flipOrder.length === index + 1) {
								return data
							}
							placement = data.placement.split("-")[0];
							placementOpposite = getOppositePlacement(placement);
							var popperOffsets = data.offsets.popper;
							var refOffsets = data.offsets.reference;
							var floor = Math.floor;
							var overlapsRef = placement === "left" && floor(popperOffsets.right) > floor(refOffsets.left) || placement === "right" && floor(popperOffsets.left) < floor(refOffsets.right) || placement === "top" && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === "bottom" && floor(popperOffsets.top) < floor(refOffsets.bottom);
							var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
							var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
							var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
							var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
							var overflowsBoundaries = placement === "left" && overflowsLeft || placement === "right" && overflowsRight || placement === "top" && overflowsTop || placement === "bottom" && overflowsBottom;
							var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
							var flippedVariation = !!options.flipVariations && (isVertical && variation === "start" && overflowsLeft || isVertical && variation === "end" && overflowsRight || !isVertical && variation === "start" && overflowsTop || !isVertical && variation === "end" && overflowsBottom);
							if (overlapsRef || overflowsBoundaries || flippedVariation) {
								data.flipped = true;
								if (overlapsRef || overflowsBoundaries) {
									placement = flipOrder[index + 1]
								}
								if (flippedVariation) {
									variation = getOppositeVariation(variation)
								}
								data.placement = placement + (variation ? "-" + variation : "");
								data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
								data = runModifiers(data.instance.modifiers, data, "flip")
							}
						});
						return data
					}

					function keepTogether(data) {
						var _data$offsets = data.offsets,
							popper = _data$offsets.popper,
							reference = _data$offsets.reference;
						var placement = data.placement.split("-")[0];
						var floor = Math.floor;
						var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
						var side = isVertical ? "right" : "bottom";
						var opSide = isVertical ? "left" : "top";
						var measurement = isVertical ? "width" : "height";
						if (popper[side] < floor(reference[opSide])) {
							data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement]
						}
						if (popper[opSide] > floor(reference[side])) {
							data.offsets.popper[opSide] = floor(reference[side])
						}
						return data
					}

					function toValue(str, measurement, popperOffsets, referenceOffsets) {
						var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
						var value = +split[1];
						var unit = split[2];
						if (!value) {
							return str
						}
						if (unit.indexOf("%") === 0) {
							var element = void 0;
							switch (unit) {
								case "%p":
									element = popperOffsets;
									break;
								case "%":
								case "%r":
								default:
									element = referenceOffsets
							}
							var rect = getClientRect(element);
							return rect[measurement] / 100 * value
						} else if (unit === "vh" || unit === "vw") {
							var size = void 0;
							if (unit === "vh") {
								size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
							} else {
								size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0)
							}
							return size / 100 * value
						} else {
							return value
						}
					}

					function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
						var offsets = [0, 0];
						var useHeight = ["right", "left"].indexOf(basePlacement) !== -1;
						var fragments = offset.split(/(\+|\-)/).map(function (frag) {
							return frag.trim()
						});
						var divider = fragments.indexOf(find(fragments, function (frag) {
							return frag.search(/,|\s/) !== -1
						}));
						if (fragments[divider] && fragments[divider].indexOf(",") === -1) {
							console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.")
						}
						var splitRegex = /\s*,\s*|\s+/;
						var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
						ops = ops.map(function (op, index) {
							var measurement = (index === 1 ? !useHeight : useHeight) ? "height" : "width";
							var mergeWithPrevious = false;
							return op.reduce(function (a, b) {
								if (a[a.length - 1] === "" && ["+", "-"].indexOf(b) !== -1) {
									a[a.length - 1] = b;
									mergeWithPrevious = true;
									return a
								} else if (mergeWithPrevious) {
									a[a.length - 1] += b;
									mergeWithPrevious = false;
									return a
								} else {
									return a.concat(b)
								}
							}, []).map(function (str) {
								return toValue(str, measurement, popperOffsets, referenceOffsets)
							})
						});
						ops.forEach(function (op, index) {
							op.forEach(function (frag, index2) {
								if (isNumeric(frag)) {
									offsets[index] += frag * (op[index2 - 1] === "-" ? -1 : 1)
								}
							})
						});
						return offsets
					}

					function offset(data, _ref) {
						var offset = _ref.offset;
						var placement = data.placement,
							_data$offsets = data.offsets,
							popper = _data$offsets.popper,
							reference = _data$offsets.reference;
						var basePlacement = placement.split("-")[0];
						var offsets = void 0;
						if (isNumeric(+offset)) {
							offsets = [+offset, 0]
						} else {
							offsets = parseOffset(offset, popper, reference, basePlacement)
						}
						if (basePlacement === "left") {
							popper.top += offsets[0];
							popper.left -= offsets[1]
						} else if (basePlacement === "right") {
							popper.top += offsets[0];
							popper.left += offsets[1]
						} else if (basePlacement === "top") {
							popper.left += offsets[0];
							popper.top -= offsets[1]
						} else if (basePlacement === "bottom") {
							popper.left += offsets[0];
							popper.top += offsets[1]
						}
						data.popper = popper;
						return data
					}

					function preventOverflow(data, options) {
						var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
						if (data.instance.reference === boundariesElement) {
							boundariesElement = getOffsetParent(boundariesElement)
						}
						var transformProp = getSupportedPropertyName("transform");
						var popperStyles = data.instance.popper.style;
						var top = popperStyles.top,
							left = popperStyles.left,
							transform = popperStyles[transformProp];
						popperStyles.top = "";
						popperStyles.left = "";
						popperStyles[transformProp] = "";
						var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
						popperStyles.top = top;
						popperStyles.left = left;
						popperStyles[transformProp] = transform;
						options.boundaries = boundaries;
						var order = options.priority;
						var popper = data.offsets.popper;
						var check = {
							primary: function primary(placement) {
								var value = popper[placement];
								if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
									value = Math.max(popper[placement], boundaries[placement])
								}
								return defineProperty({}, placement, value)
							},
							secondary: function secondary(placement) {
								var mainSide = placement === "right" ? "left" : "top";
								var value = popper[mainSide];
								if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
									value = Math.min(popper[mainSide], boundaries[placement] - (placement === "right" ? popper.width : popper.height))
								}
								return defineProperty({}, mainSide, value)
							}
						};
						order.forEach(function (placement) {
							var side = ["left", "top"].indexOf(placement) !== -1 ? "primary" : "secondary";
							popper = _extends({}, popper, check[side](placement))
						});
						data.offsets.popper = popper;
						return data
					}

					function shift(data) {
						var placement = data.placement;
						var basePlacement = placement.split("-")[0];
						var shiftvariation = placement.split("-")[1];
						if (shiftvariation) {
							var _data$offsets = data.offsets,
								reference = _data$offsets.reference,
								popper = _data$offsets.popper;
							var isVertical = ["bottom", "top"].indexOf(basePlacement) !== -1;
							var side = isVertical ? "left" : "top";
							var measurement = isVertical ? "width" : "height";
							var shiftOffsets = {
								start: defineProperty({}, side, reference[side]),
								end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
							};
							data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation])
						}
						return data
					}

					function hide(data) {
						if (!isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")) {
							return data
						}
						var refRect = data.offsets.reference;
						var bound = find(data.instance.modifiers, function (modifier) {
							return modifier.name === "preventOverflow"
						}).boundaries;
						if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
							if (data.hide === true) {
								return data
							}
							data.hide = true;
							data.attributes["x-out-of-boundaries"] = ""
						} else {
							if (data.hide === false) {
								return data
							}
							data.hide = false;
							data.attributes["x-out-of-boundaries"] = false
						}
						return data
					}

					function inner(data) {
						var placement = data.placement;
						var basePlacement = placement.split("-")[0];
						var _data$offsets = data.offsets,
							popper = _data$offsets.popper,
							reference = _data$offsets.reference;
						var isHoriz = ["left", "right"].indexOf(basePlacement) !== -1;
						var subtractLength = ["top", "left"].indexOf(basePlacement) === -1;
						popper[isHoriz ? "left" : "top"] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? "width" : "height"] : 0);
						data.placement = getOppositePlacement(placement);
						data.offsets.popper = getClientRect(popper);
						return data
					}
					var modifiers = {
						shift: {
							order: 100,
							enabled: true,
							fn: shift
						},
						offset: {
							order: 200,
							enabled: true,
							fn: offset,
							offset: 0
						},
						preventOverflow: {
							order: 300,
							enabled: true,
							fn: preventOverflow,
							priority: ["left", "right", "top", "bottom"],
							padding: 5,
							boundariesElement: "scrollParent"
						},
						keepTogether: {
							order: 400,
							enabled: true,
							fn: keepTogether
						},
						arrow: {
							order: 500,
							enabled: true,
							fn: arrow,
							element: "[x-arrow]"
						},
						flip: {
							order: 600,
							enabled: true,
							fn: flip,
							behavior: "flip",
							padding: 5,
							boundariesElement: "viewport"
						},
						inner: {
							order: 700,
							enabled: false,
							fn: inner
						},
						hide: {
							order: 800,
							enabled: true,
							fn: hide
						},
						computeStyle: {
							order: 850,
							enabled: true,
							fn: computeStyle,
							gpuAcceleration: true,
							x: "bottom",
							y: "right"
						},
						applyStyle: {
							order: 900,
							enabled: true,
							fn: applyStyle,
							onLoad: applyStyleOnLoad,
							gpuAcceleration: undefined
						}
					};
					var Defaults = {
						placement: "bottom",
						positionFixed: false,
						eventsEnabled: true,
						removeOnDestroy: false,
						onCreate: function onCreate() {},
						onUpdate: function onUpdate() {},
						modifiers: modifiers
					};
					var Popper = function () {
						function Popper(reference, popper) {
							var _this = this;
							var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
							classCallCheck(this, Popper);
							this.scheduleUpdate = function () {
								return requestAnimationFrame(_this.update)
							};
							this.update = debounce(this.update.bind(this));
							this.options = _extends({}, Popper.Defaults, options);
							this.state = {
								isDestroyed: false,
								isCreated: false,
								scrollParents: []
							};
							this.reference = reference && reference.jquery ? reference[0] : reference;
							this.popper = popper && popper.jquery ? popper[0] : popper;
							this.options.modifiers = {};
							Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
								_this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {})
							});
							this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
								return _extends({
									name: name
								}, _this.options.modifiers[name])
							}).sort(function (a, b) {
								return a.order - b.order
							});
							this.modifiers.forEach(function (modifierOptions) {
								if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
									modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state)
								}
							});
							this.update();
							var eventsEnabled = this.options.eventsEnabled;
							if (eventsEnabled) {
								this.enableEventListeners()
							}
							this.state.eventsEnabled = eventsEnabled
						}
						createClass(Popper, [{
							key: "update",
							value: function update$$1() {
								return update.call(this)
							}
						}, {
							key: "destroy",
							value: function destroy$$1() {
								return destroy.call(this)
							}
						}, {
							key: "enableEventListeners",
							value: function enableEventListeners$$1() {
								return enableEventListeners.call(this)
							}
						}, {
							key: "disableEventListeners",
							value: function disableEventListeners$$1() {
								return disableEventListeners.call(this)
							}
						}]);
						return Popper
					}();
					Popper.Utils = (typeof window !== "undefined" ? window : global).PopperUtils;
					Popper.placements = placements;
					Popper.Defaults = Defaults;
					return Popper
				})
			}).call(this)
		}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	}, {}],
	43: [function (require, module, exports) {
		var process = module.exports = {};
		var cachedSetTimeout;
		var cachedClearTimeout;

		function defaultSetTimout() {
			throw new Error("setTimeout has not been defined")
		}

		function defaultClearTimeout() {
			throw new Error("clearTimeout has not been defined")
		}(function () {
			try {
				if (typeof setTimeout === "function") {
					cachedSetTimeout = setTimeout
				} else {
					cachedSetTimeout = defaultSetTimout
				}
			} catch (e) {
				cachedSetTimeout = defaultSetTimout
			}
			try {
				if (typeof clearTimeout === "function") {
					cachedClearTimeout = clearTimeout
				} else {
					cachedClearTimeout = defaultClearTimeout
				}
			} catch (e) {
				cachedClearTimeout = defaultClearTimeout
			}
		})();

		function runTimeout(fun) {
			if (cachedSetTimeout === setTimeout) {
				return setTimeout(fun, 0)
			}
			if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
				cachedSetTimeout = setTimeout;
				return setTimeout(fun, 0)
			}
			try {
				return cachedSetTimeout(fun, 0)
			} catch (e) {
				try {
					return cachedSetTimeout.call(null, fun, 0)
				} catch (e) {
					return cachedSetTimeout.call(this, fun, 0)
				}
			}
		}

		function runClearTimeout(marker) {
			if (cachedClearTimeout === clearTimeout) {
				return clearTimeout(marker)
			}
			if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
				cachedClearTimeout = clearTimeout;
				return clearTimeout(marker)
			}
			try {
				return cachedClearTimeout(marker)
			} catch (e) {
				try {
					return cachedClearTimeout.call(null, marker)
				} catch (e) {
					return cachedClearTimeout.call(this, marker)
				}
			}
		}
		var queue = [];
		var draining = false;
		var currentQueue;
		var queueIndex = -1;

		function cleanUpNextTick() {
			if (!draining || !currentQueue) {
				return
			}
			draining = false;
			if (currentQueue.length) {
				queue = currentQueue.concat(queue)
			} else {
				queueIndex = -1
			}
			if (queue.length) {
				drainQueue()
			}
		}

		function drainQueue() {
			if (draining) {
				return
			}
			var timeout = runTimeout(cleanUpNextTick);
			draining = true;
			var len = queue.length;
			while (len) {
				currentQueue = queue;
				queue = [];
				while (++queueIndex < len) {
					if (currentQueue) {
						currentQueue[queueIndex].run()
					}
				}
				queueIndex = -1;
				len = queue.length
			}
			currentQueue = null;
			draining = false;
			runClearTimeout(timeout)
		}
		process.nextTick = function (fun) {
			var args = new Array(arguments.length - 1);
			if (arguments.length > 1) {
				for (var i = 1; i < arguments.length; i++) {
					args[i - 1] = arguments[i]
				}
			}
			queue.push(new Item(fun, args));
			if (queue.length === 1 && !draining) {
				runTimeout(drainQueue)
			}
		};

		function Item(fun, array) {
			this.fun = fun;
			this.array = array
		}
		Item.prototype.run = function () {
			this.fun.apply(null, this.array)
		};
		process.title = "browser";
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = "";
		process.versions = {};

		function noop() {}
		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;
		process.prependListener = noop;
		process.prependOnceListener = noop;
		process.listeners = function (name) {
			return []
		};
		process.binding = function (name) {
			throw new Error("process.binding is not supported")
		};
		process.cwd = function () {
			return "/"
		};
		process.chdir = function (dir) {
			throw new Error("process.chdir is not supported")
		};
		process.umask = function () {
			return 0
		}
	}, {}],
	44: [function (require, module, exports) {
		(function (global, factory) {
			typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.scrollama = factory()
		})(this, function () {
			"use strict";

			function selectAll(selector, parent) {
				if (parent === void 0) parent = document;
				if (typeof selector === "string") {
					return Array.from(parent.querySelectorAll(selector))
				} else if (selector instanceof Element) {
					return [selector]
				} else if (selector instanceof NodeList) {
					return Array.from(selector)
				} else if (selector instanceof Array) {
					return selector
				}
				return []
			}

			function getOffsetId(id) {
				return "scrollama__debug-offset--" + id
			}

			function setupOffset(ref) {
				var id = ref.id;
				var offsetVal = ref.offsetVal;
				var stepClass = ref.stepClass;
				var el = document.createElement("div");
				el.id = getOffsetId(id);
				el.className = "scrollama__debug-offset";
				el.style.position = "fixed";
				el.style.left = "0";
				el.style.width = "100%";
				el.style.height = "0";
				el.style.borderTop = "2px dashed black";
				el.style.zIndex = "9999";
				var p = document.createElement("p");
				p.innerHTML = '".' + stepClass + '" trigger: <span>' + offsetVal + "</span>";
				p.style.fontSize = "12px";
				p.style.fontFamily = "monospace";
				p.style.color = "black";
				p.style.margin = "0";
				p.style.padding = "6px";
				el.appendChild(p);
				document.body.appendChild(el)
			}

			function setup(ref) {
				var id = ref.id;
				var offsetVal = ref.offsetVal;
				var stepEl = ref.stepEl;
				var stepClass = stepEl[0].className;
				setupOffset({
					id: id,
					offsetVal: offsetVal,
					stepClass: stepClass
				})
			}

			function update(ref) {
				var id = ref.id;
				var offsetMargin = ref.offsetMargin;
				var offsetVal = ref.offsetVal;
				var format = ref.format;
				var post = format === "pixels" ? "px" : "";
				var idVal = getOffsetId(id);
				var el = document.getElementById(idVal);
				el.style.top = offsetMargin + "px";
				el.querySelector("span").innerText = "" + offsetVal + post
			}

			function notifyStep(ref) {
				var id = ref.id;
				var index = ref.index;
				var state = ref.state;
				var prefix = "scrollama__debug-step--" + id + "-" + index;
				var elA = document.getElementById(prefix + "_above");
				var elB = document.getElementById(prefix + "_below");
				var display = state === "enter" ? "block" : "none";
				if (elA) {
					elA.style.display = display
				}
				if (elB) {
					elB.style.display = display
				}
			}

			function scrollama() {
				var OBSERVER_NAMES = ["stepAbove", "stepBelow", "stepProgress", "viewportAbove", "viewportBelow"];
				var cb = {};
				var io = {};
				var id = null;
				var stepEl = [];
				var stepOffsetHeight = [];
				var stepOffsetTop = [];
				var stepStates = [];
				var offsetVal = 0;
				var offsetMargin = 0;
				var viewH = 0;
				var pageH = 0;
				var previousYOffset = 0;
				var progressThreshold = 0;
				var isReady = false;
				var isEnabled = false;
				var isDebug = false;
				var progressMode = false;
				var preserveOrder = false;
				var triggerOnce = false;
				var direction = "down";
				var format = "percent";
				var exclude = [];

				function err(msg) {
					console.error("scrollama error: " + msg)
				}

				function reset() {
					cb = {
						stepEnter: function () {},
						stepExit: function () {},
						stepProgress: function () {}
					};
					io = {}
				}

				function generateInstanceID() {
					var a = "abcdefghijklmnopqrstuv";
					var l = a.length;
					var t = Date.now();
					var r = [0, 0, 0].map(function (d) {
						return a[Math.floor(Math.random() * l)]
					}).join("");
					return "" + r + t
				}

				function getOffsetTop(el) {
					var ref = el.getBoundingClientRect();
					var top = ref.top;
					var scrollTop = window.pageYOffset;
					var clientTop = document.body.clientTop || 0;
					return top + scrollTop - clientTop
				}

				function getPageHeight() {
					var body = document.body;
					var html = document.documentElement;
					return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight)
				}

				function getIndex(element) {
					return +element.getAttribute("data-scrollama-index")
				}

				function updateDirection() {
					if (window.pageYOffset > previousYOffset) {
						direction = "down"
					} else if (window.pageYOffset < previousYOffset) {
						direction = "up"
					}
					previousYOffset = window.pageYOffset
				}

				function disconnectObserver(name) {
					if (io[name]) {
						io[name].forEach(function (d) {
							return d.disconnect()
						})
					}
				}

				function handleResize() {
					viewH = window.innerHeight;
					pageH = getPageHeight();
					var mult = format === "pixels" ? 1 : viewH;
					offsetMargin = offsetVal * mult;
					if (isReady) {
						stepOffsetHeight = stepEl.map(function (el) {
							return el.getBoundingClientRect().height
						});
						stepOffsetTop = stepEl.map(getOffsetTop);
						if (isEnabled) {
							updateIO()
						}
					}
					if (isDebug) {
						update({
							id: id,
							offsetMargin: offsetMargin,
							offsetVal: offsetVal,
							format: format
						})
					}
				}

				function handleEnable(enable) {
					if (enable && !isEnabled) {
						if (isReady) {
							updateIO()
						} else {
							err("scrollama error: enable() called before scroller was ready");
							isEnabled = false;
							return
						}
					}
					if (!enable && isEnabled) {
						OBSERVER_NAMES.forEach(disconnectObserver)
					}
					isEnabled = enable
				}

				function createThreshold(height) {
					var count = Math.ceil(height / progressThreshold);
					var t = [];
					var ratio = 1 / count;
					for (var i = 0; i < count; i += 1) {
						t.push(i * ratio)
					}
					return t
				}

				function notifyStepProgress(element, progress) {
					var index = getIndex(element);
					if (progress !== undefined) {
						stepStates[index].progress = progress
					}
					var resp = {
						element: element,
						index: index,
						progress: stepStates[index].progress
					};
					if (stepStates[index].state === "enter") {
						cb.stepProgress(resp)
					}
				}

				function notifyOthers(index, location) {
					if (location === "above") {
						for (var i = 0; i < index; i += 1) {
							var ss = stepStates[i];
							if (ss.state !== "enter" && ss.direction !== "down") {
								notifyStepEnter(stepEl[i], "down", false);
								notifyStepExit(stepEl[i], "down")
							} else if (ss.state === "enter") {
								notifyStepExit(stepEl[i], "down")
							}
						}
					} else if (location === "below") {
						for (var i$1 = stepStates.length - 1; i$1 > index; i$1 -= 1) {
							var ss$1 = stepStates[i$1];
							if (ss$1.state === "enter") {
								notifyStepExit(stepEl[i$1], "up")
							}
							if (ss$1.direction === "down") {
								notifyStepEnter(stepEl[i$1], "up", false);
								notifyStepExit(stepEl[i$1], "up")
							}
						}
					}
				}

				function notifyStepEnter(element, dir, check) {
					if (check === void 0) check = true;
					var index = getIndex(element);
					var resp = {
						element: element,
						index: index,
						direction: dir
					};
					stepStates[index].direction = dir;
					stepStates[index].state = "enter";
					if (preserveOrder && check && dir === "down") {
						notifyOthers(index, "above")
					}
					if (preserveOrder && check && dir === "up") {
						notifyOthers(index, "below")
					}
					if (cb.stepEnter && !exclude[index]) {
						cb.stepEnter(resp, stepStates);
						if (isDebug) {
							notifyStep({
								id: id,
								index: index,
								state: "enter"
							})
						}
						if (triggerOnce) {
							exclude[index] = true
						}
					}
					if (progressMode) {
						notifyStepProgress(element)
					}
				}

				function notifyStepExit(element, dir) {
					var index = getIndex(element);
					var resp = {
						element: element,
						index: index,
						direction: dir
					};
					if (progressMode) {
						if (dir === "down" && stepStates[index].progress < 1) {
							notifyStepProgress(element, 1)
						} else if (dir === "up" && stepStates[index].progress > 0) {
							notifyStepProgress(element, 0)
						}
					}
					stepStates[index].direction = dir;
					stepStates[index].state = "exit";
					cb.stepExit(resp, stepStates);
					if (isDebug) {
						notifyStep({
							id: id,
							index: index,
							state: "exit"
						})
					}
				}

				function intersectStepAbove(ref) {
					var entry = ref[0];
					updateDirection();
					var isIntersecting = entry.isIntersecting;
					var boundingClientRect = entry.boundingClientRect;
					var target = entry.target;
					var top = boundingClientRect.top;
					var bottom = boundingClientRect.bottom;
					var topAdjusted = top - offsetMargin;
					var bottomAdjusted = bottom - offsetMargin;
					var index = getIndex(target);
					var ss = stepStates[index];
					if (isIntersecting && topAdjusted <= 0 && bottomAdjusted >= 0 && direction === "down" && ss.state !== "enter") {
						notifyStepEnter(target, direction)
					}
					if (!isIntersecting && topAdjusted > 0 && direction === "up" && ss.state === "enter") {
						notifyStepExit(target, direction)
					}
				}

				function intersectStepBelow(ref) {
					var entry = ref[0];
					updateDirection();
					var isIntersecting = entry.isIntersecting;
					var boundingClientRect = entry.boundingClientRect;
					var target = entry.target;
					var top = boundingClientRect.top;
					var bottom = boundingClientRect.bottom;
					var topAdjusted = top - offsetMargin;
					var bottomAdjusted = bottom - offsetMargin;
					var index = getIndex(target);
					var ss = stepStates[index];
					if (isIntersecting && topAdjusted <= 0 && bottomAdjusted >= 0 && direction === "up" && ss.state !== "enter") {
						notifyStepEnter(target, direction)
					}
					if (!isIntersecting && bottomAdjusted < 0 && direction === "down" && ss.state === "enter") {
						notifyStepExit(target, direction)
					}
				}

				function intersectViewportAbove(ref) {
					var entry = ref[0];
					updateDirection();
					var isIntersecting = entry.isIntersecting;
					var target = entry.target;
					var index = getIndex(target);
					var ss = stepStates[index];
					if (isIntersecting && direction === "down" && ss.direction !== "down" && ss.state !== "enter") {
						notifyStepEnter(target, "down");
						notifyStepExit(target, "down")
					}
				}

				function intersectViewportBelow(ref) {
					var entry = ref[0];
					updateDirection();
					var isIntersecting = entry.isIntersecting;
					var target = entry.target;
					var index = getIndex(target);
					var ss = stepStates[index];
					if (isIntersecting && direction === "up" && ss.direction === "down" && ss.state !== "enter") {
						notifyStepEnter(target, "up");
						notifyStepExit(target, "up")
					}
				}

				function intersectStepProgress(ref) {
					var entry = ref[0];
					updateDirection();
					var isIntersecting = entry.isIntersecting;
					var intersectionRatio = entry.intersectionRatio;
					var boundingClientRect = entry.boundingClientRect;
					var target = entry.target;
					var bottom = boundingClientRect.bottom;
					var bottomAdjusted = bottom - offsetMargin;
					if (isIntersecting && bottomAdjusted >= 0) {
						notifyStepProgress(target, +intersectionRatio)
					}
				}

				function updateViewportAboveIO() {
					io.viewportAbove = stepEl.map(function (el, i) {
						var marginTop = pageH - stepOffsetTop[i];
						var marginBottom = offsetMargin - viewH - stepOffsetHeight[i];
						var rootMargin = marginTop + "px 0px " + marginBottom + "px 0px";
						var options = {
							rootMargin: rootMargin
						};
						var obs = new IntersectionObserver(intersectViewportAbove, options);
						obs.observe(el);
						return obs
					})
				}

				function updateViewportBelowIO() {
					io.viewportBelow = stepEl.map(function (el, i) {
						var marginTop = -offsetMargin - stepOffsetHeight[i];
						var marginBottom = offsetMargin - viewH + stepOffsetHeight[i] + pageH;
						var rootMargin = marginTop + "px 0px " + marginBottom + "px 0px";
						var options = {
							rootMargin: rootMargin
						};
						var obs = new IntersectionObserver(intersectViewportBelow, options);
						obs.observe(el);
						return obs
					})
				}

				function updateStepAboveIO() {
					io.stepAbove = stepEl.map(function (el, i) {
						var marginTop = -offsetMargin + stepOffsetHeight[i];
						var marginBottom = offsetMargin - viewH;
						var rootMargin = marginTop + "px 0px " + marginBottom + "px 0px";
						var options = {
							rootMargin: rootMargin
						};
						var obs = new IntersectionObserver(intersectStepAbove, options);
						obs.observe(el);
						return obs
					})
				}

				function updateStepBelowIO() {
					io.stepBelow = stepEl.map(function (el, i) {
						var marginTop = -offsetMargin;
						var marginBottom = offsetMargin - viewH + stepOffsetHeight[i];
						var rootMargin = marginTop + "px 0px " + marginBottom + "px 0px";
						var options = {
							rootMargin: rootMargin
						};
						var obs = new IntersectionObserver(intersectStepBelow, options);
						obs.observe(el);
						return obs
					})
				}

				function updateStepProgressIO() {
					io.stepProgress = stepEl.map(function (el, i) {
						var marginTop = stepOffsetHeight[i] - offsetMargin;
						var marginBottom = -viewH + offsetMargin;
						var rootMargin = marginTop + "px 0px " + marginBottom + "px 0px";
						var threshold = createThreshold(stepOffsetHeight[i]);
						var options = {
							rootMargin: rootMargin,
							threshold: threshold
						};
						var obs = new IntersectionObserver(intersectStepProgress, options);
						obs.observe(el);
						return obs
					})
				}

				function updateIO() {
					OBSERVER_NAMES.forEach(disconnectObserver);
					updateViewportAboveIO();
					updateViewportBelowIO();
					updateStepAboveIO();
					updateStepBelowIO();
					if (progressMode) {
						updateStepProgressIO()
					}
				}

				function indexSteps() {
					stepEl.forEach(function (el, i) {
						return el.setAttribute("data-scrollama-index", i)
					})
				}

				function setupStates() {
					stepStates = stepEl.map(function () {
						return {
							direction: null,
							state: null,
							progress: 0
						}
					})
				}

				function addDebug() {
					if (isDebug) {
						setup({
							id: id,
							stepEl: stepEl,
							offsetVal: offsetVal
						})
					}
				}

				function isYScrollable(element) {
					var style = window.getComputedStyle(element);
					return (style.overflowY === "scroll" || style.overflowY === "auto") && element.scrollHeight > element.clientHeight
				}

				function anyScrollableParent(element) {
					if (element && element.nodeType === 1) {
						return isYScrollable(element) ? element : anyScrollableParent(element.parentNode)
					}
					return false
				}
				var S = {};
				S.setup = function (ref) {
					var step = ref.step;
					var parent = ref.parent;
					var offset = ref.offset;
					if (offset === void 0) offset = .5;
					var progress = ref.progress;
					if (progress === void 0) progress = false;
					var threshold = ref.threshold;
					if (threshold === void 0) threshold = 4;
					var debug = ref.debug;
					if (debug === void 0) debug = false;
					var order = ref.order;
					if (order === void 0) order = true;
					var once = ref.once;
					if (once === void 0) once = false;
					reset();
					id = generateInstanceID();
					stepEl = selectAll(step, parent);
					if (!stepEl.length) {
						err("no step elements");
						return S
					}
					var scrollableParent = stepEl.reduce(function (foundScrollable, s) {
						return foundScrollable || anyScrollableParent(s.parentNode)
					}, false);
					if (scrollableParent) {
						console.error("scrollama error: step elements cannot be children of a scrollable element. Remove any css on the parent element with overflow: scroll; or overflow: auto; on elements with fixed height.", scrollableParent)
					}
					isDebug = debug;
					progressMode = progress;
					preserveOrder = order;
					triggerOnce = once;
					S.offsetTrigger(offset);
					progressThreshold = Math.max(1, +threshold);
					isReady = true;
					addDebug();
					indexSteps();
					setupStates();
					handleResize();
					S.enable();
					return S
				};
				S.resize = function () {
					handleResize();
					return S
				};
				S.enable = function () {
					handleEnable(true);
					return S
				};
				S.disable = function () {
					handleEnable(false);
					return S
				};
				S.destroy = function () {
					handleEnable(false);
					reset()
				};
				S.offsetTrigger = function (x) {
					if (x === null) {
						return offsetVal
					}
					if (typeof x === "number") {
						format = "percent";
						if (x > 1) {
							err("offset value is greater than 1. Fallback to 1.")
						}
						if (x < 0) {
							err("offset value is lower than 0. Fallback to 0.")
						}
						offsetVal = Math.min(Math.max(0, x), 1)
					} else if (typeof x === "string" && x.indexOf("px") > 0) {
						var v = +x.replace("px", "");
						if (!isNaN(v)) {
							format = "pixels";
							offsetVal = v
						} else {
							err("offset value must be in 'px' format. Fallback to 0.5.");
							offsetVal = .5
						}
					} else {
						err("offset value does not include 'px'. Fallback to 0.5.");
						offsetVal = .5
					}
					return S
				};
				S.onStepEnter = function (f) {
					if (typeof f === "function") {
						cb.stepEnter = f
					} else {
						err("onStepEnter requires a function")
					}
					return S
				};
				S.onStepExit = function (f) {
					if (typeof f === "function") {
						cb.stepExit = f
					} else {
						err("onStepExit requires a function")
					}
					return S
				};
				S.onStepProgress = function (f) {
					if (typeof f === "function") {
						cb.stepProgress = f
					} else {
						err("onStepProgress requires a function")
					}
					return S
				};
				return S
			}
			return scrollama
		})
	}, {}],
	45: [function (require, module, exports) {
		! function (e, t) {
			"object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("Siema", [], t) : "object" == typeof exports ? exports.Siema = t() : e.Siema = t()
		}("undefined" != typeof self ? self : this, function () {
			return function (e) {
				function t(r) {
					if (i[r]) return i[r].exports;
					var n = i[r] = {
						i: r,
						l: !1,
						exports: {}
					};
					return e[r].call(n.exports, n, n.exports, t), n.l = !0, n.exports
				}
				var i = {};
				return t.m = e, t.c = i, t.d = function (e, i, r) {
					t.o(e, i) || Object.defineProperty(e, i, {
						configurable: !1,
						enumerable: !0,
						get: r
					})
				}, t.n = function (e) {
					var i = e && e.__esModule ? function () {
						return e.default
					} : function () {
						return e
					};
					return t.d(i, "a", i), i
				}, t.o = function (e, t) {
					return Object.prototype.hasOwnProperty.call(e, t)
				}, t.p = "", t(t.s = 0)
			}([function (e, t, i) {
				"use strict";

				function r(e, t) {
					if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
				}
				Object.defineProperty(t, "__esModule", {
					value: !0
				});
				var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
						return typeof e
					} : function (e) {
						return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
					},
					s = function () {
						function e(e, t) {
							for (var i = 0; i < t.length; i++) {
								var r = t[i];
								r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
							}
						}
						return function (t, i, r) {
							return i && e(t.prototype, i), r && e(t, r), t
						}
					}(),
					l = function () {
						function e(t) {
							var i = this;
							if (r(this, e), this.config = e.mergeSettings(t), this.selector = "string" == typeof this.config.selector ? document.querySelector(this.config.selector) : this.config.selector, null === this.selector) throw new Error("Something wrong with your selector 😭");
							this.resolveSlidesNumber(), this.selectorWidth = this.selector.offsetWidth, this.innerElements = [].slice.call(this.selector.children), this.currentSlide = this.config.loop ? this.config.startIndex % this.innerElements.length : Math.max(0, Math.min(this.config.startIndex, this.innerElements.length - this.perPage)), this.transformProperty = e.webkitOrNot(), ["resizeHandler", "touchstartHandler", "touchendHandler", "touchmoveHandler", "mousedownHandler", "mouseupHandler", "mouseleaveHandler", "mousemoveHandler", "clickHandler"].forEach(function (e) {
								i[e] = i[e].bind(i)
							}), this.init()
						}
						return s(e, [{
							key: "attachEvents",
							value: function () {
								window.addEventListener("resize", this.resizeHandler), this.config.draggable && (this.pointerDown = !1, this.drag = {
									startX: 0,
									endX: 0,
									startY: 0,
									letItGo: null,
									preventClick: !1
								}, this.selector.addEventListener("touchstart", this.touchstartHandler), this.selector.addEventListener("touchend", this.touchendHandler), this.selector.addEventListener("touchmove", this.touchmoveHandler), this.selector.addEventListener("mousedown", this.mousedownHandler), this.selector.addEventListener("mouseup", this.mouseupHandler), this.selector.addEventListener("mouseleave", this.mouseleaveHandler), this.selector.addEventListener("mousemove", this.mousemoveHandler), this.selector.addEventListener("click", this.clickHandler))
							}
						}, {
							key: "detachEvents",
							value: function () {
								window.removeEventListener("resize", this.resizeHandler), this.selector.removeEventListener("touchstart", this.touchstartHandler), this.selector.removeEventListener("touchend", this.touchendHandler), this.selector.removeEventListener("touchmove", this.touchmoveHandler), this.selector.removeEventListener("mousedown", this.mousedownHandler), this.selector.removeEventListener("mouseup", this.mouseupHandler), this.selector.removeEventListener("mouseleave", this.mouseleaveHandler), this.selector.removeEventListener("mousemove", this.mousemoveHandler), this.selector.removeEventListener("click", this.clickHandler)
							}
						}, {
							key: "init",
							value: function () {
								this.attachEvents(), this.selector.style.overflow = "hidden", this.selector.style.direction = this.config.rtl ? "rtl" : "ltr", this.buildSliderFrame(), this.config.onInit.call(this)
							}
						}, {
							key: "buildSliderFrame",
							value: function () {
								var e = this.selectorWidth / this.perPage,
									t = this.config.loop ? this.innerElements.length + 2 * this.perPage : this.innerElements.length;
								this.sliderFrame = document.createElement("div"), this.sliderFrame.style.width = e * t + "px", this.enableTransition(), this.config.draggable && (this.selector.style.cursor = "-webkit-grab");
								var i = document.createDocumentFragment();
								if (this.config.loop)
									for (var r = this.innerElements.length - this.perPage; r < this.innerElements.length; r++) {
										var n = this.buildSliderFrameItem(this.innerElements[r].cloneNode(!0));
										i.appendChild(n)
									}
								for (var s = 0; s < this.innerElements.length; s++) {
									var l = this.buildSliderFrameItem(this.innerElements[s]);
									i.appendChild(l)
								}
								if (this.config.loop)
									for (var o = 0; o < this.perPage; o++) {
										var a = this.buildSliderFrameItem(this.innerElements[o].cloneNode(!0));
										i.appendChild(a)
									}
								this.sliderFrame.appendChild(i), this.selector.innerHTML = "", this.selector.appendChild(this.sliderFrame), this.slideToCurrent()
							}
						}, {
							key: "buildSliderFrameItem",
							value: function (e) {
								var t = document.createElement("div");
								return t.style.cssFloat = this.config.rtl ? "right" : "left", t.style.float = this.config.rtl ? "right" : "left", t.style.width = (this.config.loop ? 100 / (this.innerElements.length + 2 * this.perPage) : 100 / this.innerElements.length) + "%", t.appendChild(e), t
							}
						}, {
							key: "resolveSlidesNumber",
							value: function () {
								if ("number" == typeof this.config.perPage) this.perPage = this.config.perPage;
								else if ("object" === n(this.config.perPage)) {
									this.perPage = 1;
									for (var e in this.config.perPage) window.innerWidth >= e && (this.perPage = this.config.perPage[e])
								}
							}
						}, {
							key: "prev",
							value: function () {
								var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
									t = arguments[1];
								if (!(this.innerElements.length <= this.perPage)) {
									var i = this.currentSlide;
									if (this.config.loop) {
										if (this.currentSlide - e < 0) {
											this.disableTransition();
											var r = this.currentSlide + this.innerElements.length,
												n = this.perPage,
												s = r + n,
												l = (this.config.rtl ? 1 : -1) * s * (this.selectorWidth / this.perPage),
												o = this.config.draggable ? this.drag.endX - this.drag.startX : 0;
											this.sliderFrame.style[this.transformProperty] = "translate3d(" + (l + o) + "px, 0, 0)", this.currentSlide = r - e
										} else this.currentSlide = this.currentSlide - e
									} else this.currentSlide = Math.max(this.currentSlide - e, 0);
									i !== this.currentSlide && (this.slideToCurrent(this.config.loop), this.config.onChange.call(this), t && t.call(this))
								}
							}
						}, {
							key: "next",
							value: function () {
								var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
									t = arguments[1];
								if (!(this.innerElements.length <= this.perPage)) {
									var i = this.currentSlide;
									if (this.config.loop) {
										if (this.currentSlide + e > this.innerElements.length - this.perPage) {
											this.disableTransition();
											var r = this.currentSlide - this.innerElements.length,
												n = this.perPage,
												s = r + n,
												l = (this.config.rtl ? 1 : -1) * s * (this.selectorWidth / this.perPage),
												o = this.config.draggable ? this.drag.endX - this.drag.startX : 0;
											this.sliderFrame.style[this.transformProperty] = "translate3d(" + (l + o) + "px, 0, 0)", this.currentSlide = r + e
										} else this.currentSlide = this.currentSlide + e
									} else this.currentSlide = Math.min(this.currentSlide + e, this.innerElements.length - this.perPage);
									i !== this.currentSlide && (this.slideToCurrent(this.config.loop), this.config.onChange.call(this), t && t.call(this))
								}
							}
						}, {
							key: "disableTransition",
							value: function () {
								this.sliderFrame.style.webkitTransition = "all 0ms " + this.config.easing, this.sliderFrame.style.transition = "all 0ms " + this.config.easing
							}
						}, {
							key: "enableTransition",
							value: function () {
								this.sliderFrame.style.webkitTransition = "all " + this.config.duration + "ms " + this.config.easing, this.sliderFrame.style.transition = "all " + this.config.duration + "ms " + this.config.easing
							}
						}, {
							key: "goTo",
							value: function (e, t) {
								if (!(this.innerElements.length <= this.perPage)) {
									var i = this.currentSlide;
									this.currentSlide = this.config.loop ? e % this.innerElements.length : Math.min(Math.max(e, 0), this.innerElements.length - this.perPage), i !== this.currentSlide && (this.slideToCurrent(), this.config.onChange.call(this), t && t.call(this))
								}
							}
						}, {
							key: "slideToCurrent",
							value: function (e) {
								var t = this,
									i = this.config.loop ? this.currentSlide + this.perPage : this.currentSlide,
									r = (this.config.rtl ? 1 : -1) * i * (this.selectorWidth / this.perPage);
								e ? requestAnimationFrame(function () {
									requestAnimationFrame(function () {
										t.enableTransition(), t.sliderFrame.style[t.transformProperty] = "translate3d(" + r + "px, 0, 0)"
									})
								}) : this.sliderFrame.style[this.transformProperty] = "translate3d(" + r + "px, 0, 0)"
							}
						}, {
							key: "updateAfterDrag",
							value: function () {
								var e = (this.config.rtl ? -1 : 1) * (this.drag.endX - this.drag.startX),
									t = Math.abs(e),
									i = this.config.multipleDrag ? Math.ceil(t / (this.selectorWidth / this.perPage)) : 1,
									r = e > 0 && this.currentSlide - i < 0,
									n = e < 0 && this.currentSlide + i > this.innerElements.length - this.perPage;
								e > 0 && t > this.config.threshold && this.innerElements.length > this.perPage ? this.prev(i) : e < 0 && t > this.config.threshold && this.innerElements.length > this.perPage && this.next(i), this.slideToCurrent(r || n)
							}
						}, {
							key: "resizeHandler",
							value: function () {
								this.resolveSlidesNumber(), this.currentSlide + this.perPage > this.innerElements.length && (this.currentSlide = this.innerElements.length <= this.perPage ? 0 : this.innerElements.length - this.perPage), this.selectorWidth = this.selector.offsetWidth, this.buildSliderFrame()
							}
						}, {
							key: "clearDrag",
							value: function () {
								this.drag = {
									startX: 0,
									endX: 0,
									startY: 0,
									letItGo: null,
									preventClick: this.drag.preventClick
								}
							}
						}, {
							key: "touchstartHandler",
							value: function (e) {
								-1 !== ["TEXTAREA", "OPTION", "INPUT", "SELECT"].indexOf(e.target.nodeName) || (e.stopPropagation(), this.pointerDown = !0, this.drag.startX = e.touches[0].pageX, this.drag.startY = e.touches[0].pageY)
							}
						}, {
							key: "touchendHandler",
							value: function (e) {
								e.stopPropagation(), this.pointerDown = !1, this.enableTransition(), this.drag.endX && this.updateAfterDrag(), this.clearDrag()
							}
						}, {
							key: "touchmoveHandler",
							value: function (e) {
								if (e.stopPropagation(), null === this.drag.letItGo && (this.drag.letItGo = Math.abs(this.drag.startY - e.touches[0].pageY) < Math.abs(this.drag.startX - e.touches[0].pageX)), this.pointerDown && this.drag.letItGo) {
									e.preventDefault(), this.drag.endX = e.touches[0].pageX, this.sliderFrame.style.webkitTransition = "all 0ms " + this.config.easing, this.sliderFrame.style.transition = "all 0ms " + this.config.easing;
									var t = this.config.loop ? this.currentSlide + this.perPage : this.currentSlide,
										i = t * (this.selectorWidth / this.perPage),
										r = this.drag.endX - this.drag.startX,
										n = this.config.rtl ? i + r : i - r;
									this.sliderFrame.style[this.transformProperty] = "translate3d(" + (this.config.rtl ? 1 : -1) * n + "px, 0, 0)"
								}
							}
						}, {
							key: "mousedownHandler",
							value: function (e) {
								-1 !== ["TEXTAREA", "OPTION", "INPUT", "SELECT"].indexOf(e.target.nodeName) || (e.preventDefault(), e.stopPropagation(), this.pointerDown = !0, this.drag.startX = e.pageX)
							}
						}, {
							key: "mouseupHandler",
							value: function (e) {
								e.stopPropagation(), this.pointerDown = !1, this.selector.style.cursor = "-webkit-grab", this.enableTransition(), this.drag.endX && this.updateAfterDrag(), this.clearDrag()
							}
						}, {
							key: "mousemoveHandler",
							value: function (e) {
								if (e.preventDefault(), this.pointerDown) {
									"A" === e.target.nodeName && (this.drag.preventClick = !0), this.drag.endX = e.pageX, this.selector.style.cursor = "-webkit-grabbing", this.sliderFrame.style.webkitTransition = "all 0ms " + this.config.easing, this.sliderFrame.style.transition = "all 0ms " + this.config.easing;
									var t = this.config.loop ? this.currentSlide + this.perPage : this.currentSlide,
										i = t * (this.selectorWidth / this.perPage),
										r = this.drag.endX - this.drag.startX,
										n = this.config.rtl ? i + r : i - r;
									this.sliderFrame.style[this.transformProperty] = "translate3d(" + (this.config.rtl ? 1 : -1) * n + "px, 0, 0)"
								}
							}
						}, {
							key: "mouseleaveHandler",
							value: function (e) {
								this.pointerDown && (this.pointerDown = !1, this.selector.style.cursor = "-webkit-grab", this.drag.endX = e.pageX, this.drag.preventClick = !1, this.enableTransition(), this.updateAfterDrag(), this.clearDrag())
							}
						}, {
							key: "clickHandler",
							value: function (e) {
								this.drag.preventClick && e.preventDefault(), this.drag.preventClick = !1
							}
						}, {
							key: "remove",
							value: function (e, t) {
								if (e < 0 || e >= this.innerElements.length) throw new Error("Item to remove doesn't exist 😭");
								var i = e < this.currentSlide,
									r = this.currentSlide + this.perPage - 1 === e;
								(i || r) && this.currentSlide--, this.innerElements.splice(e, 1), this.buildSliderFrame(), t && t.call(this)
							}
						}, {
							key: "insert",
							value: function (e, t, i) {
								if (t < 0 || t > this.innerElements.length + 1) throw new Error("Unable to inset it at this index 😭");
								if (-1 !== this.innerElements.indexOf(e)) throw new Error("The same item in a carousel? Really? Nope 😭");
								var r = t <= this.currentSlide > 0 && this.innerElements.length;
								this.currentSlide = r ? this.currentSlide + 1 : this.currentSlide, this.innerElements.splice(t, 0, e), this.buildSliderFrame(), i && i.call(this)
							}
						}, {
							key: "prepend",
							value: function (e, t) {
								this.insert(e, 0), t && t.call(this)
							}
						}, {
							key: "append",
							value: function (e, t) {
								this.insert(e, this.innerElements.length + 1), t && t.call(this)
							}
						}, {
							key: "destroy",
							value: function () {
								var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
									t = arguments[1];
								if (this.detachEvents(), this.selector.style.cursor = "auto", e) {
									for (var i = document.createDocumentFragment(), r = 0; r < this.innerElements.length; r++) i.appendChild(this.innerElements[r]);
									this.selector.innerHTML = "", this.selector.appendChild(i), this.selector.removeAttribute("style")
								}
								t && t.call(this)
							}
						}], [{
							key: "mergeSettings",
							value: function (e) {
								var t = {
										selector: ".siema",
										duration: 200,
										easing: "ease-out",
										perPage: 1,
										startIndex: 0,
										draggable: !0,
										multipleDrag: !0,
										threshold: 20,
										loop: !1,
										rtl: !1,
										onInit: function () {},
										onChange: function () {}
									},
									i = e;
								for (var r in i) t[r] = i[r];
								return t
							}
						}, {
							key: "webkitOrNot",
							value: function () {
								return "string" == typeof document.documentElement.style.transform ? "transform" : "WebkitTransform"
							}
						}]), e
					}();
				t.default = l, e.exports = t.default
			}])
		})
	}, {}],
	46: [function (require, module, exports) {
		(function (global, factory) {
			typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global.WHATWGFetch = {})
		})(this, function (exports) {
			"use strict";
			var global = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
			var support = {
				searchParams: "URLSearchParams" in global,
				iterable: "Symbol" in global && "iterator" in Symbol,
				blob: "FileReader" in global && "Blob" in global && function () {
					try {
						new Blob;
						return true
					} catch (e) {
						return false
					}
				}(),
				formData: "FormData" in global,
				arrayBuffer: "ArrayBuffer" in global
			};

			function isDataView(obj) {
				return obj && DataView.prototype.isPrototypeOf(obj)
			}
			if (support.arrayBuffer) {
				var viewClasses = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"];
				var isArrayBufferView = ArrayBuffer.isView || function (obj) {
					return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
				}
			}

			function normalizeName(name) {
				if (typeof name !== "string") {
					name = String(name)
				}
				if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
					throw new TypeError('Invalid character in header field name: "' + name + '"')
				}
				return name.toLowerCase()
			}

			function normalizeValue(value) {
				if (typeof value !== "string") {
					value = String(value)
				}
				return value
			}

			function iteratorFor(items) {
				var iterator = {
					next: function () {
						var value = items.shift();
						return {
							done: value === undefined,
							value: value
						}
					}
				};
				if (support.iterable) {
					iterator[Symbol.iterator] = function () {
						return iterator
					}
				}
				return iterator
			}

			function Headers(headers) {
				this.map = {};
				if (headers instanceof Headers) {
					headers.forEach(function (value, name) {
						this.append(name, value)
					}, this)
				} else if (Array.isArray(headers)) {
					headers.forEach(function (header) {
						this.append(header[0], header[1])
					}, this)
				} else if (headers) {
					Object.getOwnPropertyNames(headers).forEach(function (name) {
						this.append(name, headers[name])
					}, this)
				}
			}
			Headers.prototype.append = function (name, value) {
				name = normalizeName(name);
				value = normalizeValue(value);
				var oldValue = this.map[name];
				this.map[name] = oldValue ? oldValue + ", " + value : value
			};
			Headers.prototype["delete"] = function (name) {
				delete this.map[normalizeName(name)]
			};
			Headers.prototype.get = function (name) {
				name = normalizeName(name);
				return this.has(name) ? this.map[name] : null
			};
			Headers.prototype.has = function (name) {
				return this.map.hasOwnProperty(normalizeName(name))
			};
			Headers.prototype.set = function (name, value) {
				this.map[normalizeName(name)] = normalizeValue(value)
			};
			Headers.prototype.forEach = function (callback, thisArg) {
				for (var name in this.map) {
					if (this.map.hasOwnProperty(name)) {
						callback.call(thisArg, this.map[name], name, this)
					}
				}
			};
			Headers.prototype.keys = function () {
				var items = [];
				this.forEach(function (value, name) {
					items.push(name)
				});
				return iteratorFor(items)
			};
			Headers.prototype.values = function () {
				var items = [];
				this.forEach(function (value) {
					items.push(value)
				});
				return iteratorFor(items)
			};
			Headers.prototype.entries = function () {
				var items = [];
				this.forEach(function (value, name) {
					items.push([name, value])
				});
				return iteratorFor(items)
			};
			if (support.iterable) {
				Headers.prototype[Symbol.iterator] = Headers.prototype.entries
			}

			function consumed(body) {
				if (body.bodyUsed) {
					return Promise.reject(new TypeError("Already read"))
				}
				body.bodyUsed = true
			}

			function fileReaderReady(reader) {
				return new Promise(function (resolve, reject) {
					reader.onload = function () {
						resolve(reader.result)
					};
					reader.onerror = function () {
						reject(reader.error)
					}
				})
			}

			function readBlobAsArrayBuffer(blob) {
				var reader = new FileReader;
				var promise = fileReaderReady(reader);
				reader.readAsArrayBuffer(blob);
				return promise
			}

			function readBlobAsText(blob) {
				var reader = new FileReader;
				var promise = fileReaderReady(reader);
				reader.readAsText(blob);
				return promise
			}

			function readArrayBufferAsText(buf) {
				var view = new Uint8Array(buf);
				var chars = new Array(view.length);
				for (var i = 0; i < view.length; i++) {
					chars[i] = String.fromCharCode(view[i])
				}
				return chars.join("")
			}

			function bufferClone(buf) {
				if (buf.slice) {
					return buf.slice(0)
				} else {
					var view = new Uint8Array(buf.byteLength);
					view.set(new Uint8Array(buf));
					return view.buffer
				}
			}

			function Body() {
				this.bodyUsed = false;
				this._initBody = function (body) {
					this.bodyUsed = this.bodyUsed;
					this._bodyInit = body;
					if (!body) {
						this._bodyText = ""
					} else if (typeof body === "string") {
						this._bodyText = body
					} else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
						this._bodyBlob = body
					} else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
						this._bodyFormData = body
					} else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
						this._bodyText = body.toString()
					} else if (support.arrayBuffer && support.blob && isDataView(body)) {
						this._bodyArrayBuffer = bufferClone(body.buffer);
						this._bodyInit = new Blob([this._bodyArrayBuffer])
					} else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
						this._bodyArrayBuffer = bufferClone(body)
					} else {
						this._bodyText = body = Object.prototype.toString.call(body)
					}
					if (!this.headers.get("content-type")) {
						if (typeof body === "string") {
							this.headers.set("content-type", "text/plain;charset=UTF-8")
						} else if (this._bodyBlob && this._bodyBlob.type) {
							this.headers.set("content-type", this._bodyBlob.type)
						} else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
							this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8")
						}
					}
				};
				if (support.blob) {
					this.blob = function () {
						var rejected = consumed(this);
						if (rejected) {
							return rejected
						}
						if (this._bodyBlob) {
							return Promise.resolve(this._bodyBlob)
						} else if (this._bodyArrayBuffer) {
							return Promise.resolve(new Blob([this._bodyArrayBuffer]))
						} else if (this._bodyFormData) {
							throw new Error("could not read FormData body as blob")
						} else {
							return Promise.resolve(new Blob([this._bodyText]))
						}
					};
					this.arrayBuffer = function () {
						if (this._bodyArrayBuffer) {
							var isConsumed = consumed(this);
							if (isConsumed) {
								return isConsumed
							}
							if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
								return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength))
							} else {
								return Promise.resolve(this._bodyArrayBuffer)
							}
						} else {
							return this.blob().then(readBlobAsArrayBuffer)
						}
					}
				}
				this.text = function () {
					var rejected = consumed(this);
					if (rejected) {
						return rejected
					}
					if (this._bodyBlob) {
						return readBlobAsText(this._bodyBlob)
					} else if (this._bodyArrayBuffer) {
						return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
					} else if (this._bodyFormData) {
						throw new Error("could not read FormData body as text")
					} else {
						return Promise.resolve(this._bodyText)
					}
				};
				if (support.formData) {
					this.formData = function () {
						return this.text().then(decode)
					}
				}
				this.json = function () {
					return this.text().then(JSON.parse)
				};
				return this
			}
			var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

			function normalizeMethod(method) {
				var upcased = method.toUpperCase();
				return methods.indexOf(upcased) > -1 ? upcased : method
			}

			function Request(input, options) {
				if (!(this instanceof Request)) {
					throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
				}
				options = options || {};
				var body = options.body;
				if (input instanceof Request) {
					if (input.bodyUsed) {
						throw new TypeError("Already read")
					}
					this.url = input.url;
					this.credentials = input.credentials;
					if (!options.headers) {
						this.headers = new Headers(input.headers)
					}
					this.method = input.method;
					this.mode = input.mode;
					this.signal = input.signal;
					if (!body && input._bodyInit != null) {
						body = input._bodyInit;
						input.bodyUsed = true
					}
				} else {
					this.url = String(input)
				}
				this.credentials = options.credentials || this.credentials || "same-origin";
				if (options.headers || !this.headers) {
					this.headers = new Headers(options.headers)
				}
				this.method = normalizeMethod(options.method || this.method || "GET");
				this.mode = options.mode || this.mode || null;
				this.signal = options.signal || this.signal;
				this.referrer = null;
				if ((this.method === "GET" || this.method === "HEAD") && body) {
					throw new TypeError("Body not allowed for GET or HEAD requests")
				}
				this._initBody(body);
				if (this.method === "GET" || this.method === "HEAD") {
					if (options.cache === "no-store" || options.cache === "no-cache") {
						var reParamSearch = /([?&])_=[^&]*/;
						if (reParamSearch.test(this.url)) {
							this.url = this.url.replace(reParamSearch, "$1_=" + (new Date).getTime())
						} else {
							var reQueryString = /\?/;
							this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (new Date).getTime()
						}
					}
				}
			}
			Request.prototype.clone = function () {
				return new Request(this, {
					body: this._bodyInit
				})
			};

			function decode(body) {
				var form = new FormData;
				body.trim().split("&").forEach(function (bytes) {
					if (bytes) {
						var split = bytes.split("=");
						var name = split.shift().replace(/\+/g, " ");
						var value = split.join("=").replace(/\+/g, " ");
						form.append(decodeURIComponent(name), decodeURIComponent(value))
					}
				});
				return form
			}

			function parseHeaders(rawHeaders) {
				var headers = new Headers;
				var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
				preProcessedHeaders.split("\r").map(function (header) {
					return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header
				}).forEach(function (line) {
					var parts = line.split(":");
					var key = parts.shift().trim();
					if (key) {
						var value = parts.join(":").trim();
						headers.append(key, value)
					}
				});
				return headers
			}
			Body.call(Request.prototype);

			function Response(bodyInit, options) {
				if (!(this instanceof Response)) {
					throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
				}
				if (!options) {
					options = {}
				}
				this.type = "default";
				this.status = options.status === undefined ? 200 : options.status;
				this.ok = this.status >= 200 && this.status < 300;
				this.statusText = options.statusText === undefined ? "" : "" + options.statusText;
				this.headers = new Headers(options.headers);
				this.url = options.url || "";
				this._initBody(bodyInit)
			}
			Body.call(Response.prototype);
			Response.prototype.clone = function () {
				return new Response(this._bodyInit, {
					status: this.status,
					statusText: this.statusText,
					headers: new Headers(this.headers),
					url: this.url
				})
			};
			Response.error = function () {
				var response = new Response(null, {
					status: 0,
					statusText: ""
				});
				response.type = "error";
				return response
			};
			var redirectStatuses = [301, 302, 303, 307, 308];
			Response.redirect = function (url, status) {
				if (redirectStatuses.indexOf(status) === -1) {
					throw new RangeError("Invalid status code")
				}
				return new Response(null, {
					status: status,
					headers: {
						location: url
					}
				})
			};
			exports.DOMException = global.DOMException;
			try {
				new exports.DOMException
			} catch (err) {
				exports.DOMException = function (message, name) {
					this.message = message;
					this.name = name;
					var error = Error(message);
					this.stack = error.stack
				};
				exports.DOMException.prototype = Object.create(Error.prototype);
				exports.DOMException.prototype.constructor = exports.DOMException
			}

			function fetch(input, init) {
				return new Promise(function (resolve, reject) {
					var request = new Request(input, init);
					if (request.signal && request.signal.aborted) {
						return reject(new exports.DOMException("Aborted", "AbortError"))
					}
					var xhr = new XMLHttpRequest;

					function abortXhr() {
						xhr.abort()
					}
					xhr.onload = function () {
						var options = {
							status: xhr.status,
							statusText: xhr.statusText,
							headers: parseHeaders(xhr.getAllResponseHeaders() || "")
						};
						options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
						var body = "response" in xhr ? xhr.response : xhr.responseText;
						setTimeout(function () {
							resolve(new Response(body, options))
						}, 0)
					};
					xhr.onerror = function () {
						setTimeout(function () {
							reject(new TypeError("Network request failed"))
						}, 0)
					};
					xhr.ontimeout = function () {
						setTimeout(function () {
							reject(new TypeError("Network request failed"))
						}, 0)
					};
					xhr.onabort = function () {
						setTimeout(function () {
							reject(new exports.DOMException("Aborted", "AbortError"))
						}, 0)
					};

					function fixUrl(url) {
						try {
							return url === "" && global.location.href ? global.location.href : url
						} catch (e) {
							return url
						}
					}
					xhr.open(request.method, fixUrl(request.url), true);
					if (request.credentials === "include") {
						xhr.withCredentials = true
					} else if (request.credentials === "omit") {
						xhr.withCredentials = false
					}
					if ("responseType" in xhr) {
						if (support.blob) {
							xhr.responseType = "blob"
						} else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
							xhr.responseType = "arraybuffer"
						}
					}
					if (init && typeof init.headers === "object" && !(init.headers instanceof Headers)) {
						Object.getOwnPropertyNames(init.headers).forEach(function (name) {
							xhr.setRequestHeader(name, normalizeValue(init.headers[name]))
						})
					} else {
						request.headers.forEach(function (value, name) {
							xhr.setRequestHeader(name, value)
						})
					}
					if (request.signal) {
						request.signal.addEventListener("abort", abortXhr);
						xhr.onreadystatechange = function () {
							if (xhr.readyState === 4) {
								request.signal.removeEventListener("abort", abortXhr)
							}
						}
					}
					xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit)
				})
			}
			fetch.polyfill = true;
			if (!global.fetch) {
				global.fetch = fetch;
				global.Headers = Headers;
				global.Request = Request;
				global.Response = Response
			}
			exports.Headers = Headers;
			exports.Request = Request;
			exports.Response = Response;
			exports.fetch = fetch;
			Object.defineProperty(exports, "__esModule", {
				value: true
			})
		})
	}, {}]
}, {}, [1, 3]);
